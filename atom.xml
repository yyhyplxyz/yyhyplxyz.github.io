<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>元昊的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yyhyplxyz.github.io/"/>
  <updated>2018-12-24T15:33:36.757Z</updated>
  <id>http://yyhyplxyz.github.io/</id>
  
  <author>
    <name>Jack Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker介绍深入浅出(-)</title>
    <link href="http://yyhyplxyz.github.io/2018/12/24/docker%E7%AE%80%E4%BB%8B/"/>
    <id>http://yyhyplxyz.github.io/2018/12/24/docker简介/</id>
    <published>2018-12-24T14:18:40.000Z</published>
    <updated>2018-12-24T15:33:36.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h2><p>镜像和容器是 Docker 中最基本的 2 个概念，镜像相当于光盘， 光盘里面存储的数据是只读的， 不会被更改的。我们可以把镜像找作一个模板或者蓝图，而容器是用镜像生成的 Docker 实例。一个镜像可以生成多个容器， 每个容器之间，容器与宿主机之间都是相互隔离的，同时，容器可以快速方便地运行, 也可以方便地删除。在实际应用中，我们甚至可以把容器当作虚拟机来使用。</p><h2 id="自动部署与Dockerfile"><a href="#自动部署与Dockerfile" class="headerlink" title="自动部署与Dockerfile"></a>自动部署与Dockerfile</h2><p>我们首先需要安装一个docker，这部分内容略，读者可以轻易在网上找到资料，且操作极易。</p><h3 id="运行第一个容器应用"><a href="#运行第一个容器应用" class="headerlink" title="运行第一个容器应用"></a>运行第一个容器应用</h3><p>我们使用下面的命令启动一个 Docker 容器</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span> -d -t -p 8000:5000 -name demo ubuntu:18.04</span><br></pre></td></tr></table></figure><p>这条命令的具体解释如下</p><ul><li><p>run 表示启动一个新的 Docker 容器</p></li><li><p>-d 表示容器在后台运行 </p></li><li><p>-t 极少能用到， 用于让一个空白的 ubuntu 镜像在后台运行</p></li><li><p>-p 用于指定端口映射′ 表示在本机访问 8000 会被自动转到容器中的 5000 端口<br>必须保证本机没有其他程序占用了 8000 端口， 否则这里会失败</p></li><li><p>-name demo 指定了容器的名字是 demo</p></li><li><p>ubuntu:18.04 是启动容器使用的镜像名，Docker 会自动从镜像服务器去下载这个镜像</p></li></ul><h3 id="运行一个简单的web应用"><a href="#运行一个简单的web应用" class="headerlink" title="运行一个简单的web应用"></a>运行一个简单的web应用</h3><p>这次我们选择开一个新容器，并提供web服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -d -p 7000:5000 -name demo ubuntu:18.04</span><br></pre></td></tr></table></figure><p>由于之前已经自动下载过 ubuntu:18.04 所以这次不会重新下载镜像, 速度很快，这个新的容器名叫demo。</p><p>我们首先在本地准备好运行的代码文件<code>a.py</code>，如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(host=<span class="string">"0.0.0.0"</span>, debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>接着我们在容器内创建目录，<code>exec</code> 命令后跟随容器名，然后再添加操作命令<code>mkdir /code</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec demol mkdir /code</span><br></pre></td></tr></table></figure><p><code>cp</code> 参数把当前文件夹的<code>a.py</code>拷贝到 demo 容器的 <code>/Code/a.py</code>处。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp a.py "demo:/code/a.py"</span><br></pre></td></tr></table></figure><p> <code>/code</code>必须是容器中存在的目录， Docker 不会自动创建，因此我们需要先手动创建。</p><p>接着我们同样用exec安装必要的依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker exec demo apt update</span><br><span class="line"></span><br><span class="line">docker exec demo apt -y install  python3 python3-pip</span><br><span class="line"></span><br><span class="line">docker exec demo pip3 install flask</span><br></pre></td></tr></table></figure><p>然后在容器 demo 中运行<code>a.py</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec demo python3  /code/o.py</span><br></pre></td></tr></table></figure><p>通过以上的操作，我们并在容器中安装程序运行所需的依赖库然后运行了一个 flask web 程序</p><p>以上操作较繁琐，我们也可以新建两个脚本文件<code>install.sh</code>和<code>run.sh</code>，然后直接运行脚本文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>install.sh</span><br><span class="line">apt update</span><br><span class="line">apt -y install python3 python3-pip</span><br><span class="line">pip3 install flask</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>run.sh</span><br><span class="line">cd /code</span><br><span class="line">python3 a.py</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker cp install.sh "demol:/code/install.sh"</span><br><span class="line"></span><br><span class="line">docker cp run.sh "demo1:/code/run.sh"</span><br><span class="line"></span><br><span class="line">docker exec demol bash /code/install.sh</span><br><span class="line"></span><br><span class="line">docker exec demol bash /code/run.sh</span><br></pre></td></tr></table></figure><h3 id="Dockerfile自动化操作"><a href="#Dockerfile自动化操作" class="headerlink" title="Dockerfile自动化操作"></a>Dockerfile自动化操作</h3><p>在本文件夹下，除了<code>a.py</code>外，我们又新建了个Dockerfile文件，如下。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Dockerfile 文件中 # 是注释</span></span><br><span class="line"><span class="comment"># FROM 用于指定构建镜像使用的基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># RUN 用于在构建镜像的时候在镜像中执行命令</span></span><br><span class="line"><span class="comment"># 这里我们安装 python3 和 flask web 框架</span></span><br><span class="line"><span class="keyword">RUN</span> apt update</span><br><span class="line">RUN apt -y install python3 python3-pip</span><br><span class="line">RUN pip3 install flask</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># COPY 相当于命令的 docker cp</span><br><span class="line"># 把本机当前目录下的 app.py 文件拷贝到镜像的 /code/app.py</span><br><span class="line"># 和 docker cp 不同的是，COPY 会自动创建镜像中不存在的目录，比如 /code</span><br><span class="line">COPY app.py /code/app.py</span><br><span class="line"></span><br><span class="line"># WORKDIR 用于指定从镜像启动的容器内的工作目录</span><br><span class="line">WORKDIR /code</span><br><span class="line"></span><br><span class="line"># CMD 用于指定容器运行后要执行的命令和参数列表</span><br><span class="line"># 这样从本镜像启动容器后会自动执行 python3 app.py 这个命令</span><br><span class="line"># 由于我们已经用 WORKDIR 指定了容器的工作目录</span><br><span class="line"># 所以下面的命令都是在 /code 下执行的</span><br><span class="line">CMD ["python3", "app.py"]</span><br></pre></td></tr></table></figure><p>我们可以直接运行下面的命令构建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t webimage .</span><br></pre></td></tr></table></figure><p><code>-t webimage</code> 指定了镜像的名字为 webimage，最后的那个 . 用来表示工作目录为本机当前目录。<br>随后我们可以直接用该镜像来运行容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8001:5000 -name demo2 webimage</span><br></pre></td></tr></table></figure><h3 id="docker-常用命令"><a href="#docker-常用命令" class="headerlink" title="docker 常用命令"></a>docker 常用命令</h3><p>启动一个停止运行的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start demo</span><br></pre></td></tr></table></figure><p>查找正在运行的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>停止容器， demo 是容器的名字</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop demo</span><br></pre></td></tr></table></figure><p>可以用 -o 参数查找所有容器, 包括未运行的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>删除被停止的容器和运行中的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm demo</span><br><span class="line">docker rm -f demo</span><br></pre></td></tr></table></figure><h2 id="数据卷与文件挂载"><a href="#数据卷与文件挂载" class="headerlink" title="数据卷与文件挂载"></a>数据卷与文件挂载</h2><p>我们可以在概念上把 Docker 找作虚拟机。当容器被删除的时候， 容器里的所有数据都会被删除，两个不同的容器之间无法互通。基于这些因素 Docker 推出了 数据卷 (volume) 功能。<br>我们可以把数据卷理解为虚拟机的虚拟磁盘， 它是独立于容器的文件，在容器中它破挂载为一个目录的形式。对于容器中的应用来说， 数据卷是透明的， 无法感知它的存在， 它就是一个普通的文件夹。由于数据卷独立于容器而存在, 因此删除容器的时候数据卷不会受到影响。<br>数据卷有以下优点</p><ul><li>多容器可以通过挂载同一个数据卷来共享数据</li><li>数据卷可以方便地备份存储数据</li></ul><ol><li><p>创建一个 volume</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create testvolume</span><br></pre></td></tr></table></figure></li><li><p>列出所有数据卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br></pre></td></tr></table></figure></li><li><p>删除一个数据卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm testvolume</span><br></pre></td></tr></table></figure></li></ol><p>我们下面来找一下如何在容器中使用数据卷</p><p>先创建一个数据卷web，接着在运行容器webimage的时候， 使用参数 -mount 如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name demovolume -mount source=web, target=/volume webimage</span><br></pre></td></tr></table></figure><p>后面参数的含义是把数据卷挂载到容器的 /volume 目录上</p><p>这样就运行了一个带有数据卷的容器， 这个容器的 /VoIume 目录中的内容在容器被删除后仍然存在。因为它实际上是存在 Docker 数据卷中。没有保存在数据卷上的文件会在容器被删除后丢失</p><p>这样我们就可以实现多容器之间可以通过数据卷共享文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -name demovolume2 -mount source=web,target=/volume webimage</span><br></pre></td></tr></table></figure><p>除了挂载数据卷外, Docker 还可以挂载共享目录 (这一点和虚拟机一样)。共享目录的优势是使用方便， 易于理解。我们开发时在宿主机中修改源代码就可以做到docker中实时生效省却 build 镜像的过程。<br>下面的命令会从 nginx 镜像运行一个名为 nginx1 的容器，井且设置了 8080-&gt;80 的端口映射，mount 参数的 type=bind 表明要挂载共享目录，把宿主机的当前目录映射为容器的 /usr/share/nginx/html<br>(这是 nginx 容器的静态页面文件存放路径).这样在宿主机中访问localhost:8080 会自动访问宿主机当前目录下的 index.html 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:80 -name nginx1 -mount type=bind, source="$&#123;PWD&#125;" ,target=/usr/share/nginx/html/ nginx</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;镜像和容器&quot;&gt;&lt;a href=&quot;#镜像和容器&quot; class=&quot;headerlink&quot; title=&quot;镜像和容器&quot;&gt;&lt;/a&gt;镜像和容器&lt;/h2&gt;&lt;p&gt;镜像和容器是 Docker 中最基本的 2 个概念，镜像相当于光盘， 光盘里面存储的数据是只读的， 不会被更改的。我
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>容器化搭建Go-Web应用</title>
    <link href="http://yyhyplxyz.github.io/2018/12/23/%E5%AE%B9%E5%99%A8%E5%8C%96%E6%90%AD%E5%BB%BAGo-Web%E5%BA%94%E7%94%A8/"/>
    <id>http://yyhyplxyz.github.io/2018/12/23/容器化搭建Go-Web应用/</id>
    <published>2018-12-23T04:13:00.000Z</published>
    <updated>2018-12-23T09:03:44.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="改用Mysql数据库"><a href="#改用Mysql数据库" class="headerlink" title="改用Mysql数据库"></a>改用Mysql数据库</h2><p>本次作业要求改<code>BoltDB</code>为<code>Mysql</code>数据库，同时，考虑到后面的作业要求搭建博客。因此将之前写的新闻应用做了重构，改成了一个博客后台。</p><p>使用了<code>Beggo</code>框架自带的<code>ORM</code>。个人感觉这类框架内部封装好了很多逻辑，实现功能会比<code>boltdb</code>的键值对操作要容易很多。下面以用户类别为例分别对增删改查四个操作作出解释。</p><p><code>User</code>的模型类别如下，我们可以像下面这样指定对应数据库的列要求。如主键<code>pk</code>，自增<code>auto</code>，可以为空null与不可重复<code>uniqu</code>e等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Id        <span class="keyword">int</span>       <span class="string">`orm:"pk;auto"`</span></span><br><span class="line">  Username  <span class="keyword">string</span>    <span class="string">`orm:"unique"`</span></span><br><span class="line">  Password  <span class="keyword">string</span></span><br><span class="line">  Token     <span class="keyword">string</span>    <span class="string">`orm:"unique"`</span></span><br><span class="line">  Avatar    <span class="keyword">string</span></span><br><span class="line">  Email     <span class="keyword">string</span>    <span class="string">`orm:"null"`</span></span><br><span class="line">  Url       <span class="keyword">string</span>    <span class="string">`orm:"null"`</span></span><br><span class="line">  Signature <span class="keyword">string</span>    <span class="string">`orm:"null;size(1000)"`</span></span><br><span class="line">  InTime    time.Time <span class="string">`orm:"auto_now_add;type(datetime)"`</span></span><br><span class="line">  Roles     []*Role   <span class="string">`orm:"rel(m2m)"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>增加操作</p><p>在用户注册页面，当我们根据用户的输入构建好了<code>user</code>类后，就可以通过如下函数进行用户的创建，注册。</p><p><code>orm</code>是单例模式，如下一行简单的<code>insert</code>就做到了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SaveUser</span><span class="params">(user *User)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">  o := orm.NewOrm()</span><br><span class="line">  id, _ := o.Insert(user)</span><br><span class="line">  <span class="keyword">return</span> id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除操作</p><p>实际博客应用中很少删除用户，为了演示使用下面的函数。同样的传入<code>user</code>类后，一行简单的<code>delete</code>就做到了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeleteUser</span><span class="params">(user *User)</span></span> &#123;</span><br><span class="line">  o := orm.NewOrm()</span><br><span class="line">  o.Delete(user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改操作</p><p>如上，因为指定了<code>id</code>为主键，所以<code>update</code>的时候会查找主键相同的，再进行修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateUser</span><span class="params">(user *User)</span></span> &#123;</span><br><span class="line">  o := orm.NewOrm()</span><br><span class="line">  o.Update(user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查找操作</p><p>查找的语句较麻烦，我们需要指定一个数据表，指明过滤的字段和条件，并将<code>user</code>类型指针传入以获得查找到的结果。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Login</span><span class="params">(username <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">bool</span>, User)</span></span> &#123;</span><br><span class="line">  o := orm.NewOrm()</span><br><span class="line">  <span class="keyword">var</span> user User</span><br><span class="line">  err := o.QueryTable(user).Filter(<span class="string">"Username"</span>, username).One(&amp;user)</span><br><span class="line">  <span class="keyword">return</span> err != orm.ErrNoRows, user</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了上述的操作外，我们还可以用数据库原生语句来执行命令。如下以增删为例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeleteUserRolesByUserId</span><span class="params">(user_id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  o := orm.NewOrm()</span><br><span class="line">  o.Raw(<span class="string">"delete from user_roles where user_id = ?"</span>, user_id).Exec()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SaveUserRole</span><span class="params">(user_id <span class="keyword">int</span>, role_id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  o := orm.NewOrm()</span><br><span class="line">  o.Raw(<span class="string">"insert into user_roles (user_id, role_id) values (?, ?)"</span>, user_id, role_id).Exec()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们构建好了<code>model</code>后，就可以注册数据库了。</p><p>如下我们需要指明数据库的地址，用户名，密码数据库名，通过<code>orm.RegisterDataBase</code>注册数据库，通过<code>orm.RegisterDriver</code>注册<code>mysql</code>驱动。之后我们还需要依次注册各个<code>model</code>，并同步数据库<code>orm.RunSyncdb</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    orm.RegisterDriver(<span class="string">"mysql"</span>, orm.DR_MySQL)</span><br><span class="line">  orm.RegisterDataBase(<span class="string">"default"</span>, <span class="string">"mysql"</span>, username+<span class="string">":"</span>+password+<span class="string">"@tcp("</span>+url+<span class="string">":"</span>+port+<span class="string">")/pybbs?charset=utf8&amp;parseTime=true&amp;charset=utf8&amp;loc=Asia%2FShanghai"</span>, <span class="number">30</span>)</span><br><span class="line">  orm.RegisterModel(</span><br><span class="line">    <span class="built_in">new</span>(models.User),</span><br><span class="line">    <span class="built_in">new</span>(models.Topic),</span><br><span class="line">    <span class="built_in">new</span>(models.Section),</span><br><span class="line">    <span class="built_in">new</span>(models.Reply),</span><br><span class="line">    <span class="built_in">new</span>(models.ReplyUpLog),</span><br><span class="line">    <span class="built_in">new</span>(models.Role),</span><br><span class="line">    <span class="built_in">new</span>(models.Permission))</span><br><span class="line">  orm.RunSyncdb(<span class="string">"default"</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/var/folders/27/4j7qwl0n383_wdy85h_txrzr0000gn/T/abnerworks.Typora/image-20181223125936969.png" alt="image-20181223125936969"></p><h2 id="Docker构建容器"><a href="#Docker构建容器" class="headerlink" title="Docker构建容器"></a>Docker构建容器</h2><ul><li><p><code>mysql</code>镜像</p><p>我们在安装了<code>docker</code>后，首先将<code>mysql</code>镜像下载下来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.6</span><br></pre></td></tr></table></figure><p>接着我们可以查看到已有的镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images |grep mysql</span><br></pre></td></tr></table></figure><p>然后开启<code>mysql</code>容器，并指定各类配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mymysql -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6</span><br></pre></td></tr></table></figure><ul><li><strong>-p 3306:3306</strong>：将容器的 3306 端口映射到主机的 3306 端口。</li><li><strong>-v ~/conf:/etc/mysql/conf.d</strong>：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。</li><li><strong>-v ~/logs:/logs</strong>：将主机当前目录下的 logs 目录挂载到容器的 /logs。</li><li><strong>-v ~/data:/var/lib/mysql</strong> ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。</li><li><strong>-e MYSQL_ROOT_PASSWORD=123456：</strong>初始化 root 用户的密码。</li></ul></li><li><p><code>node</code>镜像</p><p>接下来开启前端镜像，以下我们使用dockerfiles，进入项目目录。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装node镜像</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">7.8</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 app 目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span> /app</span><br><span class="line"></span><br><span class="line"># 安装 app 依赖</span><br><span class="line"></span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line">#暴露端口</span><br><span class="line">EXPOSE 8080</span><br><span class="line">#运行命令</span><br><span class="line">CMD [ "npm", "run" ,"dev"]</span><br></pre></td></tr></table></figure><p>然后我们创建<code>docker</code>镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t web_front .</span><br></pre></td></tr></table></figure><p>并运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 -d web_front</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fygsdr5ec1j30q20cqae0.jpg" alt=""></p></li><li><p>go镜像</p><p>接下来我们同样进入<code>web</code>后端目录，创建<code>dockerfile</code>。</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装go镜像</span></span><br><span class="line"><span class="keyword">FROM</span> golang:latest</span><br><span class="line"><span class="comment"># 创建 应用 目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span> $GOPATH/src/web_pro</span><br><span class="line">ADD . $GOPATH/src/web_pro</span><br><span class="line">#安装依赖</span><br><span class="line">RUN go get github.com/astaxie/beego</span><br><span class="line">RUN go get github.com/beego/bee</span><br><span class="line">RUN go build .</span><br><span class="line">#暴露端口</span><br><span class="line">EXPOSE 8080</span><br><span class="line">#运行命令</span><br><span class="line">CMD [ "bee", "run" ]</span><br></pre></td></tr></table></figure><p>然后我们创建<code>docker</code>镜像，并运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t web_pro .</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 -d web_pro</span><br></pre></td></tr></table></figure><p><img src="/var/folders/27/4j7qwl0n383_wdy85h_txrzr0000gn/T/abnerworks.Typora/image-20181223170149382.png" alt="image-20181223170149382"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;改用Mysql数据库&quot;&gt;&lt;a href=&quot;#改用Mysql数据库&quot; class=&quot;headerlink&quot; title=&quot;改用Mysql数据库&quot;&gt;&lt;/a&gt;改用Mysql数据库&lt;/h2&gt;&lt;p&gt;本次作业要求改&lt;code&gt;BoltDB&lt;/code&gt;为&lt;code&gt;Mysql
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>net/http 源码略读</title>
    <link href="http://yyhyplxyz.github.io/2018/11/16/net-http-%E6%BA%90%E7%A0%81%E7%95%A5%E8%AF%BB/"/>
    <id>http://yyhyplxyz.github.io/2018/11/16/net-http-源码略读/</id>
    <published>2018-11-16T03:44:22.000Z</published>
    <updated>2018-11-16T04:11:53.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="net-http-源码略读"><a href="#net-http-源码略读" class="headerlink" title="net/http 源码略读"></a>net/http 源码略读</h2><h4 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h4><p>​    网络发展，很多网络应用都是构建再 HTTP 服务基础之上。HTTP 协议从诞生到现在，发展从1.0，1.1到2.0也不断再进步。理解 HTTP 构建的网络应用只要关注两个端—客户端（clinet）和服务端（server），两个端的交互来自 clinet 的 request，以及server端的response。所谓的http服务器，主要在于如何接受 clinet 的 request，并向client返回response。</p><h4 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h4><p>​    以下是最简单的使用net/http库构建的web服务器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">handler := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello golang\n"</span>))</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, handler)</span><br><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    根据以上的代码，发现主要的是三个部分<code>HandleFunc</code>，<code>ResponseWriter</code>和<code>ListenAndServe</code>。下面将分别解释这三个部分。</p><p>####<code>HandleFunc</code> </p><p>​    实际上<code>http.HandleFunc</code>封装自<code>ServeMux</code>的HandleFunc方法。见如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">pattern <span class="keyword">string</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    接收request的过程中，最重要的莫过于路由（<code>router</code>），这就是内置的<code>DefautServeMux</code>，也可以自定义。Multiplexer路由的目的就是为了找到处理器函数（<code>handler</code>），后者将对request进行处理，同时构建response。Golang中的<code>Multiplexer</code>基于<code>ServeMux</code>结构，同时也实现了<code>Handler</code>接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">mu sync.RWMutex</span><br><span class="line">m <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry</span><br><span class="line">hosts <span class="keyword">bool</span> <span class="comment">// 决定是否会保存主机名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">explicit <span class="keyword">bool</span></span><br><span class="line">h Handler <span class="comment">//控制器</span></span><br><span class="line">pattern <span class="keyword">string</span> <span class="comment">//路由</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    其中<code>mu</code>字段是读写锁，用于并发读写的数据同步。在并发的时候保证了数据的一致性。<code>m</code>字段是一个字典数据结构，可以看到muxEntry才是路由的保存的地方，也就是一个路径对应一个<code>urlhandler</code>。</p><h4 id="ResponseWriter"><a href="#ResponseWriter" class="headerlink" title="ResponseWriter"></a><code>ResponseWriter</code></h4><p>​    <code>ResponseWriter</code>是一个接口，主要部分就是下面列的三个</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ResponseWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">   Header() Header</span><br><span class="line">   Write([]<span class="keyword">byte</span>) (<span class="keyword">int</span>, error)</span><br><span class="line">   WriteHeader(statusCode <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    其中，Header会返回Http头部内容，write和writeHeader就主要负责写入具体内容到报文。</p><h4 id="ListenAndServe"><a href="#ListenAndServe" class="headerlink" title="ListenAndServe"></a><code>ListenAndServe</code></h4><p>​    在<code>http.ListenAndServe(&quot;:8080&quot;, nil)</code>上，服务器会触发对应模式的handler。</p><p>其具体实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// 只要实现了ServeHTTP接口就可以用作handler作为ListenAndServe的第二个参数</span></span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ResponseWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">Header() Header</span><br><span class="line">Write([]<span class="keyword">byte</span> (<span class="keyword">int</span>, error)</span><br><span class="line">WriteHeader(<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(add <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// server内部有一种方法找到我们先前注册的handler</span></span><br><span class="line">server := &amp;Server&#123;Addr: addr, Handler: Handler&#125; </span><br><span class="line"><span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">Addr <span class="keyword">string</span></span><br><span class="line">Handler Handler</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">包括其他的Server控制参数，包括时间相关的参数</span></span><br><span class="line"><span class="comment">Header大小、状态、日志、运输层安全。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">mu sync.Mutex</span><br><span class="line">listeners <span class="keyword">map</span>[net.Listener]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// TCP 底层的连接池</span></span><br><span class="line"><span class="comment">// 保存HTTP长连接，看HTTP协议版本和HTTP首部字段中的`Connection`的状体</span></span><br><span class="line"><span class="comment">// 注意map的值是struct&#123;&#125;类型,保证可以存储各类控制handler</span></span><br><span class="line">activeConn <span class="keyword">map</span>[*conn]<span class="keyword">struct</span>&#123;&#125; </span><br><span class="line">doneChan <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// Server的停止、关闭控制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServe</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 忽略细节性代码</span></span><br><span class="line">addr := srv.Addr</span><br><span class="line">ln, err := net.Listen(<span class="string">"tcp"</span>, addr) <span class="comment">// 创建tcp连接，addr为监听地址"ip:port"形式的字符串</span></span><br><span class="line"><span class="keyword">return</span> srv.Serve(tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;)</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>总而言之，web服务器的基本流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Clinet -&gt; Requests -&gt;  [Multiplexer(router)] -&gt; handler  -&gt; Response -&gt; Clinet</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;net-http-源码略读&quot;&gt;&lt;a href=&quot;#net-http-源码略读&quot; class=&quot;headerlink&quot; title=&quot;net/http 源码略读&quot;&gt;&lt;/a&gt;net/http 源码略读&lt;/h2&gt;&lt;h4 id=&quot;基本架构&quot;&gt;&lt;a href=&quot;#基本架构&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>go语言并发爬虫</title>
    <link href="http://yyhyplxyz.github.io/2018/10/04/go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E7%88%AC%E8%99%AB/"/>
    <id>http://yyhyplxyz.github.io/2018/10/04/go语言并发爬虫/</id>
    <published>2018-10-04T04:48:59.000Z</published>
    <updated>2018-11-03T15:47:14.067Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则表达式的使用"><a href="#正则表达式的使用" class="headerlink" title="正则表达式的使用"></a>正则表达式的使用</h2><pre><code>正则表达式是一种进行模式匹配和文本操纵的复杂而又强大的工具。虽然正则表达式比纯粹的文本匹配效率低，但是它却更灵活。按照它的语法规则，随需构造出的匹配模式就能够从原始文本中筛选出几乎任何你想要得到的字符组合。Go语言通过`regexp`标准包为正则表达式提供了官方支持，`regexp`包中含有三个函数用来判断是否匹配，如果匹配返回true，否则返回false</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Match</span><span class="params">(pattern <span class="keyword">string</span>, b []<span class="keyword">byte</span>)</span> <span class="params">(matched <span class="keyword">bool</span>, error error)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">MatchReader</span><span class="params">(pattern <span class="keyword">string</span>, r io.RuneReader)</span> <span class="params">(matched <span class="keyword">bool</span>, error error)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">MatchString</span><span class="params">(pattern <span class="keyword">string</span>, s <span class="keyword">string</span>)</span> <span class="params">(matched <span class="keyword">bool</span>, error error)</span></span></span><br></pre></td></tr></table></figure><pre><code>上面的三个函数实现了同一个功能，就是判断`pattern`是否和输入源匹配，匹配的话就返回true，如果解析正则出错则返回error。三个函数的输入源分别是byte slice、RuneReader和string。</code></pre><p>如果要验证一个输入是不是IP地址，那么如何来判断呢？请看如下实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsIP</span><span class="params">(ip <span class="keyword">string</span>)</span> <span class="params">(b <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> m, _ := regexp.MatchString(<span class="string">"^[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;$"</span>, ip); !m &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>regexp</code>的pattern和我们平常使用的正则一模一样。</p><h2 id="爬虫基础"><a href="#爬虫基础" class="headerlink" title="爬虫基础"></a>爬虫基础</h2><pre><code>爬虫程序从一个网页开始，获取它的内容之后，可以根据xml或者xpath包找到对应的元素，然后利用上文提到的正则表达式提取一些关键数据。通常爬虫程序在一个网页中找到URL，会继续抓取该URL的内容，继续找URL，再继续抓取它的内容。下面我们演示下利用http库来模拟对浏览器发出请求，并获得响应。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/http/httputil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">request, err := http.NewRequest(</span><br><span class="line">http.MethodGet,</span><br><span class="line"><span class="string">"http://www.baidu.com"</span>, <span class="literal">nil</span>)</span><br><span class="line">request.Header.Add(<span class="string">"User-Agent"</span>,</span><br><span class="line"><span class="string">"Mozilla/5.0 (iPhone; CPU iPhone OS 10_3 like Mac OS X) AppleWebKit/602.1.50 (KHTML, like Gecko) CriOS/56.0.2924.75 Mobile/14E5239e Safari/602.1"</span>)</span><br><span class="line"></span><br><span class="line">client := http.Client&#123;</span><br><span class="line">CheckRedirect: <span class="function"><span class="keyword">func</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">req *http.Request,</span></span></span><br><span class="line"><span class="function"><span class="params">via []*http.Request)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Redirect:"</span>, req)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">resp, err := client.Do(request)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">s, err := httputil.DumpResponse(resp, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>因此爬虫程序的基本原理如下。初始化seed把请求链接给Engine，然后Engine将url维护为一个任务队列，从任务队列中源源不断的取出任务交个Fetcher获得页面内容，再交给Parser获得数据以及其他的任务链接。最后再把这些链接存入任务队列中。</code></pre><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv9cwuedrj318a0majvo.jpg" alt=""></p><h2 id="Go语言并发编程"><a href="#Go语言并发编程" class="headerlink" title="Go语言并发编程"></a>Go语言并发编程</h2><pre><code>GO语言原生支持协程，可以在一个或多个线程中开启多个协程。主函数main其实也是个协程。Go语言中的协程叫goroutine，Go标准库提供的调用操作，IO操作都会出让CPU给其他goroutine，让协程间的切换管理不依赖系统的线程和进程，不依赖CPU的核心数量。我们可以把它粗略的看成是个简单的线程</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123; <span class="comment">//i是函数的形式变量</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Hello from "</span>+</span><br><span class="line"><span class="string">"goroutine %d\n"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i) <span class="comment">//来源于主函数中的ii</span></span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Minute)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>协程的引入是为了并发编程，提高效率。并发编程的难度在于协调，协调需要通过通信，并发通信模型分为共享数据和消息。共享数据即多个并发单元保持对同一个数据的引用，数据可以是内存数据块，磁盘文件，网络数据等。数据共享通过加锁的方式来避免死锁和资源竞争。**Go**语言则采取消息机制来通信，每个并发单元是独立的个体，有独立的变量，不同并发单元间这些变量不共享，每个并发单元的输入输出只通过消息的方式。下面的代码详细解释了channel的原理</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、channel声明，声明一个管道chanName，该管道可以传递的类型是ElementType</span></span><br><span class="line"><span class="comment">//管道是一种复合类型，[chan ElementType],表示可以传递ElementType类型的管道[类似定语从句的修饰方法]</span></span><br><span class="line"><span class="keyword">var</span> chanName <span class="keyword">chan</span> ElementType</span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span>                  <span class="comment">//声明一个可以传递int类型的管道</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">chan</span> <span class="keyword">bool</span>      <span class="comment">//声明一个map，值的类型为可以传递bool类型的管道</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//2、初始化</span></span><br><span class="line">ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)   <span class="comment">//make一般用来声明一个复合类型，参数为复合类型的属性</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//3、管道写入,把值想象成一个球，"&lt;-"的方向，表示球的流向，ch即为管道</span></span><br><span class="line"><span class="comment">//写入时，当管道已满（管道有缓冲长度）则会导致程序堵塞，直到有goroutine从中读取出值</span></span><br><span class="line">ch &lt;- value</span><br><span class="line"><span class="comment">//管道读取，"&lt;-"表示从管道把球倒出来赋值给一个变量</span></span><br><span class="line"><span class="comment">//当管道为空，读取数据会导致程序阻塞，直到有goroutine写入值</span></span><br><span class="line">value:= &lt;-ch </span><br><span class="line"> </span><br><span class="line"><span class="comment">//4、每个case必须是一个IO操作，面向channel的操作，只执行其中的一个case操作，一旦满足则结束select过程</span></span><br><span class="line"><span class="comment">//面向channel的操作无非三种情况：成功读出；成功写入；即没有读出也没有写入</span></span><br><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-chan1:</span><br><span class="line">  <span class="comment">//如果chan1读到数据，则进行该case处理语句</span></span><br><span class="line">  <span class="keyword">case</span> chan2&lt;<span class="number">-1</span>:</span><br><span class="line">  <span class="comment">//如果成功向chan2写入数据，则进入该case处理语句</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  <span class="comment">//如果上面都没有成功，则进入default处理流程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并发爬虫的实现"><a href="#并发爬虫的实现" class="headerlink" title="并发爬虫的实现"></a>并发爬虫的实现</h2><pre><code>在上文提到的普通爬虫的基础上，我们可以利用并发编程的原理改进成并发爬虫。这是因为Fetcher会耗时较多，造成其它任务的阻塞。并发爬虫的逻辑框架如下，其中worker会读取页面内容，并对页面内容做解析，request队列即是任务队列。我们为每个request构建goroutine，并为每个work构建goroutine，协程和协程间通过channel通信，当有worker的协程空闲时，就会承担某个request的协程的任务。当无法为某个request搭配一个worker时就会堵塞下去。</code></pre><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv9d3ys3lj31cm0lutcq.jpg" alt=""></p><p>具体的我们实现的时候要实现以下几个部件。</p><ul><li>Engine。用于不断的创建协程，根据url判重来发起request，并将request传给scheduler。</li><li>Scheduler。用于维护request队列和创建worker的协程，并维护worker队列。</li><li>Worker。构建页面解析函数，用于解析页面获得新的url以及得到我们想要的数据</li></ul><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv8z8u90bj30nc0d5acy.jpg" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> scheduler</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"scrawl/types"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Request队列和Worker队列</span></span><br><span class="line"><span class="keyword">type</span> QueuedScheduler <span class="keyword">struct</span> &#123;</span><br><span class="line">requestChan <span class="keyword">chan</span> types.Request</span><br><span class="line">workChan    <span class="keyword">chan</span> <span class="keyword">chan</span> types.Request</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *QueuedScheduler)</span> <span class="title">Submit</span><span class="params">(r types.Request)</span></span> &#123;</span><br><span class="line">s.requestChan &lt;- r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *QueuedScheduler)</span> <span class="title">WorkerChan</span><span class="params">()</span> <span class="title">chan</span> <span class="title">types</span>.<span class="title">Request</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make</span>(<span class="keyword">chan</span> types.Request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *QueuedScheduler)</span> <span class="title">WorkerReady</span><span class="params">(w <span class="keyword">chan</span> types.Request)</span></span> &#123;</span><br><span class="line">s.workChan &lt;- w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *QueuedScheduler)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">s.workChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> types.Request)</span><br><span class="line">s.requestChan = <span class="built_in">make</span>(<span class="keyword">chan</span> types.Request)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> requestQ []types.Request</span><br><span class="line"><span class="keyword">var</span> workQ []<span class="keyword">chan</span> types.Request</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> activeRequest types.Request</span><br><span class="line"><span class="keyword">var</span> activeWorker <span class="keyword">chan</span> types.Request</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(requestQ) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(workQ) &gt; <span class="number">0</span> &#123;</span><br><span class="line">activeWorker = workQ[<span class="number">0</span>]</span><br><span class="line">activeRequest = requestQ[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> r := &lt;-s.requestChan:</span><br><span class="line">requestQ = <span class="built_in">append</span>(requestQ, r)</span><br><span class="line"><span class="keyword">case</span> w := &lt;-s.workChan:</span><br><span class="line">workQ = <span class="built_in">append</span>(workQ, w)</span><br><span class="line"><span class="keyword">case</span> activeWorker &lt;- activeRequest:</span><br><span class="line">workQ = workQ[<span class="number">1</span>:]</span><br><span class="line">requestQ = requestQ[<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码见github <a href="https://github.com/zys980808/Agenda-Go" target="_blank" rel="noopener">https://github.com/zys980808/Agenda-Go</a> 中的并发爬虫文件夹内</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;正则表达式的使用&quot;&gt;&lt;a href=&quot;#正则表达式的使用&quot; class=&quot;headerlink&quot; title=&quot;正则表达式的使用&quot;&gt;&lt;/a&gt;正则表达式的使用&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;正则表达式是一种进行模式匹配和文本操纵的复杂而又强大的工具。虽然正则表达式比
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>go语言实现selpg</title>
    <link href="http://yyhyplxyz.github.io/2018/10/04/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0selpg/"/>
    <id>http://yyhyplxyz.github.io/2018/10/04/go语言实现selpg/</id>
    <published>2018-10-04T04:42:43.000Z</published>
    <updated>2018-10-04T06:06:44.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h2><p>selpg是一个unix系统下命令。</p><p>该命令本质上就是将一个文件，通过自己设定的分页方式，输出到屏幕或者重定向到其他文件上，或者利用打印机打印出来。使用格式如下。</p><p><code>-s start_page -e end_page [ -f | -l lines_per_page ][ -d dest ] [ in_filename ]</code></p><p>必需标志以及参数：</p><ul><li>-s，后面接开始读取的页号 int</li><li>-e，后面接结束读取的页号 int<br> s和e都要大于1，并且s &lt;= e，否则提示错误</li></ul><p>可选参数：</p><ul><li>-l，后面跟行数 int，代表多少行分为一页，不指定 -l 又缺少 -f 则默认按照72行分一页</li><li>-f，该标志无参数，代表按照分页符’\f’ 分页</li><li>-d，后面接打印机名称，用于打印</li><li>filename，唯一一个无标识参数，代表选择读取的文件名</li></ul><h2 id="flag包解析参数"><a href="#flag包解析参数" class="headerlink" title="flag包解析参数"></a>flag包解析参数</h2><p>flag库是一个简单的解析参数的函数包，使用它会比使用os函数包解析字符串来获得程序运行参数简单很多。我们可以使用flag.XxxxxVar方法来实现参数的获取，该函数第一个传递值是某个自己定义的变量的指针，第二个传递值是我们给程序的某个参数，第三个传递值是在该参数没有给出时，我们设定的默认值，第四个参数是一个参数说明。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag.IntVar(&amp;pagestart, <span class="string">"s"</span>, <span class="number">-1</span>, <span class="string">"the start page"</span>)</span><br><span class="line">flag.IntVar(&amp;pageend, <span class="string">"e"</span>, <span class="number">-1</span>, <span class="string">"The end page"</span>)</span><br><span class="line">flag.IntVar(&amp;lineperpage, <span class="string">"l"</span>, <span class="number">72</span>, <span class="string">"the paging form"</span>)</span><br><span class="line">flag.StringVar(&amp;printDest, <span class="string">"d"</span>, <span class="string">""</span>, <span class="string">"The named-printer to print the selected content."</span>)</span><br><span class="line">flag.BoolVar(&amp;separationtype, <span class="string">"f"</span>, <span class="literal">false</span>, <span class="string">"Choose if the input pages should be separated by Formfeed-Character('\\f'). (not compatible with `-l`)"</span>)</span><br></pre></td></tr></table></figure><p>具体的，在我们的程序中，我们将所有变量都声明在var中，flag的参数绑定方法声明在init()函数中，从而让程序一运行就解析参数并绑定到全局变量中。</p><p>为了让程序具有更好的鲁棒性，设计一个检验函数，在输入命令出错时给予提示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> DefaultlineperPage != lineperpage &amp;&amp; separationtype == <span class="literal">true</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> argsinvalid</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> pagestart == <span class="number">-1</span> || pageend == <span class="number">-1</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> valueInvalid</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> pagestart &lt;= <span class="number">0</span> || pagestart &gt; pageend &#123;</span><br><span class="line"><span class="keyword">goto</span> valueInvalid</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> lineperpage &lt;= <span class="number">0</span>&#123;</span><br><span class="line"><span class="keyword">goto</span> valueInvalid</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">argsinvalid:</span><br><span class="line">log.Fatalln(<span class="string">"[Error] ... `-l` is not compatible with `-f`."</span>)</span><br><span class="line">valueInvalid:</span><br><span class="line">log.Fatalln(<span class="string">"[Error] ... Values of `-s` and `-e` are invalid."</span>)</span><br></pre></td></tr></table></figure><h2 id="分页功能"><a href="#分页功能" class="headerlink" title="分页功能"></a>分页功能</h2><p>接下来我们实现具体的文件分页功能，首先我们要根据separtiontype，即是否有<code>-f</code>参数来判断根据换行符还是行数来分页。</p><p>如果是根据行数来判断分页，我们首先利用bufio函数获得我们输入流的缓存，再以换行符为依据读取每行内容，在不需要输出到打印机时，直接利用系统输出流输出到文件或者屏幕即可，否则要将内容暂时存到res这个string变量中。</p><p>如果是根据换行符来判断，则要用<code>readrune</code>函数来读取单个字符，接着输出到标准输出流或者暂时存在内存中，输出到打印机内。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line">rd := bufio.NewReader(myin)</span><br><span class="line"><span class="keyword">if</span> !separationtype &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line"><span class="comment">//d1 := []byte("lineperpage" + string(lineperpage))</span></span><br><span class="line"><span class="comment">//err := ioutil.WriteFile("test.txt", d1, 0644)</span></span><br><span class="line">line, err = rd.ReadString(<span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> || io.EOF == err &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">currLine++</span><br><span class="line"><span class="keyword">if</span> currLine &gt; lineperpage &#123;</span><br><span class="line">currPage++</span><br><span class="line">currLine = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> currPage &gt;= pagestart &amp;&amp; currPage &lt;= pageend &#123;</span><br><span class="line"><span class="comment">// not for printer but to stdout</span></span><br><span class="line"><span class="keyword">if</span> printDest == <span class="string">""</span> &#123;</span><br><span class="line">fmt.Fprintf(myout, <span class="string">"%s"</span>, line)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res += line</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">char, _, err1 := rd.ReadRune()</span><br><span class="line"><span class="keyword">if</span> err1 != <span class="literal">nil</span> || io.EOF == err &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> char == <span class="string">'\f'</span> &#123;</span><br><span class="line">currPage++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> currPage &gt;= pagestart &amp;&amp; currPage &lt;= pageend &#123;</span><br><span class="line"><span class="comment">// output to stdout</span></span><br><span class="line"><span class="keyword">if</span> printDest == <span class="string">""</span> &#123;</span><br><span class="line">fmt.Fprintf(myout, <span class="string">"%c"</span>, char)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res += <span class="keyword">string</span>(char)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h2><p>我们首先要确定输入输出流，如果参数指明了输入文件，我们就要将输入流由标准输入流改为文件输入流，如果出现错误时，打出报错，显示用法，并退出程序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inputrouter</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> inputfile != <span class="string">""</span> &#123;</span><br><span class="line">myin, err = os.Open(inputfile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"selpg: could not open input file \"%s\"\n"</span>, inputfile)</span><br><span class="line">fmt.Println(err)</span><br><span class="line">usage()</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出流一般都是操作系统的标准输出，当指明了输出的打印机时，就要把输出的内容先暂存到内存中，然后通过管道传到lp命令的输入流，再通过lp命令来实现打印功能。这里使用了exec函数库中的cmmand，开启另一个线程来调用系统命令。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">outputrouter</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> printDest != <span class="string">""</span> &#123;</span><br><span class="line">str := fmt.Sprintf(<span class="string">"-d%s"</span>, printDest)</span><br><span class="line">cmd = exec.Command(<span class="string">"lp"</span>, str)</span><br><span class="line">_, err := cmd.Output()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"%s: could not open pipe to \"%s\"\n"</span>, <span class="string">"try"</span>, str)</span><br><span class="line">os.Exit(<span class="number">13</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> printDest != <span class="string">""</span> &#123;</span><br><span class="line">cmd.Stdin = strings.NewReader(res)</span><br><span class="line">cmd.Stdout = myout</span><br><span class="line">err = cmd.Run()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"printing to %s occurs some errors"</span>, printDest)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="程序测试"><a href="#程序测试" class="headerlink" title="程序测试"></a>程序测试</h2><ol><li>文件读取</li></ol><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvw5iugbjsj31kw0wqqav.jpg" alt=""></p><ol><li><p>标准输入输出流</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvw5mi0z5hj319u0emwfl.jpg" alt=""></p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvw5o1haigj31kw0h8tcb.jpg" alt=""></p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvw5o1haigj31kw0h8tcb.jpg" alt=""></p></li></ol><ol><li><p>输出重定向</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvw5p5ljrwj31kw055wft.jpg" alt=""></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;功能简介&quot;&gt;&lt;a href=&quot;#功能简介&quot; class=&quot;headerlink&quot; title=&quot;功能简介&quot;&gt;&lt;/a&gt;功能简介&lt;/h2&gt;&lt;p&gt;selpg是一个unix系统下命令。&lt;/p&gt;
&lt;p&gt;该命令本质上就是将一个文件，通过自己设定的分页方式，输出到屏幕或者重定向
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CentOS下Golang配置</title>
    <link href="http://yyhyplxyz.github.io/2018/09/27/CentOS%E4%B8%8BGolang%E9%85%8D%E7%BD%AE/"/>
    <id>http://yyhyplxyz.github.io/2018/09/27/CentOS下Golang配置/</id>
    <published>2018-09-27T15:04:18.000Z</published>
    <updated>2018-09-27T15:37:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Go环境配置"><a href="#Go环境配置" class="headerlink" title="Go环境配置"></a>Go环境配置</h4><p>在上一次作业中我们已经配置好了Centos虚拟机，基于此我们配置安装go环境。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install gloang #利用yum安装go</span><br><span class="line">go version #查看go版本</span><br><span class="line">rpm -ql golang |more #查看go安装的路径</span><br></pre></td></tr></table></figure><p>安装完毕后，我们需要配置环境变量，令我们在终端中可以使用go命令。</p><p>首先我们要了解下go语言的工作空间。工作空间，应该由 /bin, /src/, /pkg 三个文件夹组成。三个文件夹的作用如下：</p><table><thead><tr><th>Folder</th><th>Usage</th></tr></thead><tbody><tr><td>bin</td><td>存放编译后的程序包</td></tr><tr><td>pkg</td><td>存放编译生成的对象文件</td></tr><tr><td>src</td><td>外部库/源文件</td></tr></tbody></table><p>因此我们接下来将创建工作空间和工作空间内的三个文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir $HOME/gowork #创建名为gowork的工作空间</span><br><span class="line">mkdir $HOME/gowork/bin #以下分别创建三个不同作用的文件夹</span><br><span class="line">mkdir $HOME/gowork/pkg</span><br><span class="line">mkdir $HOME/gowork/src</span><br></pre></td></tr></table></figure><p>然后我们就要用命令行开始配置环境变量啦</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile #打开该文件</span><br></pre></td></tr></table></figure><p>我们在文件中添加下面两个语句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=$HOME/gowork</span><br><span class="line">export PATH=$PATH:$GOAPTH/bin</span><br></pre></td></tr></table></figure><p>接着我们输入<code>source /etc/profile</code>使变量生效。</p><p>输入<code>cd $GOPATH</code>，看是否进入了工作空间，即gowork文件夹，来判断是否设置成功。</p><p>但是这个只在当前 终端 生效，退出或新开终端则无用。因此我们可以在 .bashrc 文件中设置其永久生效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bashrc</span><br></pre></td></tr></table></figure><p>在里面加一句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>最后，我们输入<code>go env</code>，终端会输出go的所有环境配置，如下图所示</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fvoiv4i5o2j30m60go0u6.jpg" alt=""></p><h4 id="编辑工具下载安装"><a href="#编辑工具下载安装" class="headerlink" title="编辑工具下载安装"></a>编辑工具下载安装</h4><p>在安装好go之后，我们需要一个好用的代码编写工具，这里我们选用了vscode，按照官网上的安装教程输入如下命令进行安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc</span><br><span class="line">sudo sh -c 'echo -e "[code]\nname=Visual Studio Code\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc" &gt; /etc/yum.repos.d/vscode.repo' # configure the code repo</span><br><span class="line">yum check-update</span><br><span class="line">sudo yum install code</span><br></pre></td></tr></table></figure><p>在 vscode中我们需要安装Go的工具，但是因为中国网络环境可能无法直接访问Golang.org获取，因此我们从github上下载源码，然后进行编译，下面是示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir $GOPATH/src/golang.org/x/ #创建文件夹</span><br><span class="line">go get -d github.com/golang/tools #下载源码</span><br><span class="line">cp $GOPATH/src/github.com/golang/tools $GOPATH/src/golang.org/x/ -rf #复制移动到指定位置</span><br><span class="line">go install golang.org/x/tools/go/buildutil #安装工具包</span><br></pre></td></tr></table></figure><h4 id="第一份Go文件"><a href="#第一份Go文件" class="headerlink" title="第一份Go文件"></a>第一份Go文件</h4><p>我们接下来可以开始编写和运行我们的第一份go文件了，首先我们创建好目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $GOPATH/src/github.com/XXXX/hello</span><br></pre></td></tr></table></figure><p>接着，我们在上述目录中创建新的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code hello.go #使用VSCode新建打开</span><br></pre></td></tr></table></figure><p>添加如下代码，保存并退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Hello, world.\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们回到终端，使用go工具来构建并安装程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run hello.go #运行</span><br><span class="line">go install github.com/github-user/hello  #构建hello命令，添加到bin中</span><br><span class="line">hello #运行安装好的程序，如果$GOPATH/bin 已经添加到PATH中</span><br></pre></td></tr></table></figure><p>可以看到屏幕中会有如下输出</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fvoiv5ha5uj30cn01pt8k.jpg" alt=""></p><h4 id="绑定git仓库"><a href="#绑定git仓库" class="headerlink" title="绑定git仓库"></a>绑定git仓库</h4><p>我们可以将我们的代码推送到远程的git仓库上，首先我们要安装git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install git</span><br><span class="line">git --version    #显示git版本</span><br></pre></td></tr></table></figure><p>安装好git后，我们可以配置git用户名和邮箱</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "Your Name"             #Github用户名</span><br><span class="line">git config --global user.email "email@example.com"    #与Github注册邮箱一致</span><br><span class="line">git config --global credential.helper store  #第一次提交输入密码，之后免密提交</span><br></pre></td></tr></table></figure><p>最后的最后，我们可以在上面创建的hello目录中把代码推送到远程仓库啦</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init  #初始化仓库</span><br><span class="line">git add . #上传修改的文件</span><br><span class="line">git commit -m "initial commit" #提交所有更改</span><br><span class="line">git remote add origin http://github.com/username/project.git  #此处我们首先要在远程建立一个仓库</span><br><span class="line">git push origin master   #将更改提交到远程仓库</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Go环境配置&quot;&gt;&lt;a href=&quot;#Go环境配置&quot; class=&quot;headerlink&quot; title=&quot;Go环境配置&quot;&gt;&lt;/a&gt;Go环境配置&lt;/h4&gt;&lt;p&gt;在上一次作业中我们已经配置好了Centos虚拟机，基于此我们配置安装go环境。&lt;/p&gt;
&lt;figure cl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>搭建私有云桌面</title>
    <link href="http://yyhyplxyz.github.io/2018/09/13/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A/"/>
    <id>http://yyhyplxyz.github.io/2018/09/13/服务计算第一次作业/</id>
    <published>2018-09-13T07:04:19.000Z</published>
    <updated>2018-09-13T11:40:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h2><p>这次我们要利用虚拟机搭建一个自己的私有云，并完成图形化界面的远程控制。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>​    一般意义上我们只要搭建一个linux系统，再让其可以访问公网，则可以简单的称为是一个云服务器了，但这次我们作业是要考虑到一个计算机有多个多个虚拟系统，即令一台计算机充当多个虚拟专享服务器，多个虚拟机间构成子网，多台计算机再通过路由器，交换机构成子网，从而让服务商方便快捷地管理云资源。</p><p>​    我们的作业实现思路就是为虚拟机创建两张虚拟网卡，它们分别构成了一个子网络，一张网卡是NAT模式，另一张网卡是仅主机模式。在NAT模式中，主机网卡直接与虚拟NAT设备相连，然后虚拟NAT设备与虚拟DHCP服务器一起连接在虚拟交换机VMnet8上，这样就实现了虚拟机联通外网。而Host-Only模式将虚拟机与外网隔开，使得虚拟机成为一个独立的系统，只与主机相互通讯，从而构成了一个内网。</p><p>​    主要结构如下。</p><p><img src="http://p35v64prn.bkt.clouddn.com/try4.png" alt="git"></p><h2 id="环境安装配置"><a href="#环境安装配置" class="headerlink" title="环境安装配置"></a>环境安装配置</h2><p>​    我们首先下载<a href="https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html" target="_blank" rel="noopener">VMware软件</a>，网上可以很容易地找到破解码。接着我们可以到高校ftp上下载<a href="https://mirror.tuna.tsinghua.edu.cn/centos/7.5.1804/isos/x86_64/" target="_blank" rel="noopener">centos</a>系统。</p><p>​    软件安装完毕后，我们将系统添加到VMware workstation pro中，随后我们根据提示设置用户名密码等，完成系统安装即可。进入系统后，我们输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmtui</span><br></pre></td></tr></table></figure><p>打开图形化界面然后选择激活网卡，如图所示。</p><p><img src="http://p35v64prn.bkt.clouddn.com/try5.png" alt="git"></p><p><img src="http://p35v64prn.bkt.clouddn.com/try6.png" alt="git"></p><p>接着我们在VMware里添加虚拟网卡，在虚拟机-&gt;设置-&gt;添加硬件-&gt;网络适配器中选择仅主机模式 ，如下图所示</p><p><img src="http://p35v64prn.bkt.clouddn.com/try8.PNG" alt="git"></p><p>此时我们配置了两张网卡，进入系统看下能否ping通百度等网站，如果不成功则需要进行网络开启的操作。运行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/sysconfig/network-scripts/</span><br></pre></td></tr></table></figure><p>打开某个对应系统网卡的文件，不清楚可以使用<code>ifconfig</code>命令来查看网卡和ip。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ifcfg-ens33</span><br></pre></td></tr></table></figure><p>将ONBOOT设置成yes，接着重启网络服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure><p>这样，我们就做到了开机自动启动网络服务，我们可以上网了。</p><p>​    然后，我们更新和安装一些必要的软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum install wegt</span><br><span class="line">yum update</span><br><span class="line"></span><br><span class="line">yum groupinstall "X Window System"</span><br><span class="line">yum groupinstall "GNOME Desktop"</span><br><span class="line">systemctl set-default multi-user.target  //设置成命令模式</span><br><span class="line">systemctl set-default graphical.target  //设置成图形模式</span><br><span class="line">shutdown -r now #重启</span><br></pre></td></tr></table></figure><p>​    此时我们重启后看到的应该是图形化界面了。</p><p>​    接着，我们使用 windows 的远程桌面控制来访问我们的虚拟机。但是 windows 的远程桌面使用 RDP 协议，而 linux 系统原生并不支持此协议。因此我们需要在 linux 系统安装 XRDP 来支持协议。</p><p>- 下载安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">su #图形化界面账号为非root账号，su获取root权限</span><br><span class="line">#root password</span><br><span class="line">yum install epel-release #社区对于yum的补充开源库</span><br><span class="line">yum install xrdp</span><br><span class="line">yum install tigervnc-server</span><br></pre></td></tr></table></figure><p>- 开启 XRDP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start xrdp</span><br><span class="line">systemctl enable xrdp</span><br></pre></td></tr></table></figure><p>XRDP 默认监听的端口号是3389 ，我们远程连接就可以使用这个端口号</p><p>- 关闭防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure><p>- 或不关闭防火墙，添加防火墙例外，打开3389端口命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-port=3389/tcp</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>- 启动xrdp服务，并且设置为开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start xrdp</span><br><span class="line">systemctl enable xrdp</span><br></pre></td></tr></table></figure><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>​    经过了上面的操作步骤后，我们打开远程桌面连接，就可以连接上远程服务器了，实验效果如图所示。</p><p><img src="http://p35v64prn.bkt.clouddn.com/远程控制.PNG" alt="git"></p><p>​    我们需要多个虚拟机的话，那么，刚刚配置的虚拟机，就可以作为 base，我们 clone 这个虚拟机就好了。链接克隆和完整克隆都可以，具体操纵比较简单就不再赘述了，克隆完毕后我们进入新的虚拟机系统，查看ip，同样可以远程连接到这个虚拟机系统上面去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;作业要求&quot;&gt;&lt;a href=&quot;#作业要求&quot; class=&quot;headerlink&quot; title=&quot;作业要求&quot;&gt;&lt;/a&gt;作业要求&lt;/h2&gt;&lt;p&gt;这次我们要利用虚拟机搭建一个自己的私有云，并完成图形化界面的远程控制。&lt;/p&gt;
&lt;h2 id=&quot;基本原理&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SQL期中实验报告</title>
    <link href="http://yyhyplxyz.github.io/2018/03/30/SQL%E6%9C%9F%E4%B8%AD%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <id>http://yyhyplxyz.github.io/2018/03/30/SQL期中实验报告/</id>
    <published>2018-03-29T17:08:42.000Z</published>
    <updated>2018-03-29T17:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库小实验实验报告"><a href="#数据库小实验实验报告" class="headerlink" title="数据库小实验实验报告"></a>数据库小实验实验报告</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">16340274 杨元昊</span><br></pre></td></tr></table></figure><h3 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h3><p>本作业以实现一个基本的学生成绩管理系统为例，从无到有地展示Mysql数据库的使用方法，并增进对课程学习内容的理解。</p><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>操作系统 MAC OSX</p><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="安装和初步使用Mysql"><a href="#安装和初步使用Mysql" class="headerlink" title="安装和初步使用Mysql"></a>安装和初步使用Mysql</h4><p>MySQL 是最流行的关系型 DBMS（数据库管理系统）。MySQL 使用 SQL 语言进行操作。在<a href="https://www.mysql.com" target="_blank" rel="noopener">mysql</a>官网上下载软件并安装，安装过程中会设置管理员账号和密码。启动软件后，我们使用如下语句连接数据库，其中 -u 参数是指定用户名，（root是用户名，可自由替代成别的），-p参数是表明该账号要输入密码。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u （root） -p</span><br></pre></td></tr></table></figure><p>接着输入密码后，我们就连接了数据库账户。</p><p>再接着，我们可以查看已有的数据库，并将工作环境切换到某个数据库下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>;</span><br><span class="line"><span class="keyword">use</span> information_schema</span><br></pre></td></tr></table></figure><p>这里要注意三点：</p><ol><li>sql语言是以;作为结束的，但是我们也可以用<code>DELIMITER |</code>这个语句来指定结束标志符换为|。其中|可以自己替换成任意非sql保留字符</li><li>SQL默认是大小写不敏感的，也就是说a和A在sql里被认为是一样的。虽然我们也可以在mysql的配置文件中指定大小写敏感，但从规范性的角度讲，sql的保留字我们通常要用大写，以示区分。</li><li>use + 数据库名字是我目前知道的唯一一个不用加结束符结尾的命令语句，当然了加上也是没错的。</li></ol><h4 id="数据表的增删改查与查询"><a href="#数据表的增删改查与查询" class="headerlink" title="数据表的增删改查与查询"></a>数据表的增删改查与查询</h4><h5 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h5><p>首先，我们可以创建一个数据库，接着指明使用它。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> gradesystem;</span><br><span class="line"><span class="keyword">use</span> gradesystem</span><br></pre></td></tr></table></figure><p>我们在指明了使用的数据库后，可以利用<code>SHOW TABLES;</code>来显示显示已有的表单。此时当然什么都没有啦。</p><p>下一步我们可以来创建表单了。基本的格式是这样的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表的名字</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line"></span><br><span class="line">列名a 数据类型(数据长度),</span><br><span class="line"></span><br><span class="line">列名b 数据类型(数据长度)，</span><br><span class="line"></span><br><span class="line">列名c 数据类型(数据长度)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表的名字(列名a,列名b,列名c) <span class="keyword">VALUES</span>(值<span class="number">1</span>,值<span class="number">2</span>,值<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>数据的类型有挺多的，值得注意的是以下这些类型</p><table><thead><tr><th>数据类型</th><th>大小</th><th>用途</th><th>格式</th></tr></thead><tbody><tr><td>DATE</td><td>3</td><td>日期</td><td>YYYY-MM-DD</td></tr><tr><td>TIME</td><td>3</td><td>时间点或持续时间</td><td>HH:MM:SS</td></tr><tr><td>YEAR</td><td>1</td><td>年份值</td><td>YYYY</td></tr><tr><td>CHAR</td><td>0~255</td><td>定长字符串</td><td></td></tr><tr><td>VARCHAR</td><td>0~255</td><td>变长字符串</td><td></td></tr><tr><td>TEXT</td><td>0~65535</td><td>长文本数据</td></tr></tbody></table><p>Mysql对时间差的函数做了计算优化，所以数据库中有时间变量时，最好用时间类型，而不是int double。</p><p>在实际应用开发中，评论和简介的功能是很常见的，此时选用TEXT类型比较好。</p><p>下面对比下VARCHAR与CHAR，</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VARCHAR score(20) #占据（score实际长度+1）Byte,多的一个Byte用于存放长度值</span><br><span class="line">CHAR score(20)#占据（20）Byte，如果score长度小于20，多出来的Byte都是空白的</span><br></pre></td></tr></table></figure><p>但是值得注意的是，类比内存对齐的概念，VARCHAR中存储的数据长度改变后，容易导致数据存储位置发生改变，对效率有一定影响（具体改变方式视数据库引擎不同而不同）。CHAR则没有这个隐忧，只是会稍微多占用一些存储空间。所以，实际中常将大小不怎么改变的长字符串存储成VARCHAR类型。</p><h5 id="实体／参照完整性"><a href="#实体／参照完整性" class="headerlink" title="实体／参照完整性"></a>实体／参照完整性</h5><h6 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h6><p>主键作为这一行的唯一标识符，不仅可以是表中的一列，也可以由表中的两列或多列来共同标识</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONSTRAINT 你的主键名字 PRIMARY KEY （列名1，列名2）</span><br></pre></td></tr></table></figure><h6 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h6><p>当有 DEFAULT 约束的列，插入数据为空时，将使用默认值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列名a 数据类型(数据长度),DEFAULT '默认值'</span><br></pre></td></tr></table></figure><h6 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h6><p>它规定一张表中指定的一列的值必须不能有重复值，即这一列每个值都是唯一的.</p><p>当 INSERT 语句新插入的数据和已有数据重复的时候，如果有 UNIQUE约束，则 INSERT 失败.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">列名a 数据类型(数据长度),UNIQUE </span><br><span class="line">或UNIQUE(列名)</span><br></pre></td></tr></table></figure><h6 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列名a 数据类型(数据长度),NOT NULL</span><br></pre></td></tr></table></figure><h6 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h6><p>它既能确保数据完整性，也能表现表之间的关系。一个表可以有多个外键，每个外键必须 REFERENCES (参考) 另一个表的主键，被外键约束的列，取值必须在它参考的列中有对应值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOREIGN KEY(列名a) REFERENCES 表名b(b中的列名)</span><br></pre></td></tr></table></figure><h4 id="学生成绩管理系统的构建"><a href="#学生成绩管理系统的构建" class="headerlink" title="学生成绩管理系统的构建"></a>学生成绩管理系统的构建</h4><p>初步的构建是有学生，课程和成绩三张表，互相之间用外键关联。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> gradesystem2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> gradesystem2</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line"><span class="keyword">sid</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">sname <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">gender <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="keyword">sid</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> course(</span><br><span class="line">cid <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">cname <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(cid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mark(</span><br><span class="line"> <span class="keyword">mid</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> <span class="keyword">sid</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">cid <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">score <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="keyword">mid</span>),</span><br><span class="line">FOREIGN <span class="keyword">KEY</span>(<span class="keyword">sid</span>) <span class="keyword">REFERENCES</span> student(<span class="keyword">sid</span>),</span><br><span class="line">FOREIGN <span class="keyword">KEY</span>(cid) <span class="keyword">REFERENCES</span> course(cid)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">'Tom'</span>,<span class="string">'male'</span>),(<span class="number">2</span>,<span class="string">'Jack'</span>,<span class="string">'male'</span>),(<span class="number">3</span>,<span class="string">'Rose'</span>,<span class="string">'female'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> course <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">'math'</span>),(<span class="number">2</span>,<span class="string">'physics'</span>),(<span class="number">3</span>,<span class="string">'chemistry'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mark <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">80</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">85</span>),(<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">90</span>),(<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">60</span>),(<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">90</span>),(<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">75</span>),(<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">95</span>),(<span class="number">8</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">75</span>),(<span class="number">9</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">85</span>);</span><br></pre></td></tr></table></figure><h4 id="数据库中的复杂查询"><a href="#数据库中的复杂查询" class="headerlink" title="数据库中的复杂查询"></a>数据库中的复杂查询</h4><p>查询的基本格式是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 列名 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 列名=*** <span class="keyword">ORDER</span> <span class="keyword">BY</span> 列名 <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> 某数字</span><br></pre></td></tr></table></figure><p>表示降序排列搜出来的结果，搜出来的行数有限制</p><p>查询还有MAX MIN等函数，像dataframe一样的groupby功能，也可以自己设置用户变量，自己在创建成绩系统时并没有用到这些功能，就不赘述了。</p><p>基本查询可以无限制的迭代下去，接下来我们找出物理分数最高的同学，并修改Tom 的化学成绩，下面代码就是一段多重迭代的查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span>,sname,gender <span class="keyword">FROM</span> student </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">sid</span>=(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span> <span class="keyword">FROM</span> mark </span><br><span class="line"><span class="keyword">WHERE</span> score=(</span><br><span class="line"> <span class="keyword">SELECT</span> <span class="keyword">MAX</span>(score) <span class="keyword">FROM</span> mark </span><br><span class="line">        <span class="keyword">WHERE</span> cid=<span class="number">1</span>) </span><br><span class="line"> )</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> mark <span class="keyword">set</span> score= score+<span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> cid=(</span><br><span class="line">    <span class="keyword">select</span> cid</span><br><span class="line">    <span class="keyword">from</span> course </span><br><span class="line">    <span class="keyword">where</span> cname=<span class="string">'chemistry'</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">and</span> <span class="keyword">sid</span>=(</span><br><span class="line">     <span class="keyword">select</span> <span class="keyword">sid</span></span><br><span class="line">     <span class="keyword">from</span> student</span><br><span class="line">     <span class="keyword">where</span> sname=<span class="string">'Tom'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我之前曾经研究过复杂查询的效率问题，<a href="http://yangyuanhao.com/2018/03/14/sql语言初探/#more" target="_blank" rel="noopener">见博客</a>，找出物理分数最高的同学的代码可以修改成以下的，可以提高一些查询效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span>, sname, gender <span class="keyword">FROM</span> student s</span><br><span class="line"><span class="keyword">JOIN</span> mark m</span><br><span class="line"><span class="keyword">on</span> (s.sid=m.sid )</span><br><span class="line"><span class="keyword">where</span> m.cid=<span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="设计触发器"><a href="#设计触发器" class="headerlink" title="设计触发器"></a>设计触发器</h4><p>触发器是指当表上出现特定事件时，将激活该运算，一般用于更新A表的值时自动更新B表的值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name trigger_time trigger_event</span><br><span class="line">    <span class="keyword">ON</span> tabel_name <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> trigger_stmt</span><br></pre></td></tr></table></figure><p><code>trigger_time</code>是触发程序的动作时间。它可以是<code>BEFORE</code>或<code>AFTER</code>，以指明触发程序是在激活它的语句之前或之后触发。</p><p><code>trigger_event</code>指明了激活触发程序的语句的类型。<code>trigger_event</code>可以是下述值之一：</p><ul><li><code>INSERT</code>：将新行插入表时激活触发程序，例如，通过<code>INSERT</code>、<code>LOAD DATA</code>和<code>REPLACE</code>语句实现插入数据。</li><li><code>UPDATE</code>：更改某一行时激活触发程序，例如，通过<code>UPDATE</code>语句更新数据。</li><li><code>DELETE</code>：从表中删除某一行时激活触发程序，例如，通过<code>DELETE</code>和<code>REPLACE</code>语句删除数据。</li></ul><h4 id="设计学生成绩系统的重修成绩单"><a href="#设计学生成绩系统的重修成绩单" class="headerlink" title="设计学生成绩系统的重修成绩单"></a>设计学生成绩系统的重修成绩单</h4><p>我们想用retakingmark这张表来记录学生重修成绩。</p><p>当我们在mark表中更改学生成绩时，自动地更新重修成绩表，并记录第一次考试的原始分数。（此处假定更改成绩只是因为重修或重考）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> retakingmark(</span><br><span class="line">m_mid <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">m_sid <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">m_cid <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">m_score <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">original_score <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">retaking_times <span class="built_in">int</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">m_time  datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(m_mid),</span><br><span class="line">FOREIGN <span class="keyword">KEY</span>(m_sid) <span class="keyword">REFERENCES</span> student(<span class="keyword">sid</span>),</span><br><span class="line">FOREIGN <span class="keyword">KEY</span>(m_cid) <span class="keyword">REFERENCES</span> course(cid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER |</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_modify <span class="keyword">AFTER</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> mark</span><br><span class="line">    <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> retakingmark <span class="keyword">SET</span></span><br><span class="line">            m_sid=NEW.sid,m_cid=NEW.cid,m_score=NEW.score,retaking_times=retaking_times+<span class="number">1</span>,m_time=<span class="keyword">now</span>(),original_score=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">UPDATE</span> retakingmark</span><br><span class="line"><span class="keyword">SET</span> original_score = OLD.score <span class="keyword">WHERE</span> retaking_times = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> |</span><br><span class="line">#做测试</span><br><span class="line"><span class="keyword">UPDATE</span> mark <span class="keyword">SET</span> score = score + <span class="number">3</span> <span class="keyword">WHERE</span> cid = (<span class="keyword">SELECT</span> cid <span class="keyword">FROM</span> course <span class="keyword">WHERE</span> cname = <span class="string">'chemistry'</span>) <span class="keyword">AND</span> <span class="keyword">sid</span> = (<span class="keyword">SELECT</span> <span class="keyword">sid</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sname = <span class="string">'Tom'</span>);</span><br></pre></td></tr></table></figure><h4 id="创建索引来加快系统查询"><a href="#创建索引来加快系统查询" class="headerlink" title="创建索引来加快系统查询"></a>创建索引来加快系统查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (column_name)</span><br></pre></td></tr></table></figure><p>这样如果有某些列被频繁查询的话，通过索引可以加快查询速度。要注意的是，索引过多，会导致数据库体积增大，因为维护索引，还会降低数据库增删改查的性能。因此我们可以在实际应用场景中，使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'handler_read%'</span>;</span><br></pre></td></tr></table></figure><p>来显示一个行的请求次数。若值较高则意味着在此行建立索引是高效的。若值较低则意味着增加索引所带来的性能改善不够理想。</p><h4 id="学生成绩系统的权限分配"><a href="#学生成绩系统的权限分配" class="headerlink" title="学生成绩系统的权限分配"></a>学生成绩系统的权限分配</h4><p>成绩数据库是非常重要的，为了防止误删数据，我们通常要限制用户的权限，除了最高级管理员，其他人不能修改成绩。于是我们可以创建不同权限的账户。</p><p>一般地账户权限信息被存储在mysql数据库中的<code>user</code>、<code>db</code>、<code>host</code>、<code>tables_priv</code>、<code>columns_priv</code>和<code>procs_priv</code>表中。</p><p>以下面代码为例指明了</p><p>权限对象是在localhost上运行的mysql服务中的gradesystem中所有数据表</p><p>用户名是try，密码是123456</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> gradesystem.* <span class="keyword">TO</span> <span class="string">'try'</span>@<span class="string">'localhost'</span></span><br><span class="line">    <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">权限可以是这些：SELECT,INSERT,UPDATE,DELETE,CREATE,DROP</span><br></pre></td></tr></table></figure><p>于是try用户只能查询成绩，不能作任何修改操作了</p><h4 id="简化学生成绩系统中的数据操作"><a href="#简化学生成绩系统中的数据操作" class="headerlink" title="简化学生成绩系统中的数据操作"></a>简化学生成绩系统中的数据操作</h4><p>有时候我们想简化数据库查询操作，于是可以建立子过程，子程序。</p><p>默认情况下，子程序与当前数据库关联。要明确地把子程序与一个给定数据库关联起来，可以在创建子程序的时候指定其名字为<code>db_name.sp_name</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> sp_name ([proc_parameter[,...]])</span><br><span class="line">    [characteristic ...] routine_body</span><br></pre></td></tr></table></figure><p>官方文档不是很好读，看下范例就好了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER |</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> math_show ()</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">SELECT</span> cname,sname,score <span class="keyword">FROM</span> course,student,mark <span class="keyword">WHERE</span></span><br><span class="line">            course.cid=mark.cid <span class="keyword">AND</span></span><br><span class="line">            student.sid=mark.sid <span class="keyword">AND</span></span><br><span class="line">            cname=<span class="string">'math'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>;</span><br><span class="line">    <span class="keyword">END</span> |</span><br><span class="line"><span class="keyword">CALL</span> math_show();</span><br></pre></td></tr></table></figure><p>这样我们就创建了显示所有学生数学成绩的函数了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据库小实验实验报告&quot;&gt;&lt;a href=&quot;#数据库小实验实验报告&quot; class=&quot;headerlink&quot; title=&quot;数据库小实验实验报告&quot;&gt;&lt;/a&gt;数据库小实验实验报告&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>科研方向选择的一点小思考</title>
    <link href="http://yyhyplxyz.github.io/2018/03/21/%E7%A7%91%E7%A0%94%E6%96%B9%E5%90%91%E9%80%89%E6%8B%A9%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%8F%E6%80%9D%E8%80%83/"/>
    <id>http://yyhyplxyz.github.io/2018/03/21/科研方向选择的一点小思考/</id>
    <published>2018-03-21T01:12:19.000Z</published>
    <updated>2018-03-21T01:28:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><p><img src="http://p35v64prn.bkt.clouddn.com/IMG_5703.JPG" alt="git"></p><p>​    </p><p>​    我觉得出现了上图现象有个原因，人做事一般都要有点奖励和预期奖励来促进多巴胺生产，让自己快乐，也让自己有成就感，成就感也能增加人存在的意义感。机器学习的应用跟做程序开发很像，不需要很多功夫就能打出来很好玩或者很有用的应用。应用打出来的时候也是成就感高涨的时候，会激励自己去做下一个，所以我感觉即使在行业工资差不多的情况下喜欢编程，乐此不疲打代码的很明显比喜欢做会计，乐此不疲来做帐的多。</p><p>​    做科研和做工程不太一样，做科研很少听说研究成果能应用啥的，蛟龙号，神州，还有做核弹研发的大部分是工程师或者科学家客串工程师。只有机器学习这个领域是即做科学研究又做工程师，所以即使这类方向的毕业生工资没那么高，做这类研究的人相对也会比较多的。现在区块链的研究虽然也会有应用前景，但从我浅薄的知识来看他的应用局限在记录的可信度方面，想比机器学习不是很有趣，而且我感觉区块链该有的东西差不多都有了，比特币都能造出来了。人民日报说拿区块链记账也应该不存在理论上的问题，缺的只是工程师了。各国央行都有说要推行数字货币的，不难推测已经不存在技术难题，剩下的是社会经济制度的变革方面的考虑。</p><p>​    所以，我觉得区块链相比机器学习更缺的是工程师而不是科学家。而区块链在科研界的热度应该可以类比pc时代软件开发技术的科研热度，移动端时代网络通信方面的研究热度。（我也不清楚那时候这些面热不热门 QUQ）</p><p>​    大胆的预测下，数字货币真的发行的话，很多金融机构应该会凉凉。在那个时代，一切企业的消费记录和信用记录都是公开透明的，金融的信息不对称性会大大降低，投行起码不能从发行承销上赚钱。（而这已经初见端倪，因为科技公司的强势崛起，google和阿里的ipo案例里，都是投行把客户当成大爷，这跟以往投行话语权远超上市公司是截然不同的）。甚至我觉得区块链自身就具有记账功能，在实现了电子货币的前提下，会计填平账目，审计支出都是个伪命题，区块链开发工程师会或多或少地会计的职能。因为我对金融领域也不是很理解，这部分臆想的成分较多</p><p>​    我看国家在2016年发布135国家战略发展规划中，人工智能占了两个栏目，大数据/数据挖掘占了一个栏目，物联网占了一个栏目。我国从汉代开始就有着官山海的中央金融集权制度，既从科技发展趋势来看，又从国家支持的角度来看，人工智能不管还能不能在科研界火下去，在工业界应该会挺长时间都是热门，但准入门槛应该会逐步降低（类似软件开发的学习门槛相比移动端开始的时期也降低了挺多的）</p><p>​    武辉老师一直都想蹭一个热点，比如区块链，其实从科研的角度来说，我个人认为不是热点才是常态，现在机器学习的研究本身就能作为工业应用，最多的paper从企业的实验室里出出来本身就是很特殊的。</p><p>​    从科研成果的角度我不清楚怎么样好发论文，但我觉得从吸引学生的角度来讲区块链方面不是很好找热点的话，不如更多的注重物联网方面，阿里巴巴在马来西亚和杭州都建立了智能城市，（目前还只用在了交通方面，但以后用在其他方面时肯定很需要很多的计算力，这样老师研究的云计算/雾计算都还比较有用武之地了）除此之外，国家对新零售战略很注重，阿里花90亿美金收购了饿了吗，腾讯收购了沃尔玛。我看了下阿里旗下新零售盒马生鲜的报道，里面提及了特别注重供货商的及时送货和送货路线规划，算法层面感觉会用到运筹学的理论，数据情景也和老师研究的问题挺像的。</p><p>​    如果有大佬看了，轻拍吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p35v64prn.bkt.clouddn.com/IMG_5703.JPG&quot; alt=&quot;git&quot;&gt;&lt;/p&gt;
&lt;p&gt;​    &lt;/p&gt;
&lt;p&gt;​    我觉得出现了上图现象有个原因，人做事一般都要有点奖励和预期奖励
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>xgboost</title>
    <link href="http://yyhyplxyz.github.io/2018/03/16/xgboost/"/>
    <id>http://yyhyplxyz.github.io/2018/03/16/xgboost/</id>
    <published>2018-03-16T15:57:19.000Z</published>
    <updated>2018-03-17T16:23:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装过程中出现的问题"><a href="#安装过程中出现的问题" class="headerlink" title="安装过程中出现的问题"></a>安装过程中出现的问题</h2><p>按照brew install gcc@5 pip install xgboost的方式安装出错，经过查阅stackoverflow和仔细阅读报错说明，“command python setup.py egg_info failer with error 1” 可以认定pip安装时少安装了链接文件，感觉这是在做pip安装包的bug。MAC电脑多半会出现这个错误，于是将解决方案分享给大家。</p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-3-15.4.png" alt="git"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive https://github.com/dmlc/xgboost.git</span><br><span class="line"></span><br><span class="line">cd xgboost</span><br><span class="line"></span><br><span class="line">./build.sh</span><br><span class="line"></span><br><span class="line">cd python-package</span><br><span class="line"></span><br><span class="line">python3 setup.py install</span><br></pre></td></tr></table></figure><p>运行以上命令即可，其实就是从github上下载源码然后来编译啦。</p><h2 id="简单利用xgboost来提高分类性能"><a href="#简单利用xgboost来提高分类性能" class="headerlink" title="简单利用xgboost来提高分类性能"></a>简单利用xgboost来提高分类性能</h2><p>据说这是一个非常强大的库，可以直线提高原有模型的准确度。如果对它的原理和参数具体调优设置有兴趣的可以移步到这个<a href="http://blog.csdn.net/sb19931201/article/details/52557382" target="_blank" rel="noopener">博文</a>，在下才疏学浅，就讲讲自己的简单认识吧：</p><p>xgboost的基本算法原型是决策树</p><p>决策树模型的基础上进行对样本重抽样，然后多个树平均 就得到了 Tree bagging算法</p><p>Tree bagging 算法基础上进行对特征的随机挑选就形成了随机森林算法</p><p>随机森林中多个决策树进行加权平均就得到了Boosing算法</p><p>Boosting算法一般会出现过拟合现象，于是加入了惩罚因子，树越深，因子越大，同时加入了并行计算的方法就形成了现有的 xgboosting算法了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xgboost <span class="keyword">import</span> XGBClassifier</span><br><span class="line">params=&#123;</span><br><span class="line"><span class="string">'booster'</span>:<span class="string">'gbtree'</span>,</span><br><span class="line"><span class="string">'objective'</span>: <span class="string">'multi:softmax'</span>, <span class="comment">#多分类的问题</span></span><br><span class="line"><span class="string">'num_class'</span>:<span class="number">10</span>, <span class="comment"># 类别数，与 multisoftmax 并用</span></span><br><span class="line"><span class="string">'gamma'</span>:<span class="number">0.1</span>,  <span class="comment"># 用于控制是否后剪枝的参数,越大越保守，一般0.1、0.2这样子。</span></span><br><span class="line"><span class="string">'max_depth'</span>:<span class="number">12</span>, <span class="comment"># 构建树的深度，越大越容易过拟合</span></span><br><span class="line"><span class="string">'lambda'</span>:<span class="number">2</span>,  <span class="comment"># 控制模型复杂度的权重值的L2正则化项参数，参数越大，模型越不容易过拟合。</span></span><br><span class="line"><span class="string">'subsample'</span>:<span class="number">0.7</span>, <span class="comment"># 随机采样训练样本</span></span><br><span class="line"><span class="string">'colsample_bytree'</span>:<span class="number">0.7</span>, <span class="comment"># 生成树时进行的列采样</span></span><br><span class="line"><span class="string">'min_child_weight'</span>:<span class="number">3</span>, </span><br><span class="line"><span class="comment"># 这个参数默认是 1，是每个叶子里面 h 的和至少是多少，对正负样本不均衡时的 0-1 分类而言</span></span><br><span class="line"><span class="comment">#，假设 h 在 0.01 附近，min_child_weight 为 1 意味着叶子节点中最少需要包含 100 个样本。</span></span><br><span class="line"><span class="comment">#这个参数非常影响结果，控制叶子节点中二阶导的和的最小值，该参数值越小，越容易 overfitting。 </span></span><br><span class="line"><span class="string">'silent'</span>:<span class="number">0</span> ,<span class="comment">#设置成1则没有运行信息输出，最好是设置为0.</span></span><br><span class="line"><span class="string">'eta'</span>: <span class="number">0.007</span>, <span class="comment"># 如同学习率</span></span><br><span class="line"><span class="string">'seed'</span>:<span class="number">1000</span>, <span class="comment">#随机种子</span></span><br><span class="line"><span class="string">'nthread'</span>:<span class="number">7</span>,<span class="comment"># cpu 线程数</span></span><br><span class="line"><span class="comment">#'eval_metric': 'auc'</span></span><br><span class="line">&#125;</span><br><span class="line">clf = XGBClassifier(params)</span><br><span class="line">Learn=CalibratedClassifierCV(clf, method=<span class="string">'isotonic'</span>, cv=<span class="number">2</span>)</span><br><span class="line">Learn.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装过程中出现的问题&quot;&gt;&lt;a href=&quot;#安装过程中出现的问题&quot; class=&quot;headerlink&quot; title=&quot;安装过程中出现的问题&quot;&gt;&lt;/a&gt;安装过程中出现的问题&lt;/h2&gt;&lt;p&gt;按照brew install gcc@5 pip install xgboo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>线性回归实现</title>
    <link href="http://yyhyplxyz.github.io/2018/03/16/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yyhyplxyz.github.io/2018/03/16/线性回归实现/</id>
    <published>2018-03-16T06:52:13.000Z</published>
    <updated>2018-03-16T15:54:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一元回归基本实现与向量化"><a href="#一元回归基本实现与向量化" class="headerlink" title="一元回归基本实现与向量化"></a>一元回归基本实现与向量化</h2><p>线性回归本质上是处理最优化的问题，即找到a和b，使得$\sum(y<em>{i} - ax</em>{i} - b)^2$  的值                                      尽可能小。</p><p>公式推导如下图</p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-3-15.1.JPG" alt="git"></p><p>接着让我们来实现一元线性回归的方法吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearRegression</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a = <span class="number">0</span></span><br><span class="line">        self.b = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, x_train,y_train)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> x_train.ndim == y_train.ndim == <span class="number">1</span>, <span class="string">"This is a single variable LinearRegression model"</span></span><br><span class="line">        <span class="keyword">assert</span> len(x_train) == len(y_train), <span class="string">"the size of x_train must equal to the size of y_train"</span></span><br><span class="line">        x_mean = np.mean(x_train)</span><br><span class="line">        y_mean = np.mean(y_train)</span><br><span class="line">        <span class="comment">#基本实现</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        numerator = 0.0</span></span><br><span class="line"><span class="string">        denominator = 0.0</span></span><br><span class="line"><span class="string">        for x, y in zip(x_train, y_train):</span></span><br><span class="line"><span class="string">            numerator += (x*y-x*y_mean)</span></span><br><span class="line"><span class="string">            denominator += (x*x - x*x_mean)</span></span><br><span class="line"><span class="string">        self.a = numerator / denominator</span></span><br><span class="line"><span class="string">        self.b = y_mean - self.a * x_mean</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment">#向量化实现</span></span><br><span class="line">        self.a = (x_train - x_mean).dot(y_train - y_mean) / (x_train - x_mean).dot(x_train - x_mean)</span><br><span class="line">        self.b = y_mean - self.a * x_mean</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, topredict)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> topredict.ndim == <span class="number">1</span>, <span class="string">"This is a single variable LinearRegression model"</span></span><br><span class="line">        <span class="keyword">assert</span> self.a <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> self.b <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>, <span class="string">"Must fit before"</span></span><br><span class="line">        <span class="keyword">return</span> np.array([self._predict(i) <span class="keyword">for</span> i <span class="keyword">in</span> topredict])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_predict</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.a * x + self.b</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accuracy_score</span><span class="params">(self, y_true, y_predict)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> y_true.shape[<span class="number">0</span>] == y_predict.shape[<span class="number">0</span>], <span class="string">"the size of y_true must be equal to the size of y_predict"</span></span><br><span class="line">        <span class="keyword">return</span> sum(y_true == y_predict) / len(y_true)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, x_test, y_test)</span>:</span></span><br><span class="line">        y_predict = self.predict(x_test)</span><br><span class="line">        <span class="keyword">return</span> self.accuracy_score(y_test, y_predict)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"My single variable simpleLinearRegression"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>, <span class="number">5.</span>])</span><br><span class="line">y = np.array([<span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>])</span><br><span class="line">model = LinearRegression()</span><br><span class="line">model.fit(x,y)</span><br><span class="line">y_1 = model.predict(x)</span><br><span class="line">print(y_1)</span><br><span class="line"><span class="comment">#print(model.score(y_1, y))</span></span><br></pre></td></tr></table></figure><p>事实上我在上图中推导的公式并非最简的，经过下图的推导可以进一步简化。</p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-3-15.2.JPG" alt="git"></p><p>同时代码方面也可以优化成向量的形式，通过向量运算而非循环迭代可以极大地提高cpu计算效率，而且编译器／操作系统会自发地执行并行计算，加快计算速度。</p><p>代码上面部分中就可以见到了。</p><h2 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h2><p>多元线性回归最关键的是公式的推导，根据维基百科等现有资料，将推导过程呈现如下。</p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-3-15.3.JPG" alt="git"></p><p>代码的实现是蛮容易的，也是像上文一样调用numpy的内置函数做向量化运算的处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearRegression</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.coefficient = <span class="keyword">None</span></span><br><span class="line">        self.intercept_ = <span class="keyword">None</span></span><br><span class="line">        self._theta = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit_normal</span><span class="params">(self, X_train, y_train)</span>:</span></span><br><span class="line">        X_b = np.hstack([np.ones((len(X_train), <span class="number">1</span>)), X_train])</span><br><span class="line">        self._theta = np.linalg.inv(X_b.T.dot(X_b)).dot(X_b.T).dot(y_train)</span><br><span class="line">        self.intercept_ = self._theta[<span class="number">0</span>]</span><br><span class="line">        self.coefficient = self._theta[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X_predict)</span>:</span></span><br><span class="line">        X_b = np.hstack([np.ones((len(X_predict), <span class="number">1</span>)), X_predict])</span><br><span class="line">        <span class="keyword">return</span> X_b.dot(self._theta)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"My Multivariable LinearRegression"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一元回归基本实现与向量化&quot;&gt;&lt;a href=&quot;#一元回归基本实现与向量化&quot; class=&quot;headerlink&quot; title=&quot;一元回归基本实现与向量化&quot;&gt;&lt;/a&gt;一元回归基本实现与向量化&lt;/h2&gt;&lt;p&gt;线性回归本质上是处理最优化的问题，即找到a和b，使得$\su
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>sklearn中使用KNN的范例</title>
    <link href="http://yyhyplxyz.github.io/2018/03/14/sklearn%E4%B8%AD%E4%BD%BF%E7%94%A8KNN%E7%9A%84%E8%8C%83%E4%BE%8B/"/>
    <id>http://yyhyplxyz.github.io/2018/03/14/sklearn中使用KNN的范例/</id>
    <published>2018-03-14T12:27:49.000Z</published>
    <updated>2018-03-14T12:55:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><p>数据挖掘建模中一个非常常见的应用就是商品购买预测，本文将利用sklearn中的KNN算法来做这个案例，最终展现我们预测结果的二维等高线填充地图和实际结果的散点分布。</p><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>数据格式如下图</p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-3-14.1.png" alt="git"></p><p>常规的做法是要将male和female转换为数值型变量，在本例中暂不做此操作。接着我们要将年龄和预计收入归一化。这是因为收入的数值远大于年龄的数值，考虑到KNN算法的特性，不如此的话将导致收入的影响极大，年龄影响极小。于是我们采用了均值方差归一化的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">sc = StandardScaler()</span><br><span class="line">X_train = sc.fit_transform(X_train)</span><br><span class="line">X_test = sc.transform(X_test)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#绘制我们预测结果的二维等高线填充地图</span></span><br><span class="line">X_set, y_set = X_train, y_train</span><br><span class="line">X1, X2 = np.meshgrid(np.arange(start = X_set[:, <span class="number">0</span>].min() - <span class="number">1</span>, stop = X_set[:, <span class="number">0</span>].max() + <span class="number">1</span>, step = <span class="number">0.01</span>),</span><br><span class="line">                     np.arange(start = X_set[:, <span class="number">1</span>].min() - <span class="number">1</span>, stop = X_set[:, <span class="number">1</span>].max() + <span class="number">1</span>, step = <span class="number">0.01</span>))</span><br><span class="line">plt.contourf(X1, X2, classifier.predict(np.array([X1.ravel(), X2.ravel()]).T).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="number">0.75</span>, cmap = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>)))<span class="comment">#根据我们的预测值0，1来确定不同点\区域的颜色是红或者绿</span></span><br><span class="line">plt.xlim(X1.min(), X1.max())</span><br><span class="line">plt.ylim(X2.min(), X2.max())</span><br></pre></td></tr></table></figure><p>显示如下</p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-3-14.2.png" alt="git"></p><p>最终我们将实际的结果以散点图的形式绘制出来，同样以红绿两色表示二分类问题。</p><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(np.unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set == j, <span class="number">0</span>], X_set[y_set == j, <span class="number">1</span>],</span><br><span class="line">                c = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>))(i), label = j)</span><br><span class="line">            </span><br><span class="line">plt.title(<span class="string">'K-NN (Training set)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Age'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Estimated Salary'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="http://p35v64prn.bkt.clouddn.com/2018-3-14.3.png" alt="git"></p><p>全部代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dataset = pd.read_csv(<span class="string">'Social_Network_Ads.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, [<span class="number">2</span>, <span class="number">3</span>]].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">4</span>].values</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.25</span>, random_state = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">sc = StandardScaler()</span><br><span class="line">X_train = sc.fit_transform(X_train)</span><br><span class="line">X_test = sc.transform(X_test)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line">classifier = KNeighborsClassifier(n_neighbors = <span class="number">5</span>, metric = <span class="string">'minkowski'</span>, p = <span class="number">2</span>)</span><br><span class="line">classifier.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">y_pred = classifier.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line">cm = confusion_matrix(y_test, y_pred)</span><br><span class="line"><span class="comment"># Visualising the Training set results</span></span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">X_set, y_set = X_train, y_train</span><br><span class="line">X1, X2 = np.meshgrid(np.arange(start = X_set[:, <span class="number">0</span>].min() - <span class="number">1</span>, stop = X_set[:, <span class="number">0</span>].max() + <span class="number">1</span>, step = <span class="number">0.01</span>),</span><br><span class="line">                     np.arange(start = X_set[:, <span class="number">1</span>].min() - <span class="number">1</span>, stop = X_set[:, <span class="number">1</span>].max() + <span class="number">1</span>, step = <span class="number">0.01</span>))</span><br><span class="line">plt.contourf(X1, X2, classifier.predict(np.array([X1.ravel(), X2.ravel()]).T).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="number">0.75</span>, cmap = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>)))</span><br><span class="line">plt.xlim(X1.min(), X1.max())</span><br><span class="line">plt.ylim(X2.min(), X2.max())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(np.unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set == j, <span class="number">0</span>], X_set[y_set == j, <span class="number">1</span>],</span><br><span class="line">                c = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>))(i), label = j)</span><br><span class="line">            </span><br><span class="line">plt.title(<span class="string">'K-NN (Training set)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Age'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Estimated Salary'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">from matplotlib.colors import ListedColormap</span></span><br><span class="line"><span class="string">X_set, y_set = X_test, y_test</span></span><br><span class="line"><span class="string">X1, X2 = np.meshgrid(np.arange(start = X_set[:, 0].min() - 1, stop = X_set[:, 0].max() + 1, step = 0.01),</span></span><br><span class="line"><span class="string">                     np.arange(start = X_set[:, 1].min() - 1, stop = X_set[:, 1].max() + 1, step = 0.01))</span></span><br><span class="line"><span class="string">plt.contourf(X1, X2, classifier.predict(np.array([X1.ravel(), X2.ravel()]).T).reshape(X1.shape),</span></span><br><span class="line"><span class="string">             alpha = 0.75, cmap = ListedColormap(('red', 'green')))</span></span><br><span class="line"><span class="string">plt.xlim(X1.min(), X1.max())</span></span><br><span class="line"><span class="string">plt.ylim(X2.min(), X2.max())</span></span><br><span class="line"><span class="string">for i, j in enumerate(np.unique(y_set)):</span></span><br><span class="line"><span class="string">    plt.scatter(X_set[y_set == j, 0], X_set[y_set == j, 1],</span></span><br><span class="line"><span class="string">                c = ListedColormap(('red', 'green'))(i), label = j)</span></span><br><span class="line"><span class="string">plt.title('K-NN (Test set)')</span></span><br><span class="line"><span class="string">plt.xlabel('Age')</span></span><br><span class="line"><span class="string">plt.ylabel('Estimated Salary')</span></span><br><span class="line"><span class="string">plt.legend()</span></span><br><span class="line"><span class="string">plt.show()</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;导论&quot;&gt;&lt;a href=&quot;#导论&quot; class=&quot;headerlink&quot; title=&quot;导论&quot;&gt;&lt;/a&gt;导论&lt;/h2&gt;&lt;p&gt;数据挖掘建模中一个非常常见的应用就是商品购买预测，本文将利用sklearn中的KNN算法来做这个案例，最终展现我们预测结果的二维等高线填充地
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>sql语言优化（1）</title>
    <link href="http://yyhyplxyz.github.io/2018/03/14/sql%E8%AF%AD%E8%A8%80%E5%88%9D%E6%8E%A2/"/>
    <id>http://yyhyplxyz.github.io/2018/03/14/sql语言初探/</id>
    <published>2018-03-14T06:24:12.000Z</published>
    <updated>2018-03-17T15:55:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h1><p>sql语言不是图灵完备的，顾名思义，它是不能作出图灵机的。从中也可以见的它的语法是蛮简单的。</p><h2 id="几个基本优化方法"><a href="#几个基本优化方法" class="headerlink" title="几个基本优化方法"></a>几个基本优化方法</h2><p>虽然基本语法很简单，大家看看就会了。但是每一个数据提取，修改的操作效率都具有很大提升空间。</p><h3 id="使用join-代替in"><a href="#使用join-代替in" class="headerlink" title="使用join 代替in"></a>使用join 代替in</h3><p>在这个博客地址中<a href="http://openxtiger.iteye.com/blog/1911228" target="_blank" rel="noopener">http://openxtiger.iteye.com/blog/1911228</a> ，作者做了实验证明了join操作会比子查询效率高很多。事实上，子查询操作要循环多次查找子表，耗时较多，而join方法会将多个表格连接起来，可以避免多次循环查找的问题。</p><p>比如下面这两个写法是等价的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> hotel_info_original <span class="keyword">as</span> c </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> hotel_info_collection h </span><br><span class="line"><span class="keyword">on</span> c.hotel_type=h.hotel_type <span class="keyword">and</span> c.hotel_id =h.hotel_id </span><br><span class="line"><span class="keyword">where</span> h.hotel_id <span class="keyword">is</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c.* <span class="keyword">from</span> hotel_info_original </span><br><span class="line"><span class="keyword">where</span> c.hotel_id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> h.hotel_id <span class="keyword">from</span>  hotel_info_collection <span class="keyword">where</span> h.hotel_type = c.hotel_type)</span><br></pre></td></tr></table></figure><p>Left join是左连接，即从左表(A)产生一套完整的记录,与匹配的记录(右表(B)) .如果没有匹配,右侧将包含null</p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-3-16.1.png" alt="git"></p><p>实际上它是将左表和右表完全拼接起来，不满足on中条件的全部变成NULL。因此在数据库操作过程中，要尽量的多将语句写在on中，这样可以减少where查询时间，也能够提高效率。还不理解的，可以看下图实例再揣摩一下</p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-3-16.2.png" alt="git"></p><h3 id="使用工具进行大表修改"><a href="#使用工具进行大表修改" class="headerlink" title="使用工具进行大表修改"></a>使用工具进行大表修改</h3><p>我们知道在实际应用过程中，当对大表进行修改数据类型时，会造成数据库结构较大的变动。此时mysql会锁表，一切请求只能读不能写，造成大量请求排队，效率极低。因此一个改进的办法就是在主服务器重新建一个表，在旧表上每个entry都安装触发器，修改的请求将会在旧表上进行。这些变化再同步到新表中。</p><p>实际编程较繁琐，起码我不会QUQ</p><p>但是大佬们帮我们封装好了工具，那就是<a href="https://www.percona.com/doc/percona-toolkit/LATEST/pt-online-schema-change.html" target="_blank" rel="noopener">pt-online-schema-change</a>，自己去官网上免费下载安装就好啦。</p><p>基本参数信息如下</p><ul><li><p><code>--host=xxx --user=xxx --password=xxx</code><br>连接实例信息，缩写<code>-h xxx -u xxx -p xxx</code>，密码可以使用参数<code>--ask-pass</code> 手动输入。</p></li><li><p><code>--alter</code></p><p>结构变更语句</p></li></ul><ul><li><code>D=db_name,t=table_name</code><br>指定要ddl的数据库名和表名</li><li><code>--execute</code><br>确定修改表，则指定该参数。真正执行alter。</li><li><code>--execute</code><br>确定修改表，则指定该参数。真正执行alter。–dry-run与–execute必须指定一个，二者相互排斥</li><li><code>--execute</code><br>确定修改表，则指定该参数。真正执行alter。–dry-run与–execute必须指定一个，二者相互排斥</li><li><code>--execute</code><br>确定修改表，则指定该参数。真正执行alter。–dry-run与–execute必须指定一个，二者相互排斥</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-<span class="keyword">change</span> -ujacky -p xxx -h <span class="string">"10.0.201.34"</span> D=confluence,t=sbtest3 \</span><br><span class="line"><span class="comment">--alter "CHANGE pad f_pad varchar(60) NOT NULL DEFAULT '' " \</span></span><br><span class="line"><span class="comment">--execute</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本认识&quot;&gt;&lt;a href=&quot;#基本认识&quot; class=&quot;headerlink&quot; title=&quot;基本认识&quot;&gt;&lt;/a&gt;基本认识&lt;/h1&gt;&lt;p&gt;sql语言不是图灵完备的，顾名思义，它是不能作出图灵机的。从中也可以见的它的语法是蛮简单的。&lt;/p&gt;
&lt;h2 id=&quot;几个基
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>梯度下降法简单实现</title>
    <link href="http://yyhyplxyz.github.io/2018/03/13/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yyhyplxyz.github.io/2018/03/13/梯度下降法简单实现/</id>
    <published>2018-03-13T14:22:05.000Z</published>
    <updated>2018-03-13T14:22:05.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>KNN算法的简单实现</title>
    <link href="http://yyhyplxyz.github.io/2018/03/13/KNN%E7%AE%97%E6%B3%95%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yyhyplxyz.github.io/2018/03/13/KNN算法的简单实现/</id>
    <published>2018-03-13T14:13:12.000Z</published>
    <updated>2018-03-13T15:32:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><p>KNN算法可以形象的理解成是找出离点A最近的K个点，根据这K个点中不同属性的个数来确定A的属性是怎样的。（在实际问题中，高维空间中点的各个坐标表示了一个特征，属性表示了特征代表的结果。）它可以说是最简单的机器学习算法了，但具有这高数据敏感性和算法复杂度高的问题。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>模仿sklearn的借口，写了简单的一个KNN的类</p><p>KNN算法最终有个投票环节，简单版本是A点周围K个点，每个点都只能投一票，更复杂的版本是根据距离来设定投票的权重，距离近则权重大，可以拥有不止一票的投票权</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KNN_classifier</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> k &gt;= <span class="number">1</span>, <span class="string">"k must be valid"</span></span><br><span class="line">        self.k = k</span><br><span class="line">        self._X_train = <span class="keyword">None</span></span><br><span class="line">        self._y_train = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X_train, y_train)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> X_train.shape[<span class="number">0</span>] == y_train.shape[<span class="number">0</span>], \</span><br><span class="line">            <span class="string">"the size of X_train must be equal to the size of y_train"</span></span><br><span class="line">        <span class="keyword">assert</span> self.k &lt;= X_train.shape[<span class="number">0</span>], \</span><br><span class="line">            <span class="string">"the size of X_train must be at least k."</span></span><br><span class="line"></span><br><span class="line">        self._X_train = X_train</span><br><span class="line">        self._y_train = y_train</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X_predict)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> self._X_train <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> self._y_train <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>, \</span><br><span class="line">                <span class="string">"must fit before predict!"</span></span><br><span class="line">        <span class="keyword">assert</span> X_predict.shape[<span class="number">1</span>] == self._X_train.shape[<span class="number">1</span>], \</span><br><span class="line">                <span class="string">"the feature number of X_predict must be equal to X_train"</span></span><br><span class="line"></span><br><span class="line">        y_predict = [self._predict(x) <span class="keyword">for</span> x <span class="keyword">in</span> X_predict]</span><br><span class="line">        <span class="keyword">return</span> np.array(y_predict)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_predict</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> x.shape[<span class="number">0</span>] == self._X_train.shape[<span class="number">1</span>], \</span><br><span class="line">            <span class="string">"the feature number of x must be equal to X_train"</span></span><br><span class="line"></span><br><span class="line">        distances = [sqrt(np.sum((x_train - x) ** <span class="number">2</span>))</span><br><span class="line">                     <span class="keyword">for</span> x_train <span class="keyword">in</span> self._X_train]</span><br><span class="line">        nearest = np.argsort(distances)</span><br><span class="line"></span><br><span class="line">        topK_y = [self._y_train[i] <span class="keyword">for</span> i <span class="keyword">in</span> nearest[:self.k]]</span><br><span class="line">        votes = Counter(topK_y)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> votes.most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"KNN(k=%d)"</span> % self.k</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict_adavnce</span><span class="params">(self, X_test)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> X_test.shape[<span class="number">1</span>] == self._X_train.shape[<span class="number">1</span>], <span class="string">"the number of features in train set and test set must be equal"</span></span><br><span class="line">        <span class="keyword">assert</span> self._X_train <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> self._y_train <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>, \</span><br><span class="line">                <span class="string">"must fit before predict!"</span></span><br><span class="line">        y_predict = [self._predict_advance(x) <span class="keyword">for</span> x <span class="keyword">in</span> X_test]</span><br><span class="line">        <span class="keyword">return</span> np.array(y_predict)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_predict_advance</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> x.shape[<span class="number">0</span>] == self._X_train.shape[<span class="number">1</span>], <span class="string">"the number of features in train set and test set must be equal"</span></span><br><span class="line">        distances = [sqrt(np.sum((train - x)**<span class="number">2</span>)) <span class="keyword">for</span> train <span class="keyword">in</span> self._X_train]</span><br><span class="line">        <span class="comment">#print(sum(i == 0 for i in distances))</span></span><br><span class="line">        nearest = np.argsort(distances)</span><br><span class="line">        topK_y = [self._y_train[i] <span class="keyword">for</span> i <span class="keyword">in</span> nearest[:self.k]]</span><br><span class="line">        <span class="comment">#print(topK_y)</span></span><br><span class="line">        votes = Counter()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nearest[:self.k]:</span><br><span class="line">            votes[self._y_train[i]] += (<span class="number">1</span>/(distances[i]**<span class="number">2</span> + <span class="number">1</span>)) <span class="comment"># 1/i</span></span><br><span class="line">            <span class="comment">#print(votes.most_common(1)[0][0])</span></span><br><span class="line">        <span class="keyword">return</span> votes.most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train_test_split</span><span class="params">(self, X,y, text_ratio, seed = <span class="number">0</span> )</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> X.shape[<span class="number">0</span>] == y.shape[<span class="number">0</span>], <span class="string">"the size of X must be equal tp teh size of y"</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="number">0.0</span> &lt;= text_ratio &lt;= <span class="number">1.0</span>, <span class="string">"text_ratio must be valid"</span></span><br><span class="line">        <span class="keyword">if</span> seed:</span><br><span class="line">            np.random.seed(seed)</span><br><span class="line">        shuffleindex = np.random.permutation(len(X))</span><br><span class="line">        text_size = int(len(X) * text_ratio)</span><br><span class="line">        train_index = shuffleindex[text_size:]</span><br><span class="line">        test_index = shuffleindex[:text_size]</span><br><span class="line">        x_train = X[train_index]</span><br><span class="line">        y_train = y[train_index]</span><br><span class="line">        x_test = X[test_index]</span><br><span class="line">        y_test = y[test_index]</span><br><span class="line">        <span class="keyword">return</span> x_train, x_test,y_train,y_test</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, x_test, y_test)</span>:</span></span><br><span class="line">        y_predict = self.predict(x_test)</span><br><span class="line">        <span class="keyword">return</span> accuracy_score(y_test, y_predict)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accuracy_score</span><span class="params">(test, predict)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum(test == predict) / len(predict)</span><br><span class="line"></span><br><span class="line">digits = datasets.load_digits()</span><br><span class="line">X = digits.data</span><br><span class="line">y = digits.target</span><br><span class="line">temp = KNN_classifier(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.2</span>)</span><br><span class="line">my_knn_clf = KNN_classifier(k=<span class="number">3</span>)</span><br><span class="line">my_knn_clf.fit(X_train, y_train)</span><br><span class="line"><span class="comment">#y_predict = my_knn_clf.predict(X_test)</span></span><br><span class="line">print(X_test.shape)</span><br><span class="line">y_predict = my_knn_clf.predict_adavnce(X_test)</span><br><span class="line">print(y_predict.shape)</span><br><span class="line">print(y_test.shape)</span><br><span class="line">print(sum(y_test == y_predict) / len(y_test))</span><br></pre></td></tr></table></figure><p>以上代码中predict_advance是高级版本的实现，利用手写数字的数据集发现写的代码没错，准确率还是蛮高的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;导论&quot;&gt;&lt;a href=&quot;#导论&quot; class=&quot;headerlink&quot; title=&quot;导论&quot;&gt;&lt;/a&gt;导论&lt;/h2&gt;&lt;p&gt;KNN算法可以形象的理解成是找出离点A最近的K个点，根据这K个点中不同属性的个数来确定A的属性是怎样的。（在实际问题中，高维空间中点的各个坐
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>semantic 学习</title>
    <link href="http://yyhyplxyz.github.io/2018/01/28/semantic-%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yyhyplxyz.github.io/2018/01/28/semantic-学习/</id>
    <published>2018-01-28T07:25:02.000Z</published>
    <updated>2018-01-28T08:42:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Semantic UI是一个在github上已经获得39264个star的漂亮的css框架，它具有语义化特点，也就是说语法特别容易上手。</p><h3 id="安装与简单使用"><a href="#安装与简单使用" class="headerlink" title="安装与简单使用"></a>安装与简单使用</h3><p>安装教程在<a href="https://semantic-ui.com/introduction/getting-started.html" target="_blank" rel="noopener">官网</a>。</p><p>分为简单安装和完全安装。简单安装只要下载了对应的css和js文件即可，我们在写前端时，引用对应的文件即可。</p><p>完全安装较麻烦一些，但可以支持更换主题，定制各按钮，表格样式等操作。</p><p>注意，如果只是简单安装的话，官网上给出的include in your html需要注意更改文件目录</p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-1-284.png" alt="git"></p><p>我们可以在官方文档中找到多个样式的代码，看哪个自己喜欢的就复制粘贴一下，如下面的代码自己就能在网页中显示图中的效果。</p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-1-285.png" alt="git"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"/Users/yangyuanhao/semantic/dist/semantic.min.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.1.1.min.js"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">integrity</span>=<span class="string">"sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="</span></span></span><br><span class="line"><span class="tag">  <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"semantic/dist/semantic.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"ui button"</span>&gt;</span>Follow<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="更换主题与样式修改"><a href="#更换主题与样式修改" class="headerlink" title="更换主题与样式修改"></a>更换主题与样式修改</h3><p>当我们使用Semantic UI来构建网页时，我们有时候会发现自己的网页打开的比较慢，这是由于国内的网络环境造成的。<img src="http://p35v64prn.bkt.clouddn.com/2018-1-286.png" alt="git"></p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-1-287.png" alt="git"></p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-1-288.png" alt="git"></p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-1-289.png" alt="git"></p><h3 id="网站的整体布局"><a href="#网站的整体布局" class="headerlink" title="网站的整体布局"></a>网站的整体布局</h3><p>inverted 反色处理</p><p>左右边距可以用container</p><p>segment左右无空，用于网页底部等</p><p>grid</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;Semantic UI是一个在github上已经获得39264个star的漂亮的css框架，它具有语义化特点，也就是说语法特别容易上手。&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>经济机器是如何运转的</title>
    <link href="http://yyhyplxyz.github.io/2018/01/27/%E7%BB%8F%E6%B5%8E%E6%9C%BA%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%BD%AC%E7%9A%84/"/>
    <id>http://yyhyplxyz.github.io/2018/01/27/经济机器是如何运转的/</id>
    <published>2018-01-26T16:38:39.000Z</published>
    <updated>2018-01-26T16:38:39.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>奥斯维辛:一部尘封的历史</title>
    <link href="http://yyhyplxyz.github.io/2018/01/27/%E5%A5%A5%E6%96%AF%E7%BB%B4%E8%BE%9B-%E4%B8%80%E9%83%A8%E5%B0%98%E5%B0%81%E7%9A%84%E5%8E%86%E5%8F%B2/"/>
    <id>http://yyhyplxyz.github.io/2018/01/27/奥斯维辛-一部尘封的历史/</id>
    <published>2018-01-26T16:35:54.000Z</published>
    <updated>2018-01-26T16:35:54.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jquery实现记事本</title>
    <link href="http://yyhyplxyz.github.io/2018/01/27/jquery%E5%AE%9E%E7%8E%B0%E8%AE%B0%E4%BA%8B%E6%9C%AC/"/>
    <id>http://yyhyplxyz.github.io/2018/01/27/jquery实现记事本/</id>
    <published>2018-01-26T16:34:58.000Z</published>
    <updated>2018-01-26T16:34:58.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大明1556</title>
    <link href="http://yyhyplxyz.github.io/2018/01/27/%E5%A4%A7%E6%98%8E1556/"/>
    <id>http://yyhyplxyz.github.io/2018/01/27/大明1556/</id>
    <published>2018-01-26T16:26:08.000Z</published>
    <updated>2018-01-26T16:30:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>当国家（政府）有难时，牺牲的一定是平民百姓或商人。</p><p>（当民情汹涌时，）为了社会稳定，政府一定会牺牲政治斗争失败的官员或商人。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当国家（政府）有难时，牺牲的一定是平民百姓或商人。&lt;/p&gt;
&lt;p&gt;（当民情汹涌时，）为了社会稳定，政府一定会牺牲政治斗争失败的官员或商人。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
