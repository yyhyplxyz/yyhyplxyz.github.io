<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>元昊的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yyhyplxyz.github.io/"/>
  <updated>2018-01-28T08:08:11.000Z</updated>
  <id>http://yyhyplxyz.github.io/</id>
  
  <author>
    <name>Jack Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>semantic 学习</title>
    <link href="http://yyhyplxyz.github.io/2018/01/28/semantic-%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yyhyplxyz.github.io/2018/01/28/semantic-学习/</id>
    <published>2018-01-28T07:25:02.000Z</published>
    <updated>2018-01-28T08:08:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h3 id="安装与简单使用"><a href="#安装与简单使用" class="headerlink" title="安装与简单使用"></a>安装与简单使用</h3><p>安装教程在<a href="https://semantic-ui.com/introduction/getting-started.html" target="_blank" rel="noopener">官网</a>。</p><p>分为简单安装和完全安装。简单安装只要下载了对应的css和js文件即可，我们在写前端时，引用对应的文件即可。</p><p>完全安装较麻烦一些，但可以支持更换主题，定制各按钮，表格样式等操作。</p><p>注意，如果只是简单安装的话，官网上给出的include in your html需要注意更改文件目录</p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-1-284.png" alt="git"></p><p>我们可以在官方文档中找到多个样式的代码，看哪个自己喜欢的就复制粘贴一下，如下面的代码自己就能在网页中显示图中的效果。</p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-1-285.png" alt="git"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"/Users/yangyuanhao/semantic/dist/semantic.min.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.1.1.min.js"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">integrity</span>=<span class="string">"sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="</span></span></span><br><span class="line"><span class="tag">  <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"semantic/dist/semantic.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"ui button"</span>&gt;</span>Follow<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;h3 id=&quot;安装与简单使用&quot;&gt;&lt;a href=&quot;#安装与简单使用&quot; class=&quot;headerlink&quot; title=&quot;安装与简单使用&quot;&gt;&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>html5学习</title>
    <link href="http://yyhyplxyz.github.io/2018/01/28/html5%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yyhyplxyz.github.io/2018/01/28/html5学习/</id>
    <published>2018-01-28T06:35:17.000Z</published>
    <updated>2018-01-28T07:54:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h3><p>Html5 = html+css+javascript+api</p><p>2014年html5定稿，新增了离线存储，丰富表单，js线程，多媒体引擎，不止用来开发网页，还可以开发app，（快速迭代，降低成本）</p><p>native app-》web app-》native app</p><p>浏览器需要兼容html5。</p><h3 id="标签的变化"><a href="#标签的变化" class="headerlink" title="标签的变化"></a>标签的变化</h3><p>doctype指示浏览器使用哪个标准来渲染页面。</p><p>dtd是标记语言的一种规则。</p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-1-281.png" alt="git"></p><p>‘<div> <span> <a>‘就是在dtd，使用xml来指定功能的</a></span></div></p><h5 id="结构标签"><a href="#结构标签" class="headerlink" title="结构标签"></a>结构标签</h5><p>块状元素，有意义的div标签。</p><p><article>定义文章</article></p><p><nav>定义导航链接</nav></p><p><header>定义页面或区域头部</header></p><p>《section》标记定义区域</p><p>《aside》标记侧边栏</p><p>《hgroup》标记文件中一个区块的信息，用hgroup规整多个h1等标题</p><p>《figure》定义媒体内容及标题</p><p>《figurecaption》给figure元素标题</p><p>《footer》定义页面或区域底部</p><p>《dialog》可以标记对话框</p><h5 id="多媒体标签"><a href="#多媒体标签" class="headerlink" title="多媒体标签"></a>多媒体标签</h5><p>可以添加文字，当不支持时显示对应文字</p><p>《video》有height与length</p><p>《audio》</p><p>《source》可用于多种格式转码</p><p>《canvas》标记图片</p><p>《embed》外部可交互的内容，插件</p><p>富媒体的发展，不需要插件即可操作媒体文件，极大地提升了使用体验</p><h5 id="web应用标签"><a href="#web应用标签" class="headerlink" title="web应用标签"></a>web应用标签</h5><p>《meter》状态标签，value的值不能超过max或者低于min的值，否则将会向上或向下取整 chrome opera</p><p>《progress》进度的标签 chrome Firefox opera</p><p>《datalist》定义下拉标签，非常方便，可以少写很多js代码，对用户来说操作更方便，firefox，chrome，opera</p><p>《dtails》左边有个三角符号</p><p>《menu》目前所有主流浏览器都不支持，可以实现软件的菜单下拉列表的功能</p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-1-283.png" alt="git"></p><p>《menuitem》火狐8.0以上支持</p><p>《command》定义命令按钮，只有ie9支持</p><h5 id="其他标签"><a href="#其他标签" class="headerlink" title="其他标签"></a>其他标签</h5><p>《ruby》标记定义拼音，音标，注释</p><p>《rt》配合使用显示拼音</p><p>《mark》</p><h3 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h3><h3 id="属性变化"><a href="#属性变化" class="headerlink" title="属性变化"></a>属性变化</h3><h3 id="HTML5展望"><a href="#HTML5展望" class="headerlink" title="HTML5展望"></a>HTML5展望</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;导论&quot;&gt;&lt;a href=&quot;#导论&quot; class=&quot;headerlink&quot; title=&quot;导论&quot;&gt;&lt;/a&gt;导论&lt;/h3&gt;&lt;p&gt;Html5 = html+css+javascript+api&lt;/p&gt;
&lt;p&gt;2014年html5定稿，新增了离线存储，丰富表单，js线程，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>经济机器是如何运转的</title>
    <link href="http://yyhyplxyz.github.io/2018/01/27/%E7%BB%8F%E6%B5%8E%E6%9C%BA%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%BD%AC%E7%9A%84/"/>
    <id>http://yyhyplxyz.github.io/2018/01/27/经济机器是如何运转的/</id>
    <published>2018-01-26T16:38:39.000Z</published>
    <updated>2018-01-26T16:38:39.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>奥斯维辛:一部尘封的历史</title>
    <link href="http://yyhyplxyz.github.io/2018/01/27/%E5%A5%A5%E6%96%AF%E7%BB%B4%E8%BE%9B-%E4%B8%80%E9%83%A8%E5%B0%98%E5%B0%81%E7%9A%84%E5%8E%86%E5%8F%B2/"/>
    <id>http://yyhyplxyz.github.io/2018/01/27/奥斯维辛-一部尘封的历史/</id>
    <published>2018-01-26T16:35:54.000Z</published>
    <updated>2018-01-26T16:35:54.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jquery实现记事本</title>
    <link href="http://yyhyplxyz.github.io/2018/01/27/jquery%E5%AE%9E%E7%8E%B0%E8%AE%B0%E4%BA%8B%E6%9C%AC/"/>
    <id>http://yyhyplxyz.github.io/2018/01/27/jquery实现记事本/</id>
    <published>2018-01-26T16:34:58.000Z</published>
    <updated>2018-01-26T16:34:58.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大明1556</title>
    <link href="http://yyhyplxyz.github.io/2018/01/27/%E5%A4%A7%E6%98%8E1556/"/>
    <id>http://yyhyplxyz.github.io/2018/01/27/大明1556/</id>
    <published>2018-01-26T16:26:08.000Z</published>
    <updated>2018-01-26T16:30:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>当国家（政府）有难时，牺牲的一定是平民百姓或商人。</p><p>（当民情汹涌时，）为了社会稳定，政府一定会牺牲政治斗争失败的官员或商人。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当国家（政府）有难时，牺牲的一定是平民百姓或商人。&lt;/p&gt;
&lt;p&gt;（当民情汹涌时，）为了社会稳定，政府一定会牺牲政治斗争失败的官员或商人。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>东野圭吾的《白金数据》</title>
    <link href="http://yyhyplxyz.github.io/2018/01/26/%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE%E7%9A%84%E3%80%8A%E7%99%BD%E9%87%91%E6%95%B0%E6%8D%AE%E3%80%8B/"/>
    <id>http://yyhyplxyz.github.io/2018/01/26/东野圭吾的《白金数据》/</id>
    <published>2018-01-26T15:56:06.000Z</published>
    <updated>2018-01-26T16:29:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>考完试后回到家里，闲来无事便读了一个下午读完了这本新出的侦探小说。比较符合我对东野圭吾的预期，小说很有悬念，比较刺激，但文学性和思想性不足，只是消遣性读物。</p><p>后面会涉及严重剧透=======================================</p><p>故事主要描述了日本想全国范围内收集民众的DNA数据，从而通过罪犯遗留下来的任何可能携带基因的物品，达到快速找到罪犯亲属或罪犯的目的。但这样巨大的工程容易造成民众隐私的泄漏，同时在小说中通过一系列无法通过基因数据库找到罪犯消息的犯罪案件和主角的被嫁祸，几个重要配角的反转，揭示了政府重要官员在数据库中做的手脚——他们的亲属犯罪将无法通过基因匹配找到罪犯的信息，自然的也将无法通过基因匹配查到他们身上。</p><p>这些政府官员的数据就是白金数据。</p><p>小说想向我们揭示大数据技术下个人隐私泄漏的可能，这不过是老生常谈。支付宝之前的年度账单事件就拔出萝卜带着泥，牵扯了一大批不合理读取用户个人数据的app。可以想象对掌控着我们所有社交信息的腾讯公司而言，我们几乎就是白纸一张，一切都能被人一眼望到底。</p><p>作者还想引起我们的思考，人心到底是不是完全物质化的呢？毕竟激素，神经递质，他们主宰着我们的情绪和思想。随着技术的进步，我们完全可以人造情感和思想。无奈太过浅尝辄止，作者本身并没有通过故事深入讨论这个话题。</p><p>东野圭吾应该也试图展示政府高级官员的龌龊。太阳底下没有新鲜事，全国范围内收集民众的DNA数据是一个涉及法律和公安执法的变革，历朝历代的变革根本目的都是更好地维护统治阶级的利益。屁股决定脑袋，换成说是日本政坛大佬都会这样做的。君王一怒，伏尸百万，流血漂橹。相比之下，放点儿白金数据都是小儿科的了。网上不就有纪录片和帖子讨论朴槿惠为了邪教献祭牺牲了岁月号三百多名学生的事情吗？想想令人毛骨悚然，但再想想史书不绝于笔的“族”，又为之泰然。<a href="https://www.zhihu.com/question/52059063" target="_blank" rel="noopener">详情</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;考完试后回到家里，闲来无事便读了一个下午读完了这本新出的侦探小说。比较符合我对东野圭吾的预期，小说很有悬念，比较刺激，但文学性和思想性不足，只是消遣性读物。&lt;/p&gt;
&lt;p&gt;后面会涉及严重剧透=======================================&lt;/p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>利用随机森林法预测Titanic乘客生存率</title>
    <link href="http://yyhyplxyz.github.io/2018/01/26/%E5%88%A9%E7%94%A8%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E6%B3%95%E9%A2%84%E6%B5%8BTitanic%E4%B9%98%E5%AE%A2%E7%94%9F%E5%AD%98%E7%8E%87/"/>
    <id>http://yyhyplxyz.github.io/2018/01/26/利用随机森林法预测Titanic乘客生存率/</id>
    <published>2018-01-26T11:50:06.000Z</published>
    <updated>2018-01-26T13:28:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在kaggle上有一个竞赛题目，是如何根据泰坦尼克号上的已知的乘客数据来预测某一乘客在该轮船上能否存活。<a href="https://www.kaggle.com/c/titanic" target="_blank" rel="noopener">题目</a>本身就是一道供初学者进行数据分析学习的问题，也有很多大佬给出了自己的数据训练的tutorial，自己就在这里分享下自己在借鉴了一些大佬的经验之后给出的自己的解决方案。</p><h2 id="解决流程"><a href="#解决流程" class="headerlink" title="解决流程"></a>解决流程</h2><h3 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h3><p>数据清洗是所有数据分析问题第一步要解决的，我们首先来看下官方对数据集的说明。</p><ul><li>PassengerId: 编号 </li><li>Survived: 0 = 死亡，1 = 生存</li><li>Pclass: 船票级别 1 = 高级， 2 = 中等， 3 = 低等</li><li>Name: 名称</li><li>Sex: male = 男性，female = 女性</li><li>Age: 年龄</li><li>SibSp: 在 Titanic 上的兄弟姐妹以及配偶的人数</li><li>Parch: 在 Titanic 上的父母以及子女的人数</li><li>Ticket: 船票编号</li><li>Fare: 工资</li><li>Cabin: 所在的船舱</li><li>Embarked: 登船的港口 C = Cherbourg, Q = Queenstown, S = Southampton</li></ul><p>接下来我们让我们读取数据并对数据有一个初步的感性认识。</p><p>我们首先来做定性分析，看一下特征类别分布是否平衡。类别平衡指分类样例不同类别的训练样例数目差别不大。当差别很大时，为类别不平衡。当类别不平衡的时候，例如正反比为 9:1，学习器将所有样本判别为正例的正确率都能达到 0.9。这时候，我们就需要使用 “再缩放”、“欠采样”、“过采样”、“阈值移动” 等方法。如下图，我们发现总体而言还是特征分布还是平衡的，活下来的人和死亡人数没有偏差过多。</p><h4 id="删除无必要数据"><a href="#删除无必要数据" class="headerlink" title="删除无必要数据"></a>删除无必要数据</h4><h4 id="空数据处理"><a href="#空数据处理" class="headerlink" title="空数据处理"></a>空数据处理</h4><p>我们来看看有多少空数据</p><p>对空数据我们怎么处理呢，这就要分情况讨论啦。</p><h6 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h6><p>作图 Age ~ Survived。年龄较小的孩子生存的几率大。<img src="http://p35v64prn.bkt.clouddn.com/7.png" alt="git"></p><p>因为年龄是一个连续值，而且他会对预测结果产生影响，同时我们发现不同群体中年龄的分布是不同的。<img src="http://p35v64prn.bkt.clouddn.com/4.png" alt="git"><img src="http://p35v64prn.bkt.clouddn.com/5.png" alt="git"></p><p><img src="http://p35v64prn.bkt.clouddn.com/6.png" alt="git"></p><p>因此我们根据票的等级，在 Titanic 上的兄弟姐妹以及配偶的人数，在 Titanic 上的父母以及子女的人数来将数据分为不同的集合，再用缺失数据所在集合的平均值来进行填充。并判断最后的对 Age ~ Survived 的性质并未产生影响。<img src="http://p35v64prn.bkt.clouddn.com/8.png" alt="git"></p><h5 id="Embarked"><a href="#Embarked" class="headerlink" title="Embarked"></a>Embarked</h5><p>它缺少的数据只有两个，直接用众数填充即可。<img src="http://p35v64prn.bkt.clouddn.com/9.png" alt="git"></p><h5 id="Cabin"><a href="#Cabin" class="headerlink" title="Cabin"></a>Cabin</h5><p>他的数据较为复杂，Cabin 特征值由字母开头，判断船舱按字母分为A，B，C…</p><p>于是我们仅提取字母编号，降低维度。然后使用新的字母‘U’填充缺失数据。我们发现缺失数据的游客主要是三等舱的，并且这部分游客的生存率相对较低。<img src="http://p35v64prn.bkt.clouddn.com/10.png" alt="git"></p><p><img src="http://p35v64prn.bkt.clouddn.com/11.png" alt="git"></p><h4 id="数值化和标准化"><a href="#数值化和标准化" class="headerlink" title="数值化和标准化"></a>数值化和标准化</h4><h5 id="数值化"><a href="#数值化" class="headerlink" title="数值化"></a>数值化</h5><p>Ticket 特征值中的一串数字编号对我们没有意义，忽略。下面代码中，我们用正则表达式过滤掉这串数字，并使用 pandas get_dummies 函数进行数值化（以 Ticket 特征值 作为新的特征，0,1 作为新的特征值）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Ticket=[]</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">r=re.compile(<span class="string">r'\w*'</span>)<span class="comment">#正则表达式，查找所有单词字符[a-z/A-Z/0-9]</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data[<span class="string">'Ticket'</span>]:</span><br><span class="line">    sp=i.split(<span class="string">' '</span>)<span class="comment">#拆分空格前后字符串，返回列表</span></span><br><span class="line">    <span class="keyword">if</span> len(sp)==<span class="number">1</span>:</span><br><span class="line">       Ticket.append(<span class="string">'U'</span>)<span class="comment">#对于只有一串数字的 Ticket，Ticket 增加字符 'U'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">       t=r.findall(sp[<span class="number">0</span>])<span class="comment">#查找所有单词字符，忽略符号，返回列表</span></span><br><span class="line">       Ticket.append(<span class="string">''</span>.join(t))<span class="comment">#将 t 中所有字符串合并</span></span><br><span class="line">data[<span class="string">'Ticket'</span>]=Ticket</span><br><span class="line">data=pd.get_dummies(data,columns=[<span class="string">'Ticket'</span>],prefix=<span class="string">'T'</span>)<span class="comment">#get_dummies：如果DataFrame的某一列中含有k个不同的值，则可以派生出一个k列矩阵或DataFrame（其值全为1和0）</span></span><br></pre></td></tr></table></figure><p>getdummies是处理类别醒数据很好的一种方式，这样我们可以将离散的分类变成具体的0，1特征向量，很大程度的加速了电脑计算的速度和监督学习最后训练得到的准确率。对cabin和embarked同样做此操作。最后得到的特征向量如图</p><p><img src="http://p35v64prn.bkt.clouddn.com/12.png" alt="git"></p><h5 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h5><h6 id="偏态分布"><a href="#偏态分布" class="headerlink" title="偏态分布"></a>偏态分布</h6><p>偏态分布的数据有时不利于模型发现数据中的规律，我们可以使用 Log Transformation 来处理数据，这样可以提高训练的准确度。比如Fare这一特征就存在明显的偏态分布，我们skitlearn提供的函数进行处理，参考 <a href="http://www.statisticshowto.com/probability-and-statistics/skewed-distribution/" target="_blank" rel="noopener">Skewed Distribution and Log Transformation</a></p><p><img src="http://p35v64prn.bkt.clouddn.com/14.png" alt="git"></p><p><img src="http://p35v64prn.bkt.clouddn.com/15.png" alt="git"></p><h6 id="离群点删除"><a href="#离群点删除" class="headerlink" title="离群点删除"></a>离群点删除</h6><p>离群点是显著偏离数据集中其余对象的点。离群点来源于操作失误，数据本身的可变性等。我们这里采用箱线法,检测特征 [‘Age’, ‘Parch’, ‘SibSp’, ‘Fare’]的离群点。参考<a href="http://blog.csdn.net/littlely_ll/article/details/68486537" target="_blank" rel="noopener">离群点和箱线法</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outlier_detect</span><span class="params">(n, df, features)</span>:</span><span class="comment">#定义函数 outlier_detect 探测离群点，输入变量 n, df, features，返回 outlier</span></span><br><span class="line">    outlier_index = []</span><br><span class="line">    <span class="keyword">for</span> feature <span class="keyword">in</span> features:</span><br><span class="line">        Q1 = np.percentile(df[feature], <span class="number">25</span>)<span class="comment">#计算上四分位数（1/4）</span></span><br><span class="line">        Q3 = np.percentile(df[feature], <span class="number">75</span>)<span class="comment">#计算下四分位数（3/4）</span></span><br><span class="line">        IQR = Q3 - Q1</span><br><span class="line">        outlier_span = <span class="number">1.5</span> * IQR</span><br><span class="line">        col = ((data[data[feature] &gt; Q3 + outlier_span]) |</span><br><span class="line">               (data[data[feature] &lt; Q1 - outlier_span])).index</span><br><span class="line">        outlier_index.extend(col)</span><br><span class="line">        print(<span class="string">'%s: %f (Q3+1.5*IQR) , %f (Q1-1.5*QIR) )'</span> %</span><br><span class="line">              (feature, Q3 + outlier_span, Q1 - outlier_span))</span><br><span class="line">    outlier_index = Counter(outlier_index)<span class="comment">#计数</span></span><br><span class="line">    outlier = list(i <span class="keyword">for</span> i, j <span class="keyword">in</span> outlier_index.items() <span class="keyword">if</span> j &gt;= n)</span><br><span class="line">    print(<span class="string">'number of outliers: %d'</span> % len(outlier))</span><br><span class="line">    print(df[[<span class="string">'Age'</span>, <span class="string">'Parch'</span>, <span class="string">'SibSp'</span>, <span class="string">'Fare'</span>]].loc[outlier])</span><br><span class="line">    <span class="keyword">return</span> outlier</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">outlier = outlier_detect(<span class="number">3</span>, data, [<span class="string">'Age'</span>, <span class="string">'Parch'</span>, <span class="string">'SibSp'</span>, <span class="string">'Fare'</span>])<span class="comment">#调用函数 outlier_detect</span></span><br><span class="line">data = data.drop(outlier)</span><br></pre></td></tr></table></figure><p><img src="http://p35v64prn.bkt.clouddn.com/13.png" alt="git"></p><h3 id="模型选择与训练"><a href="#模型选择与训练" class="headerlink" title="模型选择与训练"></a>模型选择与训练</h3><h4 id="模型介绍"><a href="#模型介绍" class="headerlink" title="模型介绍"></a>模型介绍</h4><h6 id="Boosting模型与bagging模型"><a href="#Boosting模型与bagging模型" class="headerlink" title="Boosting模型与bagging模型"></a>Boosting模型与bagging模型</h6><p>Bagging：假设我有一个大小为n的训练集D，bagging会从D中有放回的均匀地抽样，假设我用bagging生成了m个新的训练集Di，每个Di的大小为j。由于我有放回的进行抽样，那么在Di中的样本有可能是重复的。如果j=n，这种取样称为bootstrap取样。现在，我们可以用上面的m个训练集来拟合m个模型，然后结合这些模型进行预测。对于回归问题来说，我们平均这些模型的输出;对于分类问题来说，我们进行投票（voting）。</p><p>Boosting：Boosting与Bagging主要的不同是：Boosting的base分类器是按顺序训练的（in sequence），训练每个base分类器时所使用的训练集是加权重的，而训练集中的每个样本的权重系数取决于前一个base分类器的性能。如果前一个base分类器错误分类地样本点，那么这个样本点在下一个base分类器训练时会有一个更大的权重。一旦训练完所有的base分类器，我们组合所有的分类器给出最终的预测结果。过程如下图：</p><p><img src="http://img.blog.csdn.net/20160523164415904" alt="git"></p><h6 id="Adaboost与RandomForest算法"><a href="#Adaboost与RandomForest算法" class="headerlink" title="Adaboost与RandomForest算法"></a>Adaboost与RandomForest算法</h6><p>Adaboost是一种基于boosting模型的迭代算法，其核心思想是针对同一个训练集训练不同的<a href="http://baike.baidu.com/view/895803.htm" target="_blank" rel="noopener">分类器</a>(弱分类器)，然后把这些弱分类器集合起来，构成一个更强的最终分类器（强分类器）。</p><p>Adaboost的结构:最后的分类器YM是由数个弱分类器（weak classifier）组合而成的,相当于最后m个弱分类器来投票决定分类结果，而且每个弱分类器的“话语权”因子α大小不一样。</p><p>Randomforest是基于bangging模型实现的，他的元分类器是决策树。过程简要概括如下：</p><ol><li>从原始训练集中进行bootstrap抽样</li><li>用步骤1中的bootstrap样本生成决策树<ul><li>随机选择特征子集</li><li>用上面的特征子集来拆分树的节点</li></ul></li><li>重复1和2两个步骤</li><li>集成所有生成的决策树进行预测</li></ol><h4 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h4><p>我们采用k 折交叉验证法，更具体的是10 折交叉验证法。</p><ul><li>k 折交叉验证（k-fold cross validation）：将 D 划分 k 个大小相似的子集（每份子集尽可能保持数据分布的一致性：子集中不同类别的样本数量比例与 D 基本一致），其中一份作为测试集，剩下 k-1 份为训练集 T，操作 k 次。 例如 D 划分为 D1，D2，… ，D10，第一次使用 D1 作为训练集，第二次使用 D2，第三次使用 D3， … ， 第十次使用 D10 作为测试集。最后计算 k 次测试误差的平均值近似泛化误差。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">y = data[<span class="string">'Survived'</span>]</span><br><span class="line">X = data.drop([<span class="string">'Survived'</span>], axis=<span class="number">1</span>).values</span><br><span class="line"></span><br><span class="line">classifiers = [AdaBoostClassifier(</span><br><span class="line">    random_state=<span class="number">2</span>), RandomForestClassifier(random_state=<span class="number">2</span>)]</span><br><span class="line"><span class="keyword">for</span> clf <span class="keyword">in</span> classifiers:</span><br><span class="line">    score = cross_val_score(clf, X, y, cv=<span class="number">10</span>, scoring=<span class="string">'accuracy'</span>)<span class="comment">#cv=10：10 折交叉验证法，scoring='accuracy'：返回测试精度</span></span><br><span class="line">    print([np.mean(score)])<span class="comment">#显示测试精度平均值</span></span><br></pre></td></tr></table></figure><p><img src="http://p35v64prn.bkt.clouddn.com/2018-1-251.png" alt="git"></p><p>我们可以发现随机森林分类器的准确率要高不少。</p><h4 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h4><p>但是随机森林是基于决策树的，决策树一直存在着过拟合的问题。</p><p>过拟合是学习器性能过好，把样本的一些特性当做了数据的一般性质，从而导致训练误差低但泛化误差高。学习曲线是判断过拟合的一种方式，同时可以判断学习器的表现。学习曲线包括训练误差（或精度）随样例数目的变化曲线与测试误差（或精度）随样例数目的变化曲线。</p><p>接下来通过绘制学习曲线，我们发现训练误差始终接近 0，而测试误差始终偏高，说明存在过拟合的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> learning_curve</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_learning_curve</span><span class="params">(estimator, title, X, y, cv=<span class="number">10</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                        train_sizes=np.linspace<span class="params">(<span class="number">.1</span>, <span class="number">1.0</span>, <span class="number">5</span>)</span>)</span>:</span><span class="comment">#定义函数 plot_learning_curve 绘制学习曲线。train_sizes 初始化为 array([ 0.1  ,  0.325,  0.55 ,  0.775,  1.   ]),cv 初始化为 10，以后调用函数时不再输入这两个变量</span></span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.title(title)<span class="comment">#设置图的 title</span></span><br><span class="line">    plt.xlabel(<span class="string">'Training examples'</span>)<span class="comment">#横坐标</span></span><br><span class="line">    plt.ylabel(<span class="string">'Score'</span>)<span class="comment">#纵坐标</span></span><br><span class="line">    train_sizes, train_scores, test_scores = learning_curve(estimator, X, y, cv=cv,</span><br><span class="line">                                                            train_sizes=train_sizes)<span class="comment">#使用 10 折交叉验证法，对 train_sizes*m（m为总的样例数目） 个的数据进行训练，返回训练精度 train_scores,测试精度 test_scores </span></span><br><span class="line">    train_scores_mean = np.mean(train_scores, axis=<span class="number">1</span>)<span class="comment">#计算平均值</span></span><br><span class="line">    train_scores_std = np.std(train_scores, axis=<span class="number">1</span>)<span class="comment">#计算标准差</span></span><br><span class="line">    test_scores_mean = np.mean(test_scores, axis=<span class="number">1</span>)</span><br><span class="line">    test_scores_std = np.std(test_scores, axis=<span class="number">1</span>)</span><br><span class="line">    plt.grid()<span class="comment">#设置背景的网格</span></span><br><span class="line"></span><br><span class="line">    plt.fill_between(train_sizes, train_scores_mean - train_scores_std,</span><br><span class="line">                     train_scores_mean + train_scores_std,</span><br><span class="line">                     alpha=<span class="number">0.1</span>, color=<span class="string">'g'</span>)<span class="comment">#设置颜色</span></span><br><span class="line">    plt.fill_between(train_sizes, test_scores_mean - test_scores_std,</span><br><span class="line">                     test_scores_mean + test_scores_std,</span><br><span class="line">                     alpha=<span class="number">0.1</span>, color=<span class="string">'r'</span>)</span><br><span class="line">    plt.plot(train_sizes, train_scores_mean, <span class="string">'o-'</span>, color=<span class="string">'g'</span>,</span><br><span class="line">             label=<span class="string">'traning score'</span>)<span class="comment">#绘制训练精度曲线</span></span><br><span class="line">    plt.plot(train_sizes, test_scores_mean, <span class="string">'o-'</span>, color=<span class="string">'r'</span>,</span><br><span class="line">             label=<span class="string">'testing score'</span>)<span class="comment">#绘制测试精度曲线</span></span><br><span class="line">    plt.legend(loc=<span class="string">'best'</span>)</span><br><span class="line">    <span class="keyword">return</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = plot_learning_curve(RandomForestClassifier(), <span class="string">'RFC'</span>, X, y)<span class="comment">#调用函数 plot_learning_curve 绘制随机森林学习器学习曲线</span></span><br></pre></td></tr></table></figure><p><img src="http://p35v64prn.bkt.clouddn.com/2018-1-25.png" alt="git"></p><p>要解决这一问题只能通过调参。</p><p>skitlearn中的randomforestclassifer函数具有非常多的参数，列举几个如下。</p><table><thead><tr><th>参数</th><th></th><th>特点</th></tr></thead><tbody><tr><td>n_estimators</td><td>基学习器数目（默认值10）</td><td>基本趋势是值越大精度越高 ，直到达到一个上限</td></tr><tr><td>criterion</td><td>选择算法 gini 或者 entropy (默认 gini)</td><td>视具体情况定</td></tr><tr><td>max_features</td><td>2.2.3节中子集的大小，即k值（默认 sqrt(n_features)）</td><td></td></tr><tr><td>max_depth</td><td>决策树深度</td><td>过小基学习器欠拟合，过大基学习器过拟合。粗调节</td></tr><tr><td>max_leaf_nodes</td><td>最大叶节点数（默认无限制）</td><td>粗调节</td></tr><tr><td>min_samples_split</td><td>分裂时最小样本数，默认2</td><td>细调节,越小模型越复杂</td></tr><tr><td>min_samples_leaf</td><td>叶节点最小样本数，默认2</td><td>细调节，越小模型越复杂</td></tr><tr><td>bootstrap</td><td>是否采用自助法进行样本抽样（默认使用）</td><td>决定基学习器样本是否一致</td></tr></tbody></table><p>我们先通过尝试找到最好的n_estimators和max_depth，max_leaf_nodes  参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">para_tune</span><span class="params">(para, X, y)</span>:</span> <span class="comment">#</span></span><br><span class="line">    clf = RandomForestClassifier(n_estimators=para) <span class="comment">#n_estimators 设置为 para</span></span><br><span class="line">    score = np.mean(cross_val_score(clf, X, y, scoring=<span class="string">'accuracy'</span>))</span><br><span class="line">    <span class="keyword">return</span> score</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accurate_curve</span><span class="params">(para_range, X, y, title)</span>:</span></span><br><span class="line">    score = []</span><br><span class="line">    <span class="keyword">for</span> para <span class="keyword">in</span> para_range:</span><br><span class="line">        score.append(para_tune(para, X, y))</span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.title(title)</span><br><span class="line">    plt.xlabel(<span class="string">'Paramters'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'Score'</span>)</span><br><span class="line">    plt.grid()</span><br><span class="line">    plt.plot(para_range, score, <span class="string">'o-'</span>)</span><br><span class="line">    <span class="keyword">return</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = accurate_curve([<span class="number">2</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">150</span>], X, y, <span class="string">'n_estimator tuning'</span>)</span><br></pre></td></tr></table></figure><p>与上面代码类似的我们可以得到下面三张图</p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-1-253.png" alt="git"></p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-1-254.png" alt="git"></p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-1-255.png" alt="git"></p><p>接着我们就可以固定这三个影响较大的参数，再利用自动调参函数GridSearchCV来对其他的参数进行粗略的调节。<img src="http://p35v64prn.bkt.clouddn.com/2018-1-257.png" alt="git"></p><p>如此我们得到了最终0.8204的准确率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;在kaggle上有一个竞赛题目，是如何根据泰坦尼克号上的已知的乘客数据来预测某一乘客在该轮船上能否存活。&lt;a href=&quot;h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python作图</title>
    <link href="http://yyhyplxyz.github.io/2018/01/25/python%E4%BD%9C%E5%9B%BE/"/>
    <id>http://yyhyplxyz.github.io/2018/01/25/python作图/</id>
    <published>2018-01-25T03:11:19.000Z</published>
    <updated>2018-01-26T16:29:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><p>作图工具如恒河沙数，最好用的就是excel的图表功能，还有powermap这样强大的插件，可以非常轻松的解决工作制作报表的问题。但是excel的图表自定义功能并不够强大，在工程和数据科学领域，excle也捉襟见肘。相比之下matlab，mathmeticas这样的商业软件就非常优秀了，然而我偏不它们。我接下来要讲的是python中的Matplotlib和seaborn这样的函数库。</p><h2 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h2><p>在 Matplotlib 中，大部分图形样式的绘制方法都存在于 pyplot 模块中，一共有160多种图表绘制方法。</p><h3 id="2D图绘制"><a href="#2D图绘制" class="headerlink" title="2D图绘制"></a>2D图绘制</h3><p>我们首先用接下来的代码来引用科学计算函数库numpy和图形绘制库matplotlib</p><p>用npm可以很简单地安装好啦，我就不多说了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><p>然后我们来用下面的代码生成数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = np.linspace(<span class="number">-2</span>*np.pi,<span class="number">2</span>*np.pi,<span class="number">1000</span>) <span class="comment">#在-2*np.pi和2*np.pi之间等间隔的生成1000个数据点，X就是一个np 数组</span></span><br><span class="line">Y = np.sin(X)<span class="comment">#Y也是一个数组，对应了X的sin值</span></span><br></pre></td></tr></table></figure><p>接着我们键入一下代码，分别生成线型图，柱形图和散点图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.pyplot.plot(X,Y)</span><br><span class="line">plt.pyplot.bar(X,Y)</span><br><span class="line">plt.pyplot.scatter(X,Y)</span><br></pre></td></tr></table></figure><p>输出如下</p><p>再接着我们可以尝试着画饼状图，量场图和等高线图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">z = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">plt.pyplot.pie(z)<span class="comment">#饼被分成三块，每块的相对面积大小是1，2，3</span></span><br><span class="line">X, y = np.mgrid[<span class="number">0</span>:<span class="number">10</span>, <span class="number">0</span>:<span class="number">10</span>]<span class="comment">#表示的是一个矩阵</span></span><br><span class="line">plt.pyplot.quiver(X, y)</span><br></pre></td></tr></table></figure><p>图形输出如下</p><p>这样子的功能其实excel也可以实现，还比python要简单，下面是体现python强大的图形自定义功能的时刻到啦</p><h4 id="线型图"><a href="#线型图" class="headerlink" title="线型图"></a>线型图</h4><p>线型图通过 matplotlib.pyplot.plot(<em>args, *</em>kwargs) 方法绘出。其中，args 代表数据输入，而 kwargs 的部分就是用于设置样式参数了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">X = np.linspace(<span class="number">-2</span> * np.pi, <span class="number">2</span> * np.pi, <span class="number">1000</span>)</span><br><span class="line"><span class="comment"># 计算 sin() 对应的纵坐标</span></span><br><span class="line">y1 = np.sin(X)</span><br><span class="line"><span class="comment"># 计算 cos() 对应的纵坐标</span></span><br><span class="line">y2 = np.cos(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向方法中 `*args` 输入 X，y 坐标</span></span><br><span class="line">plt.pyplot.plot(X, y1, color=<span class="string">'r'</span>, linestyle=<span class="string">'--'</span>, linewidth=<span class="number">2</span>, alpha=<span class="number">0.8</span>)</span><br><span class="line">plt.pyplot.plot(X, y2, color=<span class="string">'b'</span>, linestyle=<span class="string">'-'</span>, linewidth=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>我们就能见到这样漂亮的图拉</p><p>样式参数有很多，具体的可以见下表，更具体的麻烦查阅下官方文档</p><p><img src="../image/yangshi2.png" alt="git"></p><p><img src="../image/yangshi3.png" alt="git"></p><p><img src="../image/yangshi4.png" alt="git"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;导论&quot;&gt;&lt;a href=&quot;#导论&quot; class=&quot;headerlink&quot; title=&quot;导论&quot;&gt;&lt;/a&gt;导论&lt;/h2&gt;&lt;p&gt;作图工具如恒河沙数，最好用的就是excel的图表功能，还有powermap这样强大的插件，可以非常轻松的解决工作制作报表的问题。但是exce
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo + Github Pages博客创建历程</title>
    <link href="http://yyhyplxyz.github.io/2018/01/24/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E5%8E%86%E7%A8%8B/"/>
    <id>http://yyhyplxyz.github.io/2018/01/24/我的博客创建历程/</id>
    <published>2018-01-23T16:32:23.000Z</published>
    <updated>2018-01-24T15:51:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对程序员来说，纸上得来终觉浅，绝知此事要躬行，每分专业的能力绝不是看书看来的，听课听来的，而一定要是自己一行一行代码敲来的。不仅如此，每个不甘寂寞的程序猿（媛），还会有着创建一个博客，发布自己所见所感所学的想法或习惯。为了更好地促进自己的进步，我也来加入写博客的大军啦。</p><h2 id="怎样的博客"><a href="#怎样的博客" class="headerlink" title="怎样的博客"></a>怎样的博客</h2><p>应该以什么样的方式来创建博客是本节的重点。</p><p>在大一时，为了应付一门课的作业自己开通了cdsn的博客，有很多大牛的博客就扎根在了cdsn。但是对我而言，cdsn总有着烦人的广告，下载资料的时候还总要花钱充值，让我觉得很不爽，所以pass了这个选择。</p><p>还有很多人会选择简书，可那里是文艺青年的聚集地，程序员特有的geek氛围要远远差于cdsn。</p><p>至于知乎专栏和微信公众号，虽然也可以当作自己写随笔发布的园地，但与博客相比，总觉得差了点什么。</p><p>除此之外，还有wordpress和wix等建站方式，其实很方便的，可见即可得的操作，免费版的也不用花钱。主要原因还是自己嫌弃它们一点也不geek，就没有使用这种方式啦。说真的wix创建出来的网站可好看啦，而且官方的引导特别详尽，就像游戏里的引导操作一样，自己很容易就能建成一个很漂亮的网站，我当时</p><p>于是就开始考虑起自己搭建一个博客网站。自己之前尝试过用python的django框架搭建过博客网站，它自带有功能很强大的后台，当初自己实现的最终版也差强人意。一个完全由自己掌控的网站是能让人很有成就感的。可想了想自己还是没有选择这个自己实现的网站来作为自己的博客，因为除了后台功能外，自己所有都要手打代码，评论，搜索乃至前台的页面，出了bug要自己调试，万一调试不出来，博客就挂掉了。。。。</p><p>那么就考虑到了使用hexo框架来搭建博客，它并不是真正意义上代码的框架，使用它基本不需要编写代码，简介，美观，好用而功能强大。而且它与github pages可以无间合作，还可以省去了购买云主机，云服务器的花销。</p><h2 id="创建博客的准备"><a href="#创建博客的准备" class="headerlink" title="创建博客的准备"></a>创建博客的准备</h2><p>我们首先需要在电脑上安装好<a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js</a> , <a href="https://git-scm.com/" target="_blank" rel="noopener">git</a>和一些下载包管理工具如npm，homebrew（    mac自带），apt-get（Ubuntu自带），yum（centos自带）。</p><p>接着进入<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo官网</a>，按照上面的步骤安装hexo。（此处非常有必要阅读一下hexo官方对自己的介绍）</p><p>我们此时已经安装好了hexo，可以输入以下命令检查是否安装成功，windows用户可能需要再配置一下环境变量，</p><p>接着我们输入</p><p><br><br>hexo init <code>yourname</code><br>cd <code>yourname</code><br>npm install<br><br></p><p>这样就可以创建自己的博客文件夹，里面有网站的各个静态文件，自己以后的文章也会放在这个文件夹里，进入这个文件夹后，用npm命令来安装各项依赖。</p><p>此时我们用</p><p>hexo new “文章标题”</p>就可以新建一个文章，我们进入source文件夹内的_posts文件夹，就会发现多出了一篇md后缀的文件，这就是我们刚刚创建的文章啦，我们也可以直接在里面创建markdowm文件。接着我们用<p>hexo s</p>命令就能在本地运行这个简单的博客网站了。<p></p><p>然后在<a href="https://github.com/" target="_blank" rel="noopener">github</a>新建一个代码仓库，仓库的名字一定要是”yourusername.github.io”。如我github账户名是yyhyplxyz，我这个代码仓库名字就是“yyhyplxyz.github.io”。</p><p>接着去github上添加ssh key，可以参考此网址<a href="https://www.cnblogs.com/ayseeing/p/3572582.html" target="_blank" rel="noopener">ssh</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;对程序员来说，纸上得来终觉浅，绝知此事要躬行，每分专业的能力绝不是看书看来的，听课听来的，而一定要是自己一行一行代码敲来的。不仅如此，每个不
      
    
    </summary>
    
    
      <category term="coding" scheme="http://yyhyplxyz.github.io/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>文章标题</title>
    <link href="http://yyhyplxyz.github.io/2018/01/23/%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98/"/>
    <id>http://yyhyplxyz.github.io/2018/01/23/文章标题/</id>
    <published>2018-01-23T04:33:39.000Z</published>
    <updated>2018-01-23T04:37:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一个文章"><a href="#第一个文章" class="headerlink" title="第一个文章"></a>第一个文章</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一个文章&quot;&gt;&lt;a href=&quot;#第一个文章&quot; class=&quot;headerlink&quot; title=&quot;第一个文章&quot;&gt;&lt;/a&gt;第一个文章&lt;/h2&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
