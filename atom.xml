<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>元昊的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yyhyplxyz.github.io/"/>
  <updated>2019-06-30T11:44:48.148Z</updated>
  <id>http://yyhyplxyz.github.io/</id>
  
  <author>
    <name>Jack Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>个人报告</title>
    <link href="http://yyhyplxyz.github.io/2019/06/30/%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A/"/>
    <id>http://yyhyplxyz.github.io/2019/06/30/个人报告/</id>
    <published>2019-06-30T11:38:33.000Z</published>
    <updated>2019-06-30T11:44:48.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="个人简单小结"><a href="#个人简单小结" class="headerlink" title="个人简单小结"></a>个人简单小结</h1><p><strong>简短的课程学习自我总结</strong></p><p>   本次项目我们完成工作的时间是Mar 31, 2019 – Jun 30, 2019。其中自己的角色是后端小组长，参与的是后台搭建工作，包括api实现与管理系统实现。通过这次课程设计的编写，自己更好地掌握了flask相关技术原理，对应用容器化和网络服务框架的原理有了更深的理解，相关技术博文在本文底部附上。下面我将简单介绍本人项目完成的内容。</p><p><strong>管理</strong></p><p>- 讨论小组分工，及早确定后端成员的名单，同时通过讨论确定项目架构。</p><p>- 调整后端开发的节奏，保持开发进度能够稳步推进。</p><p>- 与产品经理和前端小组积极沟通，保证后端开发能够符合前端的需求。</p><p><strong>分析</strong></p><p>- 参与分析需求，以及实现需求所需要的后端API</p><p>- 参与讨论后端API的设计</p><p>- 设计管理员页面架构</p><p><strong>开发</strong></p><p>- 负责后端整体技术框架的搭建，实现前后端分离，使用了MVC架构</p><p>- 负责后端数据库的开发</p><p>- 负责后端部分模块（管理员菜品管理，管理员首页）的实现</p><p>- 参与后端API的开发</p><p>- 负责后端API的调试，保证后端API的鲁棒性</p><p>- 项目后期参与前端调试工作，保证前端页面的完整性美观性。</p><p><strong>PSP2.1表格</strong></p><p>|                  | Personal Software Process Stages | Time(%) |</p><p>| —————- | ——————————– | ——- |</p><p>| <strong><em>\</em>Planning**</strong>     | <strong><em>\</em>计划**</strong>                         | 10      |</p><p>| estimate         | 预估任务完成时间                 | 10      |</p><p>| <strong><em>\</em>Development**</strong>  | <strong><em>\</em>开发**</strong>                         | 70      |</p><p>| analysis         | 需求分析                         | 5       |</p><p>| learning         | 学习需要用到的技术               | 13      |</p><p>| design           | 设计系统                         | 7       |</p><p>| coding           | 编码                             | 30      |</p><p>| debug            | 测试修改                         | 10      |</p><p>| coding standard  | 调整代码规范                     | 5       |</p><p>| <strong><em>\</em>Documents**</strong>    | <strong><em>\</em>文档**</strong>                         | 20      |</p><p>| administrate     | 管理文档目录                     | 6       |</p><p>| database design  | 数据库设计文档                   | 9       |</p><p>| size measurement | 计算工作量                       | 2       |</p><p>| personal report  | 自我总结与个人报告               | 3       |</p><p><strong>个人Git总结</strong></p><p><strong> 项目主目录</strong></p><p><img src="https://raw.githubusercontent.com/yyhyplxyz/SYSU-xiaoxin-catering/master/document_files/1.PNG" alt=""></p><p><strong>最得意/或有价值/或有苦劳的工作清单</strong></p><ul><li><p>最得意：最得意的就是利用python装饰器模式实现了自定义的蓝图和数据库的自动回滚，感觉这样写代码很简介优雅。</p></li><li><p>最有价值：对web框架的原理有了更深的理解，包括wsgi，跨域访问，linux系统网络层链路层的多个参数，nginx的负载均很原理等。</p></li><li><p>最有苦劳：后端管理系统功能非常完善，而且不像Django一样有自带的管理系统，我们的感觉很厉害！</p></li></ul><p><strong>技术博客清单</strong></p><ul><li><p><a href="http://yangyuanhao.com/2019/06/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E8%A7%86%E5%9B%BE/" target="_blank" rel="noopener">数据库中的视图</a></p></li><li><p><a href="http://yangyuanhao.com/2019/06/30/Python%E4%B8%AD%E7%9A%84%E4%BF%AE%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">Python中的修饰器模式</a></p></li><li><p><a href="http://yangyuanhao.com/2019/06/30/%E5%BA%94%E7%94%A8%E5%AE%B9%E5%99%A8%E5%8C%96%E5%90%8E%E9%80%A0%E6%88%90%E7%9A%84%E4%B8%A2%E5%8C%85%E7%8E%B0%E8%B1%A1%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">应用容器化后造成的丢包现象与解决方案</a></p></li><li><p><a href="http://yangyuanhao.com/2019/06/30/DDoS-%E6%94%BB%E5%87%BB%E7%9A%84%E6%A8%A1%E6%8B%9F%E4%BB%BF%E7%9C%9F%E4%B8%8E%E9%98%B2%E5%BE%A1/" target="_blank" rel="noopener">DDoS 攻击的模拟仿真与防御</a></p></li><li><p><a href="http://yangyuanhao.com/2019/06/30/%E7%B3%BB%E5%88%86%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/" target="_blank" rel="noopener">flask技术报告</a></p></li></ul><p><strong>特别致谢</strong></p><p>- 项目经理 lordrou：感谢 lordrou帮助我们整理每周的组会记录和周报内容，让我们每一周都有明确的任务与目标，也为我们做出了很好的UI图和设计文档。</p><p>- 后台 LeonhardE：感谢LeonhardE，与他在后端的合作很愉快，让我收获了很多。</p><p>- 小队队长 johnsonLeeeee：感谢 johnsonLeeeee 对于小队的组建，他也认真的完成了前端的工作任务。</p><p>- 前端 Zhuyuze：感谢 Zhuyuze为我们的项目。设计了一个很漂亮的界面</p><p>- 测试 zxydashagou：感谢 zxydashagou 的测试工作与配合。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;个人简单小结&quot;&gt;&lt;a href=&quot;#个人简单小结&quot; class=&quot;headerlink&quot; title=&quot;个人简单小结&quot;&gt;&lt;/a&gt;个人简单小结&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;简短的课程学习自我总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   本次项目我们完成工作的时间是M
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>系分技术报告</title>
    <link href="http://yyhyplxyz.github.io/2019/06/30/%E7%B3%BB%E5%88%86%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/"/>
    <id>http://yyhyplxyz.github.io/2019/06/30/系分技术报告/</id>
    <published>2019-06-30T04:50:19.000Z</published>
    <updated>2019-06-30T04:50:57.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="技术报告"><a href="#技术报告" class="headerlink" title="技术报告"></a>技术报告</h1><p>16340274 杨元昊</p><p>​    本次我们小组使用flask框架来完成作业后端，flask是python最常用的框架之一，它具有小巧灵活，定制度高的特点。</p><p>​    从业务逻辑上而言，这个程序并不复杂，缺少的是细心和耐心。值得一提的是本次作业我更灵活的使用了python异步编程和装饰器的相关知识。同时对flask的相关原理有了更清晰的认识。</p><p>​    在发送邮件的相关模块中，我通过开启多个线程进行邮件发送的操作，避免了IO阻塞。</p><p>​    在蓝图注册的过程中，我利用装饰器的知识新建了属于自己的蓝图，用以区分v1，v2版本的api，更好地实现了可扩展性。同时，我也用装饰器保证了数据库提交发生错误的时候发生回滚。我写了相关博客，可以<a href="http://yangyuanhao.com/2019/06/30/Python%E4%B8%AD%E7%9A%84%E4%BF%AE%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">参阅</a></p><p>​    以下将简单阐述下使用flask的心得体会。</p><h2 id="应用上下文与请求上下文"><a href="#应用上下文与请求上下文" class="headerlink" title="应用上下文与请求上下文"></a>应用上下文与请求上下文</h2><p>Flask提供了两种上下文，一种是应用上下文(Application Context)，一种是请求上下文(Request Context)。<br> 可以查看Flask的文档：<a href="https://link.jianshu.com?t=http://flask.pocoo.org/docs/0.11/appcontext/" target="_blank" rel="noopener">应用上下文</a>   <a href="https://link.jianshu.com?t=http://flask.pocoo.org/docs/0.11/reqcontext/" target="_blank" rel="noopener">请求上下文</a></p><p>通俗地解释一下<strong>application context</strong>与<strong>request context</strong>：</p><blockquote><ol><li><em>application</em> 指的就是当你调用app = Flask(<strong>name</strong>)创建的这个对象app；</li></ol></blockquote><ol><li><em>request</em> 指的是每次http请求发生时，WSGI server(比如gunicorn)调Flask.<strong>call</strong>()之后，在Flask对象内部创建的Request对象；</li><li><em>application</em> 表示用于响应WSGI请求的应用本身，<em>request</em> 表示每次http请求;</li><li><em>application</em>的生命周期大于<em>request</em>，一个<em>application</em>存活期间，可能发生多次http请求，所以，也就会有多个<em>request</em></li></ol><p>为了在一个线程中更加方便使用这些变量，flask中还有一种堆栈的数据结构（通过werkzeug的LocalStack实现），可以处理这些变量，但是并不直接处理这些变量。假如有一个程序得到一个请求，那么flask会将这个请求的所有相关信息进行打包，打包形成的东西就是处理请求的一个环境。flask将这种环境称为“请求上下文”(request context)，之后flask会将这个请求上下文对象放到堆栈中。这样，请求发生时，我们一般都会指向堆栈中的“请求上下文”对象，这样可以通过请求上下文获取相关对象并直接访问，例如current_app、request、session、g。还可以通过调用对象的方法或者属性获取其他信息，例如request.method。等请求结束后，请求上下文会被销毁，堆栈重新等待新的请求上下文对象被放入。</p><p>当在一个应用的请求上下文环境中，需要嵌套处理另一个应用的相关操作时（这种情况更多的是用于测试或者在console中对多个应用进行相关处理），“请求上下文”显然就不能很好地解决问题了，Flask中将应用相关的信息单独拿出来，形成一个“应用上下文”对象。这个对象可以和“请求上下文”一起使用，也可以单独拿出来使用。不过有一点需要注意的是：在创建“请求上下文”时一定要创建一个“应用上下文”对象。比如app = Flask(<strong>name</strong>)构造出一个 Flask App 时，App Context 并不会被自动推入 Stack 中。所以此时 Local Stack 的栈顶是空的，current_app也是 unbound 状态，在编写离线脚本的时候，如果直接在一个 Flask-SQLAlchemy 写成的 Model 上调用 User.query.get(user_id)，就会遇到 RuntimeError。因为此时 App Context 还没被推入栈中，而 Flask-SQLAlchemy 需要数据库连接信息时就会去取 current_app.config，current_app 指向的却是 _app_ctx_stack为空的栈顶。</p><p>因此运行脚本正文之前，先将 App 的 App Context 推入栈中，栈顶不为空后 current_app这个 Local Proxy 对象就自然能将“取 config 属性” 的动作转发到当前 App 上。</p><h2 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h2><p>Python有着许多的Web框架，而同时又有着许多的Web 服务器（除了Nginx以外，还有Apache等），Web框架和Web服务器之间需要进行通信，如果在设计时它们之间不可以相互匹配的，那么选择了一个框架就会限制对Web服务器的选择，这显然是不合理的。</p><p>怎样确保可以在不修改Web服务器代码或Web框架代码的前提下，使用自己选择的服务器，并且匹配多个不同的网络框架呢？答案是接口，设计一套双方都遵守的接口就可以了。对Python来说，就是<strong>WSGI</strong>（Web Server Gateway Interface，Web服务器网关接口）。其他编程语言也拥有类似的接口：例如Java的Servlet API和Ruby的Rack。</p><p>Python WSGI的出现，让开发者可以将Web框架与Web服务器的选择分隔开来，不再相互限制。现在，你可以真正地将不同的Web服务器与Web框架进行混合搭配，选择满足自己需求的组合。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;技术报告&quot;&gt;&lt;a href=&quot;#技术报告&quot; class=&quot;headerlink&quot; title=&quot;技术报告&quot;&gt;&lt;/a&gt;技术报告&lt;/h1&gt;&lt;p&gt;16340274 杨元昊&lt;/p&gt;
&lt;p&gt;​    本次我们小组使用flask框架来完成作业后端，flask是python最常
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DDoS 攻击的模拟仿真与防御</title>
    <link href="http://yyhyplxyz.github.io/2019/06/30/DDoS-%E6%94%BB%E5%87%BB%E7%9A%84%E6%A8%A1%E6%8B%9F%E4%BB%BF%E7%9C%9F%E4%B8%8E%E9%98%B2%E5%BE%A1/"/>
    <id>http://yyhyplxyz.github.io/2019/06/30/DDoS-攻击的模拟仿真与防御/</id>
    <published>2019-06-30T04:17:24.000Z</published>
    <updated>2019-06-30T04:18:08.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DDoS-简介"><a href="#DDoS-简介" class="headerlink" title="DDoS 简介"></a>DDoS 简介</h2><p>DDoS 的前身是 DoS（Denail of Service），即拒绝服务攻击，指利用大量的合理请求，来占用过多的目标资源，从而使目标服务无法响应正常请求。</p><p>DDoS（Distributed Denial of Service） 则是在 DoS 的基础上，采用了分布式架构，利用多台主机同时攻击目标主机。这样，即使目标服务部署了网络防御设备，面对大量网络请求时，还是无力应对。</p><p>比如，目前已知的最大流量攻击，正是去年 Github 遭受的 <a href="https://githubengineering.com/ddos-incident-report/" target="_blank" rel="noopener">DDoS 攻击</a>，其峰值流量已经达到了 1.35Tbps，PPS 更是超过了 1.2 亿（126.9 million）。</p><p>从攻击的原理上来看，DDoS 可以分为下面几种类型。</p><p>第一种，耗尽带宽。无论是服务器还是路由器、交换机等网络设备，带宽都有固定的上限。带宽耗尽后，就会发生网络拥堵，从而无法传输其他正常的网络报文。</p><p>第二种，耗尽操作系统的资源。网络服务的正常运行，都需要一定的系统资源，像是CPU、内存等物理资源，以及连接表等软件资源。一旦资源耗尽，系统就不能处理其他正常的网络连接。</p><p>第三种，消耗应用程序的运行资源。应用程序的运行，通常还需要跟其他的资源或系统交互。如果应用程序一直忙于处理无效请求，也会导致正常请求的处理变慢，甚至得不到响应。</p><p>比如，构造大量不同的域名来攻击 DNS 服务器，就会导致 DNS 服务器不停执行迭代查询，并更新缓存。这会极大地消耗 DNS 服务器的资源，使 DNS 的响应变慢。</p><p>无论是哪一种类型的 DDoS，危害都是巨大的。那么，如何可以发现系统遭受了 DDoS 攻击，又该如何应对这种攻击呢？接下来，我们就通过一个案例，一起来看看这些问题。</p><h2 id="模拟操作"><a href="#模拟操作" class="headerlink" title="模拟操作"></a>模拟操作</h2><p>我们使用hping3 来构造 TCP/IP 协议数据包，对系统进行安全审计、防火墙测试、DoS 攻击测试等。</p><p>我们用一个虚拟机/容器运行 Nginx ，用来模拟待分析的 Web 服务器；而另外两台作为 Web 服务器的客户端，其中一台用作 DoS 攻击，而另一台则是正常的客户端。使用多台虚拟机的目的，自然还是为了相互隔离，避免“交叉感染”。</p><blockquote><p>由于案例只使用了一台机器作为攻击源，所以这里的攻击，实际上还是传统的 DoS ，而非 DDoS。</p></blockquote><p>首先，在终端一中，执行下面的命令运行案例，也就是启动一个最基本的 Nginx 应用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 运行Nginx服务并对外开放80端口</span><br><span class="line"># --network=host表示使用主机网络（这是为了方便后面排查问题）</span><br><span class="line">$ docker run -itd --name=nginx --network=host nginx</span><br></pre></td></tr></table></figure><p>然后，在终端二和终端三中，使用 curl 访问 Nginx 监听的端口，确认 Nginx 正常启动。假设 192.168.0.30 是 Nginx 所在虚拟机的 IP 地址，那么运行 curl 命令后，你应该会看到下面这个输出界面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># -w表示只输出HTTP状态码及总时间，-o表示将响应重定向到/dev/null</span><br><span class="line">$ curl -s -w &apos;Http code: %&#123;http_code&#125;\nTotal time:%&#123;time_total&#125;s\n&apos; -o /dev/null http://192.168.0.30/</span><br><span class="line">...</span><br><span class="line">Http code: 200</span><br><span class="line">Total time:0.002s</span><br></pre></td></tr></table></figure><p>从这里可以看到，正常情况下，我们访问 Nginx 只需要 2ms（0.002s）。</p><p>接着，在终端二中，运行 hping3 命令，来模拟 DoS 攻击：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># -S参数表示设置TCP协议的SYN（同步序列号），-p表示目的端口为80</span><br><span class="line"># -i u10表示每隔10微秒发送一个网络帧</span><br><span class="line">$ hping3 -S -p 80 -i u10 192.168.0.30</span><br></pre></td></tr></table></figure><p>现在，再回到终端一，我们就会发现，现在不管执行什么命令，都慢了很多。甚至于我们还会发现终端会 变得完全没有响应，乃至ssh断开。此时我们需要适当调大 u10（比如调成 u30），否则后面就不能通过 SSH 操作 。</p><p>然后，到终端三中，执行下面的命令，模拟正常客户端的连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># --connect-timeout表示连接超时时间</span><br><span class="line">$ curl -w &apos;Http code: %&#123;http_code&#125;\nTotal time:%&#123;time_total&#125;s\n&apos; -o /dev/null --connect-timeout 10 http://192.168.0.30</span><br><span class="line">...</span><br><span class="line">Http code: 000</span><br><span class="line">Total time:10.001s</span><br><span class="line">curl: (28) Connection timed out after 10000 milliseconds</span><br></pre></td></tr></table></figure><p>你可以发现，在终端三中，正常客户端的连接超时了，并没有收到 Nginx 服务的响应。</p><p>这是发生了什么问题呢？我们再回到终端一中，检查网络状况。你应该还记得我们多次用过的 sar，它既可以观察 PPS（每秒收发的报文数），还可以观察 BPS（每秒收发的字节数）。</p><p>我们可以回到终端一中，执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sar -n DEV 1</span><br><span class="line">08:55:49        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil</span><br><span class="line">08:55:50      docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">08:55:50         eth0  22274.00    629.00   1174.64     37.78      0.00      0.00      0.00      0.02</span><br><span class="line">08:55:50           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br></pre></td></tr></table></figure><p>其中，</p><ol><li>rxpck/s 和 txpck/s 分别是接收和发送的 PPS， 单位为包/秒。</li><li>rxkB/s 和 txkB/s 分别是接收和发送的吞吐量， 单位是KB/秒。</li><li>rxcmp/s 和 txcmp/s 分别是接收和发送的压缩数据包数， 单位是包/秒。</li><li>%ifutil 是网络接口的使用率， 即半双工模式下为 (rxkB/s+txkB/s)/Bandwidth， 而全双工模式下<br>为 max(rxkB/s, txkB/s)/Bandwidth。 </li></ol><p>从这次 sar 的输出中，你可以看到，网络接收的 PPS 已经达到了 20000 多，但是 BPS 却只有 1174 kB，这样每个包的大小就只有 54B（1174*1024/22274=54）。</p><p>这明显就是个小包了，不过具体是个什么样的包呢？那我们就用 tcpdump 抓包看看吧。</p><p>在终端一中，执行下面的 tcpdump 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># -i eth0 只抓取eth0网卡，-n不解析协议名和主机名</span><br><span class="line"># tcp port 80表示只抓取tcp协议并且端口号为80的网络帧</span><br><span class="line">$ tcpdump -i eth0 -n tcp port 80</span><br><span class="line">09:15:48.287047 IP 192.168.0.2.27095 &gt; 192.168.0.30: Flags [S], seq 1288268370, win 512, length 0</span><br><span class="line">09:15:48.287050 IP 192.168.0.2.27131 &gt; 192.168.0.30: Flags [S], seq 2084255254, win 512, length 0</span><br><span class="line">09:15:48.287052 IP 192.168.0.2.27116 &gt; 192.168.0.30: Flags [S], seq 677393791, win 512, length 0</span><br><span class="line">09:15:48.287055 IP 192.168.0.2.27141 &gt; 192.168.0.30: Flags [S], seq 1276451587, win 512, length 0</span><br><span class="line">09:15:48.287068 IP 192.168.0.2.27154 &gt; 192.168.0.30: Flags [S], seq 1851495339, win 512, length 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这个输出中，Flags [S] 表示这是一个 SYN 包。大量的 SYN 包表明，这是一个 SYN Flood 攻击。如果你用Wireshark 来观察，则可以更直观地看到 SYN Flood 的过程：</p><p><img src="https://ws4.sinaimg.cn//006vdpNxgy1g4izv3x9vdj30t40fyjtv.jpg" alt="f397305c87be6ae43e065d3262ec9113"></p><p>实际上，SYN Flood 正是互联网中最经典的 DDoS 攻击方式。从上面这个图，你也可以看到它的原理：</p><ul><li>即客户端构造大量的 SYN 包，请求建立 TCP 连接；</li><li>而服务器收到包后，会向源 IP 发送 SYN+ACK 报文，并等待三次握手的最后一次ACK报文，直到超时。</li></ul><p>这种等待状态的 TCP 连接，通常也称为半开连接。由于连接表的大小有限，大量的半开连接就会导致连接表迅速占满，从而无法建立新的 TCP 连接。此时，服务器端的 TCP 连接，会处于 SYN_RECEIVED 状态：</p><p><img src="https://upload.wikimedia.org/wikipedia/en/5/57/Tcp_state_diagram.png" alt=""></p><p>这其实提示了我们，查看 TCP 半开连接的方法，关键在于 SYN_RECEIVED 状态的连接。我们可以使用 netstat ，来查看所有连接的状态，不过要注意，SYN_REVEIVED 的状态，通常被缩写为 SYN_RECV。</p><p>我们继续在终端一中，执行下面的 netstat 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># -n表示不解析名字，-p表示显示连接所属进程</span><br><span class="line">$ netstat -n -p | grep SYN_REC</span><br><span class="line">tcp        0      0 192.168.0.30:80          192.168.0.2:12503      SYN_RECV    -</span><br><span class="line">tcp        0      0 192.168.0.30:80          192.168.0.2:13502      SYN_RECV    -</span><br><span class="line">tcp        0      0 192.168.0.30:80          192.168.0.2:15256      SYN_RECV    -</span><br><span class="line">tcp        0      0 192.168.0.30:80          192.168.0.2:18117      SYN_RECV    -</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从结果中，你可以发现大量 SYN_RECV 状态的连接，并且源IP地址为 192.168.0.2。</p><p>进一步，我们还可以通过 wc 工具，来统计所有 SYN_RECV 状态的连接数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -n -p | grep SYN_REC | wc -l</span><br><span class="line">193</span><br></pre></td></tr></table></figure><p>找出源 IP 后，要解决 SYN 攻击的问题，只要丢掉相关的包就可以。这时，iptables 可以帮你完成这个任务。你可以在终端一中，执行下面的 iptables 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -I INPUT -s 192.168.0.2 -p tcp -j REJECT</span><br></pre></td></tr></table></figure><p>然后回到终端三中，再次执行 curl 命令，查看正常用户访问 Nginx 的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -w &apos;Http code: %&#123;http_code&#125;\nTotal time:%&#123;time_total&#125;s\n&apos; -o /dev/null --connect-timeout 10 http://192.168.0.30</span><br><span class="line">Http code: 200</span><br><span class="line">Total time:1.572171s</span><br></pre></td></tr></table></figure><p>现在，你可以发现，正常用户也可以访问 Nginx 了，只是响应比较慢，从原来的 2ms 变成了现在的 1.5s。</p><p>不过，一般来说，SYN Flood 攻击中的源 IP 并不是固定的。比如，你可以在 hping3 命令中，加入 –rand-source 选项，来随机化源 IP。不过，这时，刚才的方法就不适用了。</p><p>幸好，我们还有很多其他方法，实现类似的目标。比如，你可以用以下两种方法，来限制 syn 包的速率：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 限制syn并发数为每秒1次</span><br><span class="line">$ iptables -A INPUT -p tcp --syn -m limit --limit 1/s -j ACCEPT</span><br><span class="line"></span><br><span class="line"># 限制单个IP在60秒新建立的连接数为10</span><br><span class="line">$ iptables -I INPUT -p tcp --dport 80 --syn -m recent --name SYN_FLOOD --update --seconds 60 --hitcount 10 -j REJECT</span><br></pre></td></tr></table></figure><p>到这里，我们已经初步限制了 SYN Flood 攻击。不过这还不够，因为我们的案例还只是单个的攻击源。</p><p>如果是多台机器同时发送 SYN Flood，这种方法可能就直接无效了。因为你很可能无法 SSH 登录（SSH 也是基于 TCP 的）到机器上去，更别提执行上述所有的排查命令。</p><p>所以，这还需要你事先对系统做一些 TCP 优化。</p><p>比如，SYN Flood 会导致 SYN_RECV 状态的连接急剧增大。在上面的 netstat 命令中，你也可以看到 190 多个处于半开状态的连接。</p><p>不过，半开状态的连接数是有限制的，执行下面的命令，你就可以看到，默认的半连接容量只有 256：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl net.ipv4.tcp_max_syn_backlog</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 256</span><br></pre></td></tr></table></figure><p>换句话说， SYN 包数再稍微增大一些，就不能 SSH 登录机器了。 所以，你还应该增大半连接的容量，比如，你可以用下面的命令，将其增大为 1024：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -w net.ipv4.tcp_max_syn_backlog=1024</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 1024</span><br></pre></td></tr></table></figure><p>另外，连接每个 SYN_RECV 时，如果失败的话，内核还会自动重试，并且默认的重试次数是5次。你可以执行下面的命令，将其减小为 1 次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -w net.ipv4.tcp_synack_retries=1</span><br><span class="line">net.ipv4.tcp_synack_retries = 1</span><br></pre></td></tr></table></figure><p>除此之外，TCP SYN Cookies 也是一种专门防御 SYN Flood 攻击的方法。SYN Cookies 基于连接信息（包括源地址、源端口、目的地址、目的端口等）以及一个加密种子（如系统启动时间），计算出一个哈希值（SHA1），这个哈希值称为 cookie。</p><p>然后，这个 cookie 就被用作序列号，来应答 SYN+ACK 包，并释放连接状态。当客户端发送完三次握手的最后一次 ACK 后，服务器就会再次计算这个哈希值，确认是上次返回的 SYN+ACK 的返回包，才会进入 TCP 的连接状态。</p><p>因而，开启 SYN Cookies 后，就不需要维护半开连接状态了，进而也就没有了半连接数的限制。</p><blockquote><p>注意，开启 TCP syncookies 后，内核选项 net.ipv4.tcp_max_syn_backlog 也就无效了。</p></blockquote><p>你可以通过下面的命令，开启 TCP SYN Cookies：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -w net.ipv4.tcp_syncookies=1</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br></pre></td></tr></table></figure><p>注意，上述 sysctl 命令修改的配置都是临时的，重启后这些配置就会丢失。所以，为了保证配置持久化，你还应该把这些配置，写入 /etc/sysctl.conf 文件中。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/sysctl.conf</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_synack_retries = 1</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 1024</span><br></pre></td></tr></table></figure><p>不过要记得，写入 /etc/sysctl.conf 的配置，需要执行 sysctl -p 命令后，才会动态生效。</p><h2 id="DDoS到底该怎么防御"><a href="#DDoS到底该怎么防御" class="headerlink" title="DDoS到底该怎么防御"></a>DDoS到底该怎么防御</h2><p>实际上，当 DDoS 报文到达服务器后，Linux 提供的机制只能缓解，而无法彻底解决。即使像是 SYN Flood 这样的小包攻击，其巨大的 PPS ，也会导致 Linux 内核消耗大量资源，进而导致其他网络报文的处理缓慢。</p><p>虽然你可以调整内核参数，缓解 DDoS 带来的性能问题，却也会像案例这样，无法彻底解决它。首先，因为Linux 内核中冗长的协议栈，在 PPS 很大时，对机器是一个巨大的负担。对 DDoS 攻击来说，也是一样的道理。</p><p>所以，基于 XDP 或者 DPDK，我们可以构建 DDoS 方案，在内核网络协议栈前，或者跳过内核协议栈，来识别并丢弃 DDoS 报文，避免DDoS 对系统其他资源的消耗。</p><p>不过，对于流量型的 DDoS 来说，当服务器的带宽被耗尽后，在服务器内部处理就无能为力了。这时，只能在服务器外部的网络设备中，设法识别并阻断流量（当然前提是网络设备要能扛住流量攻击）。比如，购置专业的入侵检测和防御设备，配置流量清洗设备阻断恶意流量等。</p><p>既然 DDoS 这么难防御，这是不是说明， Linux 服务器内部压根儿就不关注这一点，而是全部交给专业的网络设备来处理呢？</p><p>当然不是，因为 DDoS 并不一定是因为大流量或者大 PPS，有时候，慢速的请求也会带来巨大的性能下降（这种情况称为慢速 DDoS）。</p><p>比如，很多针对应用程序的攻击，都会伪装成正常用户来请求资源。这种情况下，请求流量可能本身并不大，但响应流量却可能很大，并且应用程序内部也很可能要耗费大量资源处理。</p><p>这时，就需要应用程序考虑识别，并尽早拒绝掉这些恶意流量，比如合理利用缓存、增加 WAF（Web Application Firewall）、使用 CDN 等等。</p><p>总而言之，DDoS会对网络安全造成很大的影响，而且极难防御。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DDoS-简介&quot;&gt;&lt;a href=&quot;#DDoS-简介&quot; class=&quot;headerlink&quot; title=&quot;DDoS 简介&quot;&gt;&lt;/a&gt;DDoS 简介&lt;/h2&gt;&lt;p&gt;DDoS 的前身是 DoS（Denail of Service），即拒绝服务攻击，指利用大量的合理请
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python中的修饰器模式</title>
    <link href="http://yyhyplxyz.github.io/2019/06/30/Python%E4%B8%AD%E7%9A%84%E4%BF%AE%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yyhyplxyz.github.io/2019/06/30/Python中的修饰器模式/</id>
    <published>2019-06-30T04:17:11.000Z</published>
    <updated>2019-06-30T04:18:32.542Z</updated>
    
    <content type="html"><![CDATA[<p>所谓的修饰器模式其实是在做下面的几件事。</p><ul><li>表面上看，修饰器模式就是扩展现有的一个函数的功能，让它可以干一些其他的事，或是在现有的函数功能上再附加上一些别的功能。</li><li>修饰器模式可以让我们感受到函数的代码扩展能力，我们还能感受到函数的互相和随意拼装带来的好处。</li><li>但是深入一下，我们不难发现，Decorator这个函数其实是可以修饰几乎所有的函数的。于是，这种可以通用于其它函数的编程方式，可以很容易地将一些非业务功能的、属于控制类型的代码给抽象出来（所谓的控制类型的代码就是像for-loop，或是打日志，或是函数路由，或是求函数运行时间之类的非业务功能性的代码）。</li></ul><p>Python的Decorator在使用上和Java的Annotation（以及C#的Attribute）很相似，就是在方法名前面加一个@XXX注解来为这个方法装饰一些东西。但是，Java/C#的Annotation也很让人望而却步，太过于复杂了。如果要了解它，我们需要先了解一堆Annotation的类库文档，感觉几乎就是在学另外一门语言。</p><p>而Python使用了一种相对于Decorator Pattern和Annotation来说非常优雅的方法，这种方法不需要你去掌握什么复杂的OO模型或是Annotation的各种类库规定，完全就是语言层面的玩法：一种函数式编程的技巧。这个模式动用了函数式编程的一个技术——用一个函数来构造另一个函数。</p><p>好了，我们先来点感性认识，看一个Python修饰器的Hello World代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(fn)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"hello, %s"</span> % fn.__name__</span><br><span class="line">        fn()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"goodbye, %s"</span> % fn.__name__</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"> </span><br><span class="line"><span class="meta">@hello</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Hao</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"i am Hao Chen"</span></span><br><span class="line"> </span><br><span class="line">Hao()</span><br></pre></td></tr></table></figure><p>代码的执行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> python hello.py</span><br><span class="line">hello, Hao</span><br><span class="line">i am Hao Chen</span><br><span class="line">goodbye, Hao</span><br></pre></td></tr></table></figure><p>你可以看到如下的东西：</p><ol><li>函数 <code>Hao</code> 前面有个@hello的“注解”，<code>hello</code> 就是我们前面定义的函数 <code>hello</code>；</li><li>在 <code>hello</code> 函数中，其需要一个 <code>fn</code> 的参数（这就是用来做回调的函数）；</li><li>hello函数中返回了一个inner函数 <code>wrapper</code>，这个 <code>wrapper</code>函数回调了传进来的 <code>fn</code>，并在回调前后加了两条语句。</li></ol><p>对于Python的这个@注解语法糖（syntactic sugar）来说，当你在用某个@decorator来修饰某个函数 <code>func</code> 时，如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>其解释器会解释成下面这样的语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func = decorator(func)</span><br></pre></td></tr></table></figure><p>嘿！这不就是把一个函数当参数传到另一个函数中，然后再回调吗？是的。但是，我们需要注意，那里还有一个赋值语句，把decorator这个函数的返回值赋值回了原来的 <code>func</code>。</p><p>我们再来看一个带参数的玩法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeHtmlTag</span><span class="params">(tag, *args, **kwds)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">real_decorator</span><span class="params">(fn)</span>:</span></span><br><span class="line">        css_class = <span class="string">" class='&#123;0&#125;'"</span>.format(kwds[<span class="string">"css_class"</span>]) \</span><br><span class="line">                                     <span class="keyword">if</span> <span class="string">"css_class"</span> <span class="keyword">in</span> kwds <span class="keyword">else</span> <span class="string">""</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">(*args, **kwds)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&lt;"</span>+tag+css_class+<span class="string">"&gt;"</span> + fn(*args, **kwds) + <span class="string">"&lt;/"</span>+tag+<span class="string">"&gt;"</span></span><br><span class="line">        <span class="keyword">return</span> wrapped</span><br><span class="line">    <span class="keyword">return</span> real_decorator</span><br><span class="line"> </span><br><span class="line"><span class="meta">@makeHtmlTag(tag="b", css_class="bold_css")</span></span><br><span class="line"><span class="meta">@makeHtmlTag(tag="i", css_class="italic_css")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello world"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> hello()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 输出：</span><br><span class="line"># &lt;b class=&apos;bold_css&apos;&gt;&lt;i class=&apos;italic_css&apos;&gt;hello world&lt;/i&gt;&lt;/b&gt;</span><br></pre></td></tr></table></figure><p>在上面这个例子中，我们可以看到：<code>makeHtmlTag</code>有两个参数。所以，为了让 <code>hello = makeHtmlTag(arg1, arg2)(hello)</code> 成功， <code>makeHtmlTag</code> 必需返回一个decorator（这就是为什么我们在 <code>makeHtmlTag</code> 中加入了 <code>real_decorator()</code>）。</p><p>这样一来，我们就可以进入到decorator的逻辑中去了——decorator得返回一个wrapper，wrapper里回调 <code>hello</code>。看似那个 <code>makeHtmlTag()</code> 写得层层叠叠，但是，已经了解了本质的我们觉得写得很自然。</p><p>我们再来看一个为其它函数加缓存的示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memoization</span><span class="params">(fn)</span>:</span></span><br><span class="line">    cache = &#123;&#125;</span><br><span class="line">    miss = object()</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @wraps(fn)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args)</span>:</span></span><br><span class="line">        result = cache.get(args, miss)</span><br><span class="line">        <span class="keyword">if</span> result <span class="keyword">is</span> miss:</span><br><span class="line">            result = fn(*args)</span><br><span class="line">            cache[args] = result</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"> </span><br><span class="line"><span class="meta">@memoization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>上面这个例子中，是一个斐波那契数例的递归算法。我们知道，这个递归是相当没有效率的，因为会重复调用。比如：我们要计算fib(5)，于是其分解成 <code>fib(4) + fib(3)</code>，而 <code>fib(4)</code> 分解成 <code>fib(3) + fib(2)</code>，<code>fib(3)</code> 又分解成<code>fib(2) + fib(1)</code>……你可以看到，基本上来说，<code>fib(3)</code>, <code>fib(2)</code>, <code>fib(1)</code>在整个递归过程中被调用了至少两次。</p><p>而我们用decorator，在调用函数前查询一下缓存，如果没有才调用，有了就从缓存中返回值。一下子，这个递归从二叉树式的递归成了线性的递归。<code>wraps</code> 的作用是保证 <code>fib</code> 的函数名不被 <code>wrapper</code> 所取代。</p><p>除此之外，Python还支持类方式的decorator。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myDecorator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fn)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"inside myDecorator.__init__()"</span></span><br><span class="line">        self.fn = fn</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.fn()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"inside myDecorator.__call__()"</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@myDecorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aFunction</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"inside aFunction()"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> <span class="string">"Finished decorating aFunction()"</span></span><br><span class="line">aFunction()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line"># inside myDecorator.__init__()</span><br><span class="line"># Finished decorating aFunction()</span><br><span class="line"># inside aFunction()</span><br><span class="line"># inside myDecorator.__call__()</span><br></pre></td></tr></table></figure><p>上面这个示例展示了，用类的方式声明一个decorator。我们可以看到这个类中有两个成员：</p><ol><li>一个是<code>__init__()</code>，这个方法是在我们给某个函数decorate时被调用，所以，需要有一个 <code>fn</code> 的参数，也就是被decorate的函数。</li><li>一个是<code>__call__()</code>，这个方法是在我们调用被decorate的函数时被调用的。</li></ol><p>从上面的输出中，可以看到整个程序的执行顺序。这看上去要比“函数式”的方式更易读一些。</p><p>我们来看一个实际点的例子。下面这个示例展示了通过URL的路由来调用相关注册的函数示例，这也是flask路由注册的相关源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.func_map = &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func_wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">            self.func_map[name] = func</span><br><span class="line">            <span class="keyword">return</span> func</span><br><span class="line">        <span class="keyword">return</span> func_wrapper</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call_method</span><span class="params">(self, name=None)</span>:</span></span><br><span class="line">        func = self.func_map.get(name, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">if</span> func <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"No function registered against - "</span> + str(name))</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line"> </span><br><span class="line">app = MyApp()</span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.register('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main_page_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"This is the main page."</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.register('/next_page')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next_page_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"This is the next page."</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> app.call_method(<span class="string">'/'</span>)</span><br><span class="line"><span class="keyword">print</span> app.call_method(<span class="string">'/next_page'</span>)</span><br></pre></td></tr></table></figure><p>注意：上面这个示例中decorator类不是真正的decorator，其中也没有<code>__call__()</code>，并且，wrapper返回了原函数。所以，原函数没有发生任何变化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;所谓的修饰器模式其实是在做下面的几件事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表面上看，修饰器模式就是扩展现有的一个函数的功能，让它可以干一些其他的事，或是在现有的函数功能上再附加上一些别的功能。&lt;/li&gt;
&lt;li&gt;修饰器模式可以让我们感受到函数的代码扩展能力，我们还能感受到函数的互
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>应用容器化后造成的丢包现象与解决方案</title>
    <link href="http://yyhyplxyz.github.io/2019/06/30/%E5%BA%94%E7%94%A8%E5%AE%B9%E5%99%A8%E5%8C%96%E5%90%8E%E9%80%A0%E6%88%90%E7%9A%84%E4%B8%A2%E5%8C%85%E7%8E%B0%E8%B1%A1%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yyhyplxyz.github.io/2019/06/30/应用容器化后造成的丢包现象与解决方案/</id>
    <published>2019-06-30T04:16:58.000Z</published>
    <updated>2019-06-30T04:30:13.244Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><p>​    容器利用 Linux内核提供的命名空间技术， 将不同应用程序的运行隔离起来， 并用统一的镜像，来管理应用程序的依赖环境。 这为应用程序的管理和维护， 带来了极大的便捷性， 并进一步催生了微服务、 云原生等新一代技术架构。虽然容器技术有很多优势， 但容器化也会对应用程序的性能带来一定影响。 笔者在完成项目设计的时候偶然发现将web应用容器化后意外地降低了网站的响应时间。因此本文将就此现象展开分析讨论。</p><h2 id="原因猜想"><a href="#原因猜想" class="headerlink" title="原因猜想"></a>原因猜想</h2><p>​    笔者首先使用curl命令来检查网站应用对Http请求的响应，可以看到的确出现了访问超时的现象。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --max-time 3 http://192.168.0.30</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl: (28) Operation timed out after 3000 milliseconds with 0 bytes received</span><br></pre></td></tr></table></figure><p>那么究竟是哪里有可能造成丢包呢？回顾整个网络协议栈，笔者总结了可能产生丢包的原因如下图。</p><p><img src="https://raw.githubusercontent.com/yyhyplxyz/SYSU-xiaoxin-catering/master/document_files/1.jpg" alt="1"></p><p>具体而言，有以下几点：</p><ol><li><p>在两台 电脑连接之间， 可能会发生传输失败的错误， 比如网络拥塞、 线路错误等；</p></li><li><p>在网卡收包后， 环形缓冲区可能会因为溢出而丢包；</p></li><li><p>在链路层， 可能会因为网络帧校验失败、 QoS 等而丢包；</p></li><li><p>在 IP层， 可能会因为路由失败、 组包大小超过 MTU 等而丢包；如果配置了 iptables 规则， 这些网络包也可能因为 iptables 过滤规则而丢包。 </p></li><li><p>在传输层， 可能会因为端口未监听、 资源占用超过内核限制等而丢包；</p></li><li><p>在套接字层， 可能会因为套接字缓冲区溢出而丢包；</p></li><li><p>在应用层， 可能会因为应用程序异常而丢包；</p><p>我们首先忽略互联网中的数据传输问题，因为这不是我们能控制的。</p></li></ol><h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><p>​    来看链路层，当缓冲区溢出等原因导致网卡丢包时， Linux会在网卡收发数据的统计信息中， 记录下收发错误的次数。 我们进入容器内，执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">netstat -i</span><br><span class="line">Kernel Interface table</span><br><span class="line">Iface MTU RX-OK RX-ERR RX-DRP RX-OVR TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line">eth0 1300 35 0 0 0 8 0 0 0 BMRU</span><br><span class="line">lo 65536 0 0 0 0 0 0 0 0 LRU</span><br></pre></td></tr></table></figure><p>​    输出中的 RX-OK、 RX-ERR、 RX-DRP、 RX-OVR ， 分别表示接收时的总包数、 总错误数、 进入Ring Buffer 后因其他原因（如内存不足） 导致的丢包数以及 Ring Buffer 溢出导致的丢包数。 TX-OK、 TX-ERR、 TX-DRP、 TX-OVR 也代表类似的含义， 只不过是指发送时对应的各个指标。 </p><p>​    从中我们发现并没有任何错误，这说明说明容器的虚拟网卡没有丢包 。linux操作系统中有流量控制器，我们可以查看下流量控制规则。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tc -s qdisc show dev eth0</span><br><span class="line">qdisc pfifo_fast 0: root refcnt 2 bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1</span><br><span class="line">Sent 5702480501 bytes 44582392 pkt (dropped 0, overlimits 0 requeues 0)</span><br><span class="line">backlog 0b 0p requeues 0</span><br></pre></td></tr></table></figure><p>可以看出linux并未配置任何模拟排队规则来模拟高延迟网络环境。</p><p>我们使用hping3确认一下，数据包的发送与接收确实是正常的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hping3 -c 3 -S -p 80 192.168.0.30</span><br><span class="line">HPING 192.168.0.30 (eth0 192.168.0.30): S set, 40 headers + 0 data bytes</span><br><span class="line">len=44 ip=192.168.0.30 ttl=63 DF id=0 sport=80 flags=SA seq=0 win=5120 rtt=7.8 ms</span><br><span class="line">len=44 ip=192.168.0.30 ttl=63 DF id=0 sport=80 flags=SA seq=1 win=5120 rtt=7.7 ms</span><br><span class="line">len=44 ip=192.168.0.30 ttl=63 DF id=0 sport=80 flags=SA seq=2 win=5120 rtt=3.6 ms</span><br></pre></td></tr></table></figure><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>我们回到容器环境下，执行<code>netstat -s</code>命令，可以看到TCP相关输出结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">TcpExt:</span><br><span class="line">    95 invalid SYN cookies received</span><br><span class="line">    36784 resets received for embryonic SYN_RECV sockets</span><br><span class="line">    943 packets pruned from receive queue because of socket buffer overrun</span><br><span class="line">    17 ICMP packets dropped because they were out-of-window</span><br><span class="line">    18372 TCP sockets finished time wait in fast timer</span><br><span class="line">    78 packets rejects in established connections because of timestamp</span><br><span class="line">    4724 delayed acks sent</span><br><span class="line">    104 delayed acks further delayed because of locked socket</span><br><span class="line">    Quick ack mode was activated 8528 times</span><br><span class="line">    897 SYNs to LISTEN sockets dropped</span><br><span class="line">    18656 packets directly queued to recvmsg prequeue.</span><br><span class="line">    8 bytes directly in process context from backlog</span><br><span class="line">    20709 bytes directly received in process context from prequeue</span><br><span class="line">    44649 packet headers predicted</span><br><span class="line">    34 packets header predicted and directly queued to user</span><br><span class="line">    119192 acknowledgments not containing data payload received</span><br><span class="line">    9760 predicted acknowledgments</span><br><span class="line">    22 times recovered from packet loss due to fast retransmit</span><br><span class="line">    4303 times recovered from packet loss by selective acknowledgements</span><br><span class="line">    Detected reordering 19 times using FACK</span><br><span class="line">    Detected reordering 11 times using SACK</span><br><span class="line">    Detected reordering 97 times using time stamp</span><br><span class="line">    187 congestion windows fully recovered without slow start</span><br><span class="line">    92 congestion windows partially recovered using Hoe heuristic</span><br><span class="line">    450 congestion windows recovered without slow start by DSACK</span><br><span class="line">    8176 congestion windows recovered without slow start after partial ack</span><br><span class="line">    TCPLostRetransmit: 450</span><br><span class="line">    45 timeouts after reno fast retransmit</span><br><span class="line">    816 timeouts after SACK recovery</span><br><span class="line">    1077 timeouts in loss state</span><br><span class="line">    1004 fast retransmits</span><br><span class="line">    448 forward retransmits</span><br><span class="line">    1213 retransmits in slow start</span><br><span class="line">    2876 other TCP timeouts</span><br><span class="line">    TCPLossProbes: 79489</span><br><span class="line">    TCPLossProbeRecovery: 49853</span><br><span class="line">    1 classic Reno fast retransmits failed</span><br><span class="line">    24360 SACK retransmits failed</span><br><span class="line">    2517 packets collapsed in receive queue due to low socket buffer</span><br><span class="line">    985 DSACKs sent for old packets</span><br><span class="line">    497 DSACKs sent for out of order packets</span><br><span class="line">    58701 DSACKs received</span><br><span class="line">    50 DSACKs for out of order packets received</span><br><span class="line">    320 connections reset due to unexpected data</span><br><span class="line">    115 connections reset due to early user close</span><br><span class="line">    1326 connections aborted due to timeout</span><br><span class="line">    TCPSACKDiscard: 1</span><br><span class="line">    TCPDSACKIgnoredOld: 17</span><br><span class="line">    TCPDSACKIgnoredNoUndo: 44242</span><br><span class="line">    TCPSpuriousRTOs: 480</span><br><span class="line">    TCPSackShifted: 710</span><br><span class="line">    TCPSackMerged: 7075</span><br><span class="line">    TCPSackShiftFallback: 20566</span><br><span class="line">    TCPBacklogDrop: 35</span><br><span class="line">    TCPRcvCoalesce: 38445</span><br><span class="line">    TCPOFOQueue: 4724</span><br><span class="line">    TCPOFOMerge: 462</span><br><span class="line">    TCPChallengeACK: 1034</span><br><span class="line">    TCPSYNChallenge: 3</span><br><span class="line">    TCPFastOpenCookieReqd: 15</span><br><span class="line">    TCPFromZeroWindowAdv: 4</span><br><span class="line">    TCPToZeroWindowAdv: 4</span><br><span class="line">    TCPWantZeroWindowAdv: 340</span><br><span class="line">    TCPSynRetrans: 2403</span><br><span class="line">    TCPOrigDataSent: 15014</span><br><span class="line">    TCPHystartTrainDetect: 66</span><br><span class="line">    TCPHystartTrainCwnd: 147</span><br><span class="line">    TCPHystartDelayDetect: 117</span><br><span class="line">    TCPHystartDelayCwnd: 3917</span><br><span class="line">    TCPACKSkippedSynRecv: 2107</span><br><span class="line">    TCPACKSkippedPAWS: 4</span><br><span class="line">    TCPACKSkippedSeq: 25</span><br><span class="line">    TCPACKSkippedFinWait2: 1</span><br><span class="line">    TCPACKSkippedTimeWait: 4</span><br><span class="line">    TCPACKSkippedChallenge: 4</span><br></pre></td></tr></table></figure><p>netstat 汇总了 IP、 ICMP、 TCP、 UDP等各种协议的收发统计信息。 不过， 我们的目的是排查丢包问题， 所以这里主要观察的是错误数、 丢包数以及重传数。从 36784 resets received for embryonic SYN_RECV sockets，我们可以看出主要的错误来自于半连接重置 ，也就是第三次握手失败。</p><h2 id="原因分析与解决"><a href="#原因分析与解决" class="headerlink" title="原因分析与解决"></a>原因分析与解决</h2><p>​    为什么会这样呢，我们使用抓包工具做一下测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 -nn port 5000</span><br></pre></td></tr></table></figure><p>​    输出如下，从中我们可以看出前三个包是正常的 TCP三次握手，但第四个包却是在 3 秒以后了， 并且还是客户端（VM2） 发送过来的 FIN包， 也就说明， 客户端的连接关闭了 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">14:40:00.589235 IP 10.255.255.5.39058 &gt; 172.17.0.2.5000: Flags [S], seq 332257715, win 29200, options [mss 1418,sackOK,TS val 486800541 ecr 0,nop,wscale 7], length 0</span><br><span class="line">14:40:00.589277 IP 172.17.0.2.5000 &gt; 10.255.255.5.39058: Flags [S.], seq 1630206251, ack 332257716, win 4880, options [mss 256,sackOK,TS val 2509376001 ecr 486800541,nop,wscale 7], length 0</span><br><span class="line">14:40:00.589894 IP 10.255.255.5.39058 &gt; 172.17.0.2.5000: Flags [.], ack 1, win 229, options [nop,nop,TS val 486800541 ecr 2509376001], length 0</span><br><span class="line">14:40:03.589352 IP 10.255.255.5.39058 &gt; 172.17.0.2.5000: Flags [F.], seq 76, ack 1, win 229, options [nop,nop,TS val 486803541 ecr 2509376001], length 0</span><br><span class="line">14:40:03.589417 IP 172.17.0.2.5000 &gt; 10.255.255.5.39058: Flags [.], ack 1, win 40, options [nop,nop,TS val 2509379001 ecr 486800541,nop,nop,sack 1 &#123;76:77&#125;], length 0</span><br></pre></td></tr></table></figure><p>​    此时，我们再执行netstat -i 命令就会发现网卡的确记录了丢包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Kernel Interface table</span><br><span class="line">Iface MTU RX-OK RX-ERR RX-DRP RX-OVR TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line">eth0 1300 169 0 0 105 76 0 0 0 BMRU</span><br><span class="line">lo 65536 0 0 0 0 0 0 0 0 LRU</span><br></pre></td></tr></table></figure><p>​    这也就是为什么curl会超时了。而我们发现之前执行hping3命令时，一切正常，因此很有可能是因为curl 在发送 SYN包后， 还会发送 HTTPGET请求 导致的。因此curl发送的数据包包含的字段会多一些，笔者进而发现了容器配置的虚拟网卡的MTU值只有1300，而以太网的默认MTU值是1500.这个值表示最大传输单元，如果一条物理链路的两端MTU不一致，就会导致丢包现象的发生。（MTU一般与MRU最大接收单元相等，这样一个物理链路可以类似一个水管，两边流量不匹配导致的失衡）</p><p>​    我们将MTU的值改回1500即可。笔者并不清楚为什么docker会有这样一个奇怪的错误，网上可以查到也有不少遇到这个问题的人。也附上相关博文链接，供参考</p><p><a href="https://medium.com/@sylwit/how-we-spent-a-full-day-figuring-out-a-mtu-issue-with-docker-4d81fdfe2caf" target="_blank" rel="noopener">https://medium.com/@sylwit/how-we-spent-a-full-day-figuring-out-a-mtu-issue-with-docker-4d81fdfe2caf</a></p><p><a href="https://nicksu86.github.io/2019/05/Docker-MTU/" target="_blank" rel="noopener">https://nicksu86.github.io/2019/05/Docker-MTU/</a></p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;导论&quot;&gt;&lt;a href=&quot;#导论&quot; class=&quot;headerlink&quot; title=&quot;导论&quot;&gt;&lt;/a&gt;导论&lt;/h2&gt;&lt;p&gt;​    容器利用 Linux内核提供的命名空间技术， 将不同应用程序的运行隔离起来， 并用统一的镜像，来管理应用程序的依赖环境。 这为应用
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库中的视图</title>
    <link href="http://yyhyplxyz.github.io/2019/06/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E8%A7%86%E5%9B%BE/"/>
    <id>http://yyhyplxyz.github.io/2019/06/30/数据库中的视图/</id>
    <published>2019-06-30T04:16:41.000Z</published>
    <updated>2019-06-30T04:18:58.075Z</updated>
    
    <content type="html"><![CDATA[<p>在一个项目的实际开发过程中牵涉到复杂业务的时候，我们不可避免的需要使用中间表来进行数据连接，虽然我们可以用主外键进行关联，多对多，多对一，一对一等，但采用主外键关联在数据的操作过程中具有很强的耦合性，尤其对于需要经常删改数据表而言，采用主外键关联这种模式对数据库性能还是有影响的。如果我们采用中间表的话，当数据过大在性能上又面临严峻考验，sql视图的出现，在解决中间表的业务逻辑上是不错的选择。视图是虚拟的表，只包含使用时动态检索数据的查询。也就是说作为视图，它不包含任何列和数据，包含的是一个查询。视图的字段是由我们自定义的，视图只供查询，数据不可更改，查询数据来源于我们建立的实体表。</p><p>使用视图可以</p><ul><li>重用SQL语句</li><li>简化复杂的SQL操作</li><li>使用表的一部分而不是整个表</li><li>保护数据：可以赋予访问表的特定部分的权限</li><li>可返回与底层表不同格式和表示的数据</li></ul><p>如果应用大量或复杂的视图，极可能影响性能，应该先进行测试再应用视图。</p><p>视图的使用也有一些限制</p><ul><li>视图名必须唯一，与其他的视图和表不同</li><li>视图数目没有限制</li><li>可以嵌套</li><li>视图不能索引，也不能有关联的触发器或默认值</li></ul><p>不同DBMS对视图语法和表示的定义不同。</p><p>例如，有些DBMS会限制视图嵌套的级数、禁止在视图中使用ORDER BY子句、设置视图为只读等等。</p><h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><p>使用CREATE VIEW语句来创建视图。</p><p>使用DROP VIEW语句来删除视图。</p><p>覆盖或更新视图，必须先删除视图，然后再重新创建。</p><h3 id="利用视图简化复杂的联结"><a href="#利用视图简化复杂的联结" class="headerlink" title="利用视图简化复杂的联结"></a><strong>利用视图简化复杂的联结</strong></h3><p>建议创建不绑定特定数据的视图，增强可重用性。我们以下从顾客，订单，购买物品三个表连在了一起，创建了视图。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [sqlbzbh]&gt; SHOW TABLES;</span><br><span class="line">+<span class="comment">-------------------+</span></span><br><span class="line">| Tables_in_sqlbzbh |</span><br><span class="line">+<span class="comment">-------------------+</span></span><br><span class="line">| Customers         |</span><br><span class="line">| OrderItems        |</span><br><span class="line">| Orders            |</span><br><span class="line">| Products          |</span><br><span class="line">| Vendors           |</span><br><span class="line">+<span class="comment">-------------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">MariaDB [sqlbzbh]&gt;</span><br><span class="line">MariaDB [sqlbzbh]&gt; <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> ProductCustomers <span class="keyword">AS</span></span><br><span class="line">    -&gt; <span class="keyword">SELECT</span> cust_name, cust_contact, prod_id</span><br><span class="line">    -&gt; <span class="keyword">FROM</span> Customers, Orders, OrderItems</span><br><span class="line">    -&gt; <span class="keyword">WHERE</span> Customers.cust_id = Orders.cust_id</span><br><span class="line">    -&gt; <span class="keyword">AND</span> OrderItems.order_num = Orders.order_num;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">MariaDB [sqlbzbh]&gt;</span><br><span class="line">MariaDB [sqlbzbh]&gt; SHOW TABLES;</span><br><span class="line">+<span class="comment">-------------------+</span></span><br><span class="line">| Tables_in_sqlbzbh |</span><br><span class="line">+<span class="comment">-------------------+</span></span><br><span class="line">| Customers         |</span><br><span class="line">| OrderItems        |</span><br><span class="line">| Orders            |</span><br><span class="line">| ProductCustomers  |</span><br><span class="line">| Products          |</span><br><span class="line">| Vendors           |</span><br><span class="line">+<span class="comment">-------------------+</span></span><br><span class="line">6 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">MariaDB [sqlbzbh]&gt; <span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line">    -&gt; <span class="keyword">FROM</span> ProductCustomers</span><br><span class="line">    -&gt; <span class="keyword">WHERE</span> prod_id = <span class="string">'RGAN01'</span>;</span><br><span class="line">+<span class="comment">---------------+--------------------+</span></span><br><span class="line">| cust_name     | cust_contact       |</span><br><span class="line">+<span class="comment">---------------+--------------------+</span></span><br><span class="line">| Fun4All       | Denise L. Stephens |</span><br><span class="line">| The Toy Store | Kim Howard         |</span><br><span class="line">+<span class="comment">---------------+--------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">MariaDB [sqlbzbh]&gt;</span><br></pre></td></tr></table></figure><h3 id="用视图重新格式化检索出的数据"><a href="#用视图重新格式化检索出的数据" class="headerlink" title="用视图重新格式化检索出的数据"></a><strong>用视图重新格式化检索出的数据</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [sqlbzbh]&gt; CREATE VIEW VendorLocations AS</span><br><span class="line">    -&gt; SELECT Concat(vend_name, '---', vend_country) AS vend_title FROM Vendors;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">MariaDB [sqlbzbh]&gt;</span><br><span class="line">MariaDB [sqlbzbh]&gt; SELECT * FROM VendorLocations;</span><br><span class="line">+<span class="comment">-------------------------+</span></span><br><span class="line">| vend_title              |</span><br><span class="line">+<span class="comment">-------------------------+</span></span><br><span class="line">| Bear Emporium<span class="comment">---USA     |</span></span><br><span class="line">| Bears R Us<span class="comment">---USA        |</span></span><br><span class="line">| Doll House Inc.<span class="comment">---USA   |</span></span><br><span class="line">| Fun and Games<span class="comment">---England |</span></span><br><span class="line">| Furball Inc.<span class="comment">---USA      |</span></span><br><span class="line">| Jouets et ours<span class="comment">---France |</span></span><br><span class="line">+<span class="comment">-------------------------+</span></span><br><span class="line">6 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">MariaDB [sqlbzbh]&gt;</span><br></pre></td></tr></table></figure><h3 id="用视图过滤不想要的数据"><a href="#用视图过滤不想要的数据" class="headerlink" title="用视图过滤不想要的数据"></a><strong>用视图过滤不想要的数据</strong></h3><p>WHERE子句适用于视图。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [sqlbzbh]&gt; CREATE VIEW CustomerEMailList AS</span><br><span class="line">    -&gt; SELECT cust_id, cust_name, cust_email FROM Customers WHERE cust_email IS NOT NULL;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">MariaDB [sqlbzbh]&gt;</span><br><span class="line">MariaDB [sqlbzbh]&gt; SELECT * FROM CustomerEMailList;</span><br><span class="line">+<span class="comment">------------+--------------+-----------------------+</span></span><br><span class="line">| cust_id    | cust_name    | cust_email            |</span><br><span class="line">+<span class="comment">------------+--------------+-----------------------+</span></span><br><span class="line">| 1000000001 | Village Toys | sales@villagetoys.com |</span><br><span class="line">| 1000000003 | Fun4All      | jjones@fun4all.com    |</span><br><span class="line">| 1000000004 | Fun4All      | dstephens@fun4all.com |</span><br><span class="line">+<span class="comment">------------+--------------+-----------------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">MariaDB [sqlbzbh]&gt;</span><br></pre></td></tr></table></figure><h3 id="使用视图与计算字段"><a href="#使用视图与计算字段" class="headerlink" title="使用视图与计算字段"></a><strong>使用视图与计算字段</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [sqlbzbh]&gt; CREATE VIEW OrderItemsExpanded AS</span><br><span class="line">    -&gt; SELECT order_num, prod_id, quantity, item_price, quantity*item_price AS expanded_price FROM OrderItems;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">MariaDB [sqlbzbh]&gt;</span><br><span class="line">MariaDB [sqlbzbh]&gt; SELECT * FROM OrderItemsExpanded WHERE order_num = 20008;</span><br><span class="line">+<span class="comment">-----------+---------+----------+------------+----------------+</span></span><br><span class="line">| order_num | prod_id | quantity | item_price | expanded_price |</span><br><span class="line">+<span class="comment">-----------+---------+----------+------------+----------------+</span></span><br><span class="line">|     20008 | RGAN01  |        5 |       4.99 |          24.95 |</span><br><span class="line">|     20008 | BR03    |        5 |      11.99 |          59.95 |</span><br><span class="line">|     20008 | BNBG01  |       10 |       3.49 |          34.90 |</span><br><span class="line">|     20008 | BNBG02  |       10 |       3.49 |          34.90 |</span><br><span class="line">|     20008 | BNBG03  |       10 |       3.49 |          34.90 |</span><br><span class="line">+<span class="comment">-----------+---------+----------+------------+----------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">MariaDB [sqlbzbh]&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在一个项目的实际开发过程中牵涉到复杂业务的时候，我们不可避免的需要使用中间表来进行数据连接，虽然我们可以用主外键进行关联，多对多，多对一，一对一等，但采用主外键关联在数据的操作过程中具有很强的耦合性，尤其对于需要经常删改数据表而言，采用主外键关联这种模式对数据库性能还是有影
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CNCF初实践</title>
    <link href="http://yyhyplxyz.github.io/2019/01/19/CNCF%E5%88%9D%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yyhyplxyz.github.io/2019/01/19/CNCF初实践/</id>
    <published>2019-01-19T01:30:18.000Z</published>
    <updated>2019-01-19T03:45:16.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="K8S介绍"><a href="#K8S介绍" class="headerlink" title="K8S介绍"></a>K8S介绍</h2><h3 id="什么是Kubernetes？"><a href="#什么是Kubernetes？" class="headerlink" title="什么是Kubernetes？"></a>什么是Kubernetes？</h3><p>Kubernetes（k8s）是自动化容器操作的开源平台，这些操作包括部署，调度和节点集群间扩展。我们曾经用过Docker容器技术部署容器，而Docker恰恰可以被看成Kubernetes内部使用的低级别组件。Kubernetes不仅仅支持Docker，还支持Rocket，这是另一种容器技术。</p><p>使用Kubernetes可以：</p><ul><li>自动化容器的部署和复制 </li><li>随时扩展或收缩容器规模 </li><li>将容器组织成组，并且提供容器间的负载均衡 </li><li>很容易地升级应用程序容器的新版本 </li><li>提供容器弹性，如果容器失效就替换它</li></ul><p>实际上，使用Kubernetes只需一个部署文件，使用一条命令就可以部署多层容器（前端，后台等）的完整集群：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f single-config-file.yaml</span><br></pre></td></tr></table></figure><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>集群是一组节点，这些节点可以是物理服务器或者虚拟机，之上安装了Kubernetes平台。下图展示这样的集群。</p><p>这里可以看到一个典型的Kubernetes架构图。</p><p><a href="http://dockone.io/uploads/article/20151230/d56441427680948fb56a00af57bda690.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20151230/d56441427680948fb56a00af57bda690.png" alt="1.png"></a></p><p>集群拥有一个Kubernetes Master（紫色方框）。Kubernetes Master提供集群的独特视角，并且拥有一系列组件来操控多个主机提供高可用的服务。</p><h2 id="搭建K8S集群与基本工具"><a href="#搭建K8S集群与基本工具" class="headerlink" title="搭建K8S集群与基本工具"></a>搭建K8S集群与基本工具</h2><h3 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h3><p>安装过程将在Ubuntu 16.04系统上（一台master node，两台worker node）进行</p><h3 id="VirtualBox搭建集群"><a href="#VirtualBox搭建集群" class="headerlink" title="VirtualBox搭建集群"></a>VirtualBox搭建集群</h3><ol><li>下载ubuntu镜像文件</li><li>创建新的虚拟机镜像模板</li><li>挂载我们在第一步下载的镜像文件</li><li>创建全局NAT网络</li><li>克隆三个虚拟机，k8s1（master，k8s2，k8s3</li><li>网络类型NAT网络，选择我们第四步创建的网络名称</li><li>NAT网络配置端口转发规则，确保可以通过ssh本地连接虚拟机</li></ol><h3 id="安装容器引擎"><a href="#安装容器引擎" class="headerlink" title="安装容器引擎"></a>安装容器引擎</h3><p>安装docker，具体过程略</p><h3 id="安装各组件和命令行工具"><a href="#安装各组件和命令行工具" class="headerlink" title="安装各组件和命令行工具"></a>安装各组件和命令行工具</h3><ol><li><p>添加kuberbates apt源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/apt/sources.list</span><br><span class="line"><span class="meta">#</span><span class="bash"> 系统安装源</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> kubeadm及kubernetes组件安装源</span></span><br><span class="line">deb https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial main</span><br></pre></td></tr></table></figure></li><li><p>apt安装kublet， kubeadm，kubectl</p></li><li><p>初始化master节点，其中192.168.16.0/20为本地IP，<em>apiserver</em>-<em>advertise</em>-<em>address</em>是API server 用来告知集群中其它成员的地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --apiserver-advertise-address=10.0.25 --pod-network-cidr=192.168.16.0/20</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzbo7ddd8gj31nb0u0u0x.jpg" alt=""></p><ol><li>配置kubectl环境变量</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export KUBECONFIG=/etc/kubernates/admin.conf</span><br></pre></td></tr></table></figure><ol><li><p>查看当前节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -n kube-system -o wide</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzbo844jbsj31nb0u0hdt.jpg" alt=""></p><p>我们呢会发现此时除了dns服务，其它都可以使用</p><h3 id="安装集群网络"><a href="#安装集群网络" class="headerlink" title="安装集群网络"></a>安装集群网络</h3><p>一个好的网络方案，可以让多个容器构成的基于微服务架构的应用可以运行在任何地方：主机，多主机，云上或者数据中心。应用程序使用网络就好像容器是插在同一个网络交换机上一样，不需要配置端口映射，连接等。</p><p>我们这里选择比较常用的Weave网络，它通过创建虚拟网络使docker容器能够跨主机通信并能够自动相互发现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L "https://cloud.weave.works/k8s/net?k8s-version4(kubectl v ersion I base64 I tr -d '\n')" &gt; weave.yaml</span><br></pre></td></tr></table></figure><p>接着我们打开该文件，如下，新添加<code>-name:IPALLOC_RANGE value:192.168.16.0/20</code>字段，其中ip地址是我们在第一步创建的master节点的ip。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzboa3nxsvj319t0u0khn.jpg" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f weave.yaml</span><br></pre></td></tr></table></figure><h3 id="节点加入集群网络"><a href="#节点加入集群网络" class="headerlink" title="节点加入集群网络"></a>节点加入集群网络</h3><ul><li><p>现状</p><p>此时master节点的各组件已安装完毕，但集群中只有master一个节点。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzbocg52qpj31mb0u0e81.jpg" alt=""></p></li><li><p>k8s2节点加入集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.0.200:6443 --token rw4enn.mvk547juq7qi2b5f --discovery-token-ca-cert-hash sha256:ba260d5191213382a806a9a7d92c9e6bb09061847c7914b1ac584d0c69471579</span><br></pre></td></tr></table></figure><p>k8s3节点以此类推，值得注意的是，一般master节点不承担工作负荷。</p></li></ul><h3 id="非master节点上管理集群"><a href="#非master节点上管理集群" class="headerlink" title="非master节点上管理集群"></a>非master节点上管理集群</h3><ol><li><p>将master节点上的/etc/kubernetes/admin.conf分发到各worker节点的对应目录下</p></li><li><p>设置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export KUBECONFIG=/etc/kubernates/admin.conf</span><br></pre></td></tr></table></figure></li></ol><h3 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h3><ol><li><p>安装dashboard</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzbpuuotc1j320i03s46p.jpg" alt=""></p></li><li><p>访问dashboard</p><ul><li><p>建立api server的代理，运行在8001端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl proxy</span><br></pre></td></tr></table></figure></li><li><p>设置端口转发规则，本地端口9001的数据转到master节点上去（9091端口）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -D 9001 root@127.0.0.1 -p 9091</span><br></pre></td></tr></table></figure></li><li><p>浏览器设定代理服务器，本地的数据转发到9001端口，从而访问master节点</p></li><li><p>浏览器输入地址，访问dashboard</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy</span><br></pre></td></tr></table></figure></li><li><p>创建管理用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f user.yaml</span><br></pre></td></tr></table></figure><p>创建绑定</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f user-binding.yaml</span><br></pre></td></tr></table></figure><p>user.yaml的文件内容如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">vl</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span> </span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line"><span class="attr">name:</span> <span class="string">yyhyplxyz</span> </span><br><span class="line"><span class="attr">namespace:</span> <span class="string">kube</span> <span class="string">system</span></span><br></pre></td></tr></table></figure><p>user-binding.yaml的文件内容如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/vlbetal</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="attr">dashboard:yyhyplxyz</span> </span><br><span class="line"><span class="attr">roleRef:</span> </span><br><span class="line"><span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span> </span><br><span class="line"><span class="attr">name:</span> <span class="string">cluster-admin</span> </span><br><span class="line"><span class="attr">subjects:</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">lerviceAccount</span> </span><br><span class="line"><span class="attr">name:</span> <span class="string">yyhyplxyz</span> </span><br><span class="line"><span class="attr">namespace:</span> <span class="string">kube</span> <span class="string">system</span></span><br></pre></td></tr></table></figure><p>接着，我们查看我们生成的用户密钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get secret -n kube-system #选出恰当的名字</span><br><span class="line">kubectl describe secret/yyhyplxyz token-knfmh -n kube-system</span><br></pre></td></tr></table></figure><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzbqi88n81j324o0oahdu.jpg" alt=""></p><p>复制token数据段</p></li><li><p>浏览器登录，dashboard登录界面</p><p>选择令牌方式登录</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzbqj0znz0j315w0lydme.jpg" alt=""></p></li></ul></li><li><p>安装Heapster</p><p>这个组件负责k8s集群度量数据采集和容器监控，</p><ul><li><p>我们首先下载Heapster的github开源代码</p></li><li><p>下载镜像文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull anjia0532/heapster grafana amd64:v4.4.3</span><br></pre></td></tr></table></figure></li><li><p>在github源码包中的<code>/deploy/ube-config</code>中执行创建influxdb的命令，influxdb是Heapster的后端</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f influxdb</span><br></pre></td></tr></table></figure><ul><li>创建角色绑定，在deploy目录下，运行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f  rbac/heapster-rbac.yaml</span><br></pre></td></tr></table></figure></li><li><p>安装效果</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzbqoh1w7vj31rl0u0ato.jpg" alt=""></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzbqp7y79hj31rl0u0gx3.jpg" alt=""></p></li></ol><h2 id="K8S基本使用"><a href="#K8S基本使用" class="headerlink" title="K8S基本使用"></a>K8S基本使用</h2><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod是k8s的最基本的操作单元，包含一个或多个紧密相关的容器，类似于豌豆荚的概念。一个Pod可以被一个容器化的环境看作应用层的“逻辑宿主机”（Logical Host)。一个Pod中的多个容器应用通常是紧耦合的。Pod在Node上被创建、启动或者销毁。</p><p>   为什么k8s使用Pod在容器之上再封装一层呢？一个很重要的原因是Docker容器之间的通信受到Docker网络机制的限制。在Docker的世界中，一个容器需要通过link方式才能访问另一个容器提供的服务（端口）。大量容器之间的link将是一个非常繁重的工作。通过Pod的概念将多个容器组合在一个虚拟的“主机”内，可以实现容器之间仅需通过Localhost就能相互通信了。</p><p>一个Pod中的应用容器共享同一组资源：</p><p>  （1）PID命名空间：Pod中的不同应用程序可以看见其他应用程序的进程ID</p><p>  （2）网络命名空间：Pod中的多个容器能访问同一个IP和端口范围</p><p>  （3）IPC命名空间：Pod中的多个容器能够使用SystemV IPC或POSIX消息队列进行通信。</p><p>  （4）UTS命名空间：Pod中的多个容器共享一个主机名</p><p>  （5）Volumes（共享存储卷）：Pod中的各个容器可以访问在Pod级别定义的Volumes  </p><p>一些Pod有Label。一个Label是attach到Pod的一对键/值对，用来传递用户定义的属性。比如，你可能创建了一个”tier”和“app”标签，通过Label（<strong>tier=frontend, app=myapp</strong>）来标记前端Pod容器，使用Label（<strong>tier=backend, app=myapp</strong>）标记后台Pod。然后可以使用Selectors选择带有特定Label的Pod，并且将Service或者Replication Controller应用到上面。</p><p>pod常常运行在node（物理主机）上。</p><h3 id="Replication-Controller"><a href="#Replication-Controller" class="headerlink" title="Replication Controller"></a>Replication Controller</h3><p>Replication Controller确保任意时间都有指定数量的Pod“副本”在运行。如果为某个Pod创建了Replication Controller并且指定3个副本，它会创建3个Pod，并且持续监控它们。如果某个Pod不响应，那么Replication Controller会替换它，保持总数为3.如下面的动画所示：</p><p><a href="http://dockone.io/uploads/article/20151230/5e2bad1a25e33e2d155da81da1d3a54b.gif" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20151230/5e2bad1a25e33e2d155da81da1d3a54b.gif" alt="2.gif"></a></p><p>如果之前不响应的Pod恢复了，现在就有4个Pod了，那么Replication Controller会将其中一个终止保持总数为3。如果在运行中将副本总数改为5，Replication Controller会立刻启动2个新Pod，保证总数为5。还可以按照这样的方式缩小Pod，这个特性在执行滚动升级时很有用。</p><p> master服务上创建文件node-controller.yaml,为了避免同一个rc定义的pod在同一个node上生成多个pod时，端口冲突，文件中不指定hostPort。replicas指定pod的数量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span> <span class="comment">#指名类型为rc</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">   name:</span> <span class="string">node-controller</span> <span class="comment">#rc 名字，创建后的pod名字为  serverrc-随机字符</span></span><br><span class="line"><span class="attr">   labels:</span> </span><br><span class="line"><span class="attr">     name:</span> <span class="string">node-controller</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">2</span> <span class="comment">#指定副本数量，会一直维持这个数量的副本，如果某节点挂掉，又会立即构建新的来替代　　</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">     name:</span> <span class="string">node-test-pod</span></span><br><span class="line"><span class="attr">  template:</span> </span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">     labels:</span></span><br><span class="line"><span class="attr">       name:</span> <span class="string">node-test-pod</span> </span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">node-test</span></span><br><span class="line"><span class="attr">        image:</span> <span class="number">192.168</span><span class="number">.174</span><span class="number">.131</span><span class="string">:5000/node-base:1.0</span> <span class="comment">#镜像源</span></span><br><span class="line"><span class="attr">        env:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">ENV_TEST_1</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">env_test_1</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">ENV_TEST_2</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">env_test_2</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span> 　<span class="comment">#容器端口</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f node-controller.yaml</span><br></pre></td></tr></table></figure><p>现在已经创建了Pod的一些副本，那么在这些副本上如何均衡负载呢？我们需要的是Service。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>如果Pods是短暂的，那么重启时IP地址可能会改变，怎么才能从前端容器正确可靠地指向后台容器呢？Service就恰是定义一系列Pod以及访问这些Pod的策略的一层抽象。Service通过Label找到Pod组。现在，假定有2个后台Pod，并且定义后台Service的名称为‘backend-service’，lable选择器为<code>（tier=backend, app=myapp）</code>。backend-service的Service会完成如下两件重要的事情：</p><ul><li>会为Service创建一个本地集群的DNS入口，因此前端Pod只需要DNS查找主机名为 ‘backend-service’，就能够解析出前端应用程序可用的IP地址。</li><li>现在前端已经得到了后台服务的IP地址，但是它应该访问2个后台Pod的哪一个呢？Service在这2个后台Pod之间提供透明的负载均衡，会将请求分发给其中的任意一个（如下面的动画所示）。通过每个Node上运行的代理（kube-proxy）完成。</li></ul><p>下述动画展示了Service的功能。<a href="http://dockone.io/uploads/article/20151230/125bbccce0b3bbf42abab0e520d9250b.gif" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20151230/125bbccce0b3bbf42abab0e520d9250b.gif" alt="3.gif"></a></p><p>有一个特别类型的Kubernetes Service，称为’LoadBalancer’，作为外部负载均衡器使用，在一定数量的Pod之间均衡流量。比如，对于负载均衡Web流量很有用。</p><p>我们再看上面例子，node-test Pod运行了2个副本（replicas），这2个Pod对于前端程序来说没有区别，所以前端程序不关心是哪个后端副本在提供服务。并且后端node-test Pod在发生变化（比如replicas数量变化或某个node挂了，Pod在另一个node重新生成），前端无须跟踪这些变化。“Service”就是用来实现这种解耦的抽象概念。如下，我们可以创建</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span>  <span class="comment">#指定种类为service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">node-service</span>  <span class="comment">#service 名字 提供给调用方使用，调用方无需知道ip  由dns解析服务名为cluster ip</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">node-service</span> <span class="comment">#rc的名字，service将同一名字的rc作为后端node进行负载</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - port:</span> <span class="number">8081</span>  <span class="comment">#service暴露在cluster ip上的端口，clusterIP:port 是提供给集群内部客户访问service的入口</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">80</span>  <span class="comment">#pod上的端口，从port和nodePort上到来的数据最终经过kube-proxy流入到后端pod的targetPort上进入容器，和rc中的containerPort一致</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">TCP</span>  <span class="comment">#提供给集群外部客户访问service的入口</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">node-test-pod</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;K8S介绍&quot;&gt;&lt;a href=&quot;#K8S介绍&quot; class=&quot;headerlink&quot; title=&quot;K8S介绍&quot;&gt;&lt;/a&gt;K8S介绍&lt;/h2&gt;&lt;h3 id=&quot;什么是Kubernetes？&quot;&gt;&lt;a href=&quot;#什么是Kubernetes？&quot; class=&quot;head
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>docker介绍深入浅出(-)</title>
    <link href="http://yyhyplxyz.github.io/2018/12/24/docker%E7%AE%80%E4%BB%8B/"/>
    <id>http://yyhyplxyz.github.io/2018/12/24/docker简介/</id>
    <published>2018-12-24T14:18:40.000Z</published>
    <updated>2018-12-25T00:27:37.493Z</updated>
    
    <content type="html"><![CDATA[<h2 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h2><p>镜像和容器是 Docker 中最基本的 2 个概念，镜像相当于光盘， 光盘里面存储的数据是只读的， 不会被更改的。我们可以把镜像找作一个模板或者蓝图，而容器是用镜像生成的 Docker 实例。一个镜像可以生成多个容器， 每个容器之间，容器与宿主机之间都是相互隔离的，同时，容器可以快速方便地运行, 也可以方便地删除。在实际应用中，我们甚至可以把容器当作虚拟机来使用。</p><h2 id="自动部署与Dockerfile"><a href="#自动部署与Dockerfile" class="headerlink" title="自动部署与Dockerfile"></a>自动部署与Dockerfile</h2><p>我们首先需要安装一个docker，这部分内容略，读者可以轻易在网上找到资料，且操作极易。</p><h3 id="运行第一个容器应用"><a href="#运行第一个容器应用" class="headerlink" title="运行第一个容器应用"></a>运行第一个容器应用</h3><p>我们使用下面的命令启动一个 Docker 容器</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -d -t -p 8000:5000 -name demo ubuntu:18.04</span></span><br></pre></td></tr></table></figure><p>这条命令的具体解释如下</p><ul><li><p>run 表示启动一个新的 Docker 容器</p></li><li><p>-d 表示容器在后台运行 </p></li><li><p>-t 极少能用到， 用于让一个空白的 ubuntu 镜像在后台运行</p></li><li><p>-p 用于指定端口映射′ 表示在本机访问 8000 会被自动转到容器中的 5000 端口<br>必须保证本机没有其他程序占用了 8000 端口， 否则这里会失败</p></li><li><p>-name demo 指定了容器的名字是 demo</p></li><li><p>ubuntu:18.04 是启动容器使用的镜像名，Docker 会自动从镜像服务器去下载这个镜像</p></li></ul><h3 id="运行一个简单的web应用"><a href="#运行一个简单的web应用" class="headerlink" title="运行一个简单的web应用"></a>运行一个简单的web应用</h3><p>这次我们选择开一个新容器，并提供web服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -d -p 7000:5000 -name demo ubuntu:18.04</span><br></pre></td></tr></table></figure><p>由于之前已经自动下载过 ubuntu:18.04 所以这次不会重新下载镜像, 速度很快，这个新的容器名叫demo。</p><p>我们首先在本地准备好运行的代码文件<code>a.py</code>，如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(host=<span class="string">"0.0.0.0"</span>, debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>接着我们在容器内创建目录，<code>exec</code> 命令后跟随容器名，然后再添加操作命令<code>mkdir /code</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec demol mkdir /code</span><br></pre></td></tr></table></figure><p><code>cp</code> 参数把当前文件夹的<code>a.py</code>拷贝到 demo 容器的 <code>/Code/a.py</code>处。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp a.py "demo:/code/a.py"</span><br></pre></td></tr></table></figure><p> <code>/code</code>必须是容器中存在的目录， Docker 不会自动创建，因此我们需要先手动创建。</p><p>接着我们同样用exec安装必要的依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker exec demo apt update</span><br><span class="line"></span><br><span class="line">docker exec demo apt -y install  python3 python3-pip</span><br><span class="line"></span><br><span class="line">docker exec demo pip3 install flask</span><br></pre></td></tr></table></figure><p>然后在容器 demo 中运行<code>a.py</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec demo python3  /code/o.py</span><br></pre></td></tr></table></figure><p>通过以上的操作，我们并在容器中安装程序运行所需的依赖库然后运行了一个 flask web 程序</p><p>以上操作较繁琐，我们也可以新建两个脚本文件<code>install.sh</code>和<code>run.sh</code>，然后直接运行脚本文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">install.sh</span></span><br><span class="line">apt update</span><br><span class="line">apt -y install python3 python3-pip</span><br><span class="line">pip3 install flask</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">run.sh</span></span><br><span class="line">cd /code</span><br><span class="line">python3 a.py</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker cp install.sh "demol:/code/install.sh"</span><br><span class="line"></span><br><span class="line">docker cp run.sh "demo1:/code/run.sh"</span><br><span class="line"></span><br><span class="line">docker exec demol bash /code/install.sh</span><br><span class="line"></span><br><span class="line">docker exec demol bash /code/run.sh</span><br></pre></td></tr></table></figure><h3 id="Dockerfile自动化操作"><a href="#Dockerfile自动化操作" class="headerlink" title="Dockerfile自动化操作"></a>Dockerfile自动化操作</h3><p>在本文件夹下，除了<code>a.py</code>外，我们又新建了个Dockerfile文件，如下。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Dockerfile 文件中 # 是注释</span></span><br><span class="line"><span class="comment"># FROM 用于指定构建镜像使用的基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># RUN 用于在构建镜像的时候在镜像中执行命令</span></span><br><span class="line"><span class="comment"># 这里我们安装 python3 和 flask web 框架</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt update</span></span><br><span class="line"><span class="bash">RUN apt -y install python3 python3-pip</span></span><br><span class="line"><span class="bash">RUN pip3 install flask</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># COPY 相当于命令的 docker cp</span></span></span><br><span class="line"><span class="bash"><span class="comment"># 把本机当前目录下的 app.py 文件拷贝到镜像的 /code/app.py</span></span></span><br><span class="line"><span class="bash"><span class="comment"># 和 docker cp 不同的是，COPY 会自动创建镜像中不存在的目录，比如 /code</span></span></span><br><span class="line"><span class="bash">COPY app.py /code/app.py</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># WORKDIR 用于指定从镜像启动的容器内的工作目录</span></span></span><br><span class="line"><span class="bash">WORKDIR /code</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># CMD 用于指定容器运行后要执行的命令和参数列表</span></span></span><br><span class="line"><span class="bash"><span class="comment"># 这样从本镜像启动容器后会自动执行 python3 app.py 这个命令</span></span></span><br><span class="line"><span class="bash"><span class="comment"># 由于我们已经用 WORKDIR 指定了容器的工作目录</span></span></span><br><span class="line"><span class="bash"><span class="comment"># 所以下面的命令都是在 /code 下执行的</span></span></span><br><span class="line"><span class="bash">CMD [<span class="string">"python3"</span>, <span class="string">"app.py"</span>]</span></span><br></pre></td></tr></table></figure><p>我们可以直接运行下面的命令构建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t webimage .</span><br></pre></td></tr></table></figure><p><code>-t webimage</code> 指定了镜像的名字为 webimage，最后的那个 . 用来表示工作目录为本机当前目录。<br>随后我们可以直接用该镜像来运行容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8001:5000 -name demo2 webimage</span><br></pre></td></tr></table></figure><h3 id="docker-常用命令"><a href="#docker-常用命令" class="headerlink" title="docker 常用命令"></a>docker 常用命令</h3><p>启动一个停止运行的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start demo</span><br></pre></td></tr></table></figure><p>查找正在运行的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>停止容器， demo 是容器的名字</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop demo</span><br></pre></td></tr></table></figure><p>可以用 -o 参数查找所有容器, 包括未运行的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -o ps</span><br></pre></td></tr></table></figure><p>删除被停止的容器和运行中的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm demo</span><br><span class="line">docker rm -f demo</span><br></pre></td></tr></table></figure><h2 id="数据卷与文件挂载"><a href="#数据卷与文件挂载" class="headerlink" title="数据卷与文件挂载"></a>数据卷与文件挂载</h2><p>我们可以在概念上把 Docker 找作虚拟机。当容器被删除的时候， 容器里的所有数据都会被删除，两个不同的容器之间无法互通。基于这些因素 Docker 推出了 数据卷 (volume) 功能。<br>我们可以把数据卷理解为虚拟机的虚拟磁盘， 它是独立于容器的文件，在容器中它破挂载为一个目录的形式。对于容器中的应用来说， 数据卷是透明的， 无法感知它的存在， 它就是一个普通的文件夹。由于数据卷独立于容器而存在, 因此删除容器的时候数据卷不会受到影响。<br>数据卷有以下优点</p><ul><li>多容器可以通过挂载同一个数据卷来共享数据</li><li>数据卷可以方便地备份存储数据</li></ul><ol><li><p>创建一个 volume</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create testvolume</span><br></pre></td></tr></table></figure></li><li><p>列出所有数据卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br></pre></td></tr></table></figure></li><li><p>删除一个数据卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm testvolume</span><br></pre></td></tr></table></figure></li></ol><p>我们下面来找一下如何在容器中使用数据卷</p><p>先创建一个数据卷web，接着在运行容器webimage的时候， 使用参数 -mount 如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name demovolume -mount source=web, target=/volume webimage</span><br></pre></td></tr></table></figure><p>后面参数的含义是把数据卷挂载到容器的 /volume 目录上</p><p>这样就运行了一个带有数据卷的容器， 这个容器的 /VoIume 目录中的内容在容器被删除后仍然存在。因为它实际上是存在 Docker 数据卷中。没有保存在数据卷上的文件会在容器被删除后丢失</p><p>这样我们就可以实现多容器之间可以通过数据卷共享文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -name demovolume2 -mount source=web,target=/volume webimage</span><br></pre></td></tr></table></figure><p>除了挂载数据卷外, Docker 还可以挂载共享目录 (这一点和虚拟机一样)。共享目录的优势是使用方便， 易于理解。我们开发时在宿主机中修改源代码就可以做到docker中实时生效省却 build 镜像的过程。<br>下面的命令会从 nginx 镜像运行一个名为 nginx1 的容器，井且设置了 8080-&gt;80 的端口映射，mount 参数的 type=bind 表明要挂载共享目录，把宿主机的当前目录映射为容器的 /usr/share/nginx/html<br>(这是 nginx 容器的静态页面文件存放路径).这样在宿主机中访问localhost:8080 会自动访问宿主机当前目录下的 index.html 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:80 -name nginx1 -mount type=bind, source="$&#123;PWD&#125;" ,target=/usr/share/nginx/html/ nginx</span><br></pre></td></tr></table></figure><h2 id="多应用容器化编排"><a href="#多应用容器化编排" class="headerlink" title="多应用容器化编排"></a>多应用容器化编排</h2><p>Docker 被设计为程序容器， 所以每一个容器只应该运行一个程序，但是在实际的项目中会有需要多个程序互相配合一起运行的情况。比如 Web 程序通常包含 cpp、 数据库、 nginX， Redis 等。这些程序各自的容器需要协同工作， 并且需要能够互相访问网络。比如 cpp 需要连接数据库，nginx 需要能访问 cpp 才能给它做反向代理。</p><p>由于 Docker 容器是一个隔离的环境， 正常情况下容器与容器之间是无法互相访问的，为了应对复杂工程的需要， 我们可以手动配置多容器之间的虚拟网络，文件互访等功能来实现容器交互，但 Docker 官方推出了Compose 程序用于配置管理多容器的运行。</p><p>Compose 通过一个单独的 docker-compose.yml 配量文件来管理一组容器，参下。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示这是 compose 配置文件第三版</span></span><br><span class="line">version: <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个服务都是一个 Docker 容器</span></span><br><span class="line"><span class="comment"># 所以必须用 image 指定服务的镜像名或者从 Dockerfile 中 build 镜像</span></span><br><span class="line">services:</span><br><span class="line">  pyweb:</span><br><span class="line">    <span class="comment"># build 指定了 Dockerfile 所在的路径</span></span><br><span class="line">    build: .</span><br><span class="line">    <span class="comment"># ports 指定暴露的端口，9000 是宿主机，5000 是容器</span></span><br><span class="line">    <span class="comment"># 可以指定多个暴露端口</span></span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"9000:5000"</span></span><br><span class="line">    <span class="comment"># volumes 参数把当前目录挂载到容器的 /code</span></span><br><span class="line">    <span class="comment"># docker-compose 的配置中才支持相对路径的挂载</span></span><br><span class="line">    volumes:</span><br><span class="line">      - .:/code</span><br><span class="line">    <span class="comment"># depends_on 设定了依赖，这里 redisdemo 会先于 pyweb 启动</span></span><br><span class="line">    <span class="comment"># 但是如果 redisdemo 启动时间长于 pyweb</span></span><br><span class="line">    <span class="comment"># 那么 pyweb 运行的时候 redisdemo 未必可用</span></span><br><span class="line">    depends_on:</span><br><span class="line">      - redisdemo</span><br><span class="line"></span><br><span class="line">  redisdemo:</span><br><span class="line">    <span class="comment"># 每个服务必须用 image 指定镜像名或者从 Dockerfile 中 build</span></span><br><span class="line">    <span class="comment"># 这里用 image 指定镜像，redis:alpine 是 redis 项目的官方 Docker 镜像</span></span><br><span class="line">    image: <span class="string">"redis:alpine"</span></span><br></pre></td></tr></table></figure><p>使用如下命令开启服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><p>用 -d 参数让项目后台运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-comuose up -d</span><br></pre></td></tr></table></figure><p>用 stop 暂停容器的运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-comuose up -d</span><br></pre></td></tr></table></figure><p>用 down 关闭并删除项目的所有容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><p>如果我们修改了文件代码后，要重新启动项目时，再次运行<code>docker-compose up</code>，会发现它并末重新构建镜像。这是因为 Dockerfile 并末修改， 所以 Docker 复用了已有的镜像，修改并末生效。这时候我们应该重新构建镜像并运行, 或者加上 “build 参数来强制 build<code>docker-compose up &quot;build</code>。</p><h2 id="Docker使用的小trick"><a href="#Docker使用的小trick" class="headerlink" title="Docker使用的小trick"></a>Docker使用的小trick</h2><h3 id="Docker更换镜像源"><a href="#Docker更换镜像源" class="headerlink" title="Docker更换镜像源"></a>Docker更换镜像源</h3><p>将下载在源改为中科大镜像源等国内源，可以显著提高下载速度。<a href="https://docker.mirrors.ustc.edu.cn，具体修改方式见下图。" target="_blank" rel="noopener">https://docker.mirrors.ustc.edu.cn，具体修改方式见下图。</a></p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fyiofzej25j30dq0h8401.jpg" alt=""></p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fyiog8e1dcj30rg0v8n07.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;镜像和容器&quot;&gt;&lt;a href=&quot;#镜像和容器&quot; class=&quot;headerlink&quot; title=&quot;镜像和容器&quot;&gt;&lt;/a&gt;镜像和容器&lt;/h2&gt;&lt;p&gt;镜像和容器是 Docker 中最基本的 2 个概念，镜像相当于光盘， 光盘里面存储的数据是只读的， 不会被更改的。我
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>容器化搭建Go-Web应用</title>
    <link href="http://yyhyplxyz.github.io/2018/12/23/%E5%AE%B9%E5%99%A8%E5%8C%96%E6%90%AD%E5%BB%BAGo-Web%E5%BA%94%E7%94%A8/"/>
    <id>http://yyhyplxyz.github.io/2018/12/23/容器化搭建Go-Web应用/</id>
    <published>2018-12-23T04:13:00.000Z</published>
    <updated>2018-12-23T09:03:44.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="改用Mysql数据库"><a href="#改用Mysql数据库" class="headerlink" title="改用Mysql数据库"></a>改用Mysql数据库</h2><p>本次作业要求改<code>BoltDB</code>为<code>Mysql</code>数据库，同时，考虑到后面的作业要求搭建博客。因此将之前写的新闻应用做了重构，改成了一个博客后台。</p><p>使用了<code>Beggo</code>框架自带的<code>ORM</code>。个人感觉这类框架内部封装好了很多逻辑，实现功能会比<code>boltdb</code>的键值对操作要容易很多。下面以用户类别为例分别对增删改查四个操作作出解释。</p><p><code>User</code>的模型类别如下，我们可以像下面这样指定对应数据库的列要求。如主键<code>pk</code>，自增<code>auto</code>，可以为空null与不可重复<code>uniqu</code>e等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Id        <span class="keyword">int</span>       <span class="string">`orm:"pk;auto"`</span></span><br><span class="line">  Username  <span class="keyword">string</span>    <span class="string">`orm:"unique"`</span></span><br><span class="line">  Password  <span class="keyword">string</span></span><br><span class="line">  Token     <span class="keyword">string</span>    <span class="string">`orm:"unique"`</span></span><br><span class="line">  Avatar    <span class="keyword">string</span></span><br><span class="line">  Email     <span class="keyword">string</span>    <span class="string">`orm:"null"`</span></span><br><span class="line">  Url       <span class="keyword">string</span>    <span class="string">`orm:"null"`</span></span><br><span class="line">  Signature <span class="keyword">string</span>    <span class="string">`orm:"null;size(1000)"`</span></span><br><span class="line">  InTime    time.Time <span class="string">`orm:"auto_now_add;type(datetime)"`</span></span><br><span class="line">  Roles     []*Role   <span class="string">`orm:"rel(m2m)"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>增加操作</p><p>在用户注册页面，当我们根据用户的输入构建好了<code>user</code>类后，就可以通过如下函数进行用户的创建，注册。</p><p><code>orm</code>是单例模式，如下一行简单的<code>insert</code>就做到了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SaveUser</span><span class="params">(user *User)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">  o := orm.NewOrm()</span><br><span class="line">  id, _ := o.Insert(user)</span><br><span class="line">  <span class="keyword">return</span> id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除操作</p><p>实际博客应用中很少删除用户，为了演示使用下面的函数。同样的传入<code>user</code>类后，一行简单的<code>delete</code>就做到了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeleteUser</span><span class="params">(user *User)</span></span> &#123;</span><br><span class="line">  o := orm.NewOrm()</span><br><span class="line">  o.Delete(user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改操作</p><p>如上，因为指定了<code>id</code>为主键，所以<code>update</code>的时候会查找主键相同的，再进行修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateUser</span><span class="params">(user *User)</span></span> &#123;</span><br><span class="line">  o := orm.NewOrm()</span><br><span class="line">  o.Update(user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查找操作</p><p>查找的语句较麻烦，我们需要指定一个数据表，指明过滤的字段和条件，并将<code>user</code>类型指针传入以获得查找到的结果。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Login</span><span class="params">(username <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">bool</span>, User)</span></span> &#123;</span><br><span class="line">  o := orm.NewOrm()</span><br><span class="line">  <span class="keyword">var</span> user User</span><br><span class="line">  err := o.QueryTable(user).Filter(<span class="string">"Username"</span>, username).One(&amp;user)</span><br><span class="line">  <span class="keyword">return</span> err != orm.ErrNoRows, user</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了上述的操作外，我们还可以用数据库原生语句来执行命令。如下以增删为例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeleteUserRolesByUserId</span><span class="params">(user_id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  o := orm.NewOrm()</span><br><span class="line">  o.Raw(<span class="string">"delete from user_roles where user_id = ?"</span>, user_id).Exec()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SaveUserRole</span><span class="params">(user_id <span class="keyword">int</span>, role_id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  o := orm.NewOrm()</span><br><span class="line">  o.Raw(<span class="string">"insert into user_roles (user_id, role_id) values (?, ?)"</span>, user_id, role_id).Exec()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们构建好了<code>model</code>后，就可以注册数据库了。</p><p>如下我们需要指明数据库的地址，用户名，密码数据库名，通过<code>orm.RegisterDataBase</code>注册数据库，通过<code>orm.RegisterDriver</code>注册<code>mysql</code>驱动。之后我们还需要依次注册各个<code>model</code>，并同步数据库<code>orm.RunSyncdb</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    orm.RegisterDriver(<span class="string">"mysql"</span>, orm.DR_MySQL)</span><br><span class="line">  orm.RegisterDataBase(<span class="string">"default"</span>, <span class="string">"mysql"</span>, username+<span class="string">":"</span>+password+<span class="string">"@tcp("</span>+url+<span class="string">":"</span>+port+<span class="string">")/pybbs?charset=utf8&amp;parseTime=true&amp;charset=utf8&amp;loc=Asia%2FShanghai"</span>, <span class="number">30</span>)</span><br><span class="line">  orm.RegisterModel(</span><br><span class="line">    <span class="built_in">new</span>(models.User),</span><br><span class="line">    <span class="built_in">new</span>(models.Topic),</span><br><span class="line">    <span class="built_in">new</span>(models.Section),</span><br><span class="line">    <span class="built_in">new</span>(models.Reply),</span><br><span class="line">    <span class="built_in">new</span>(models.ReplyUpLog),</span><br><span class="line">    <span class="built_in">new</span>(models.Role),</span><br><span class="line">    <span class="built_in">new</span>(models.Permission))</span><br><span class="line">  orm.RunSyncdb(<span class="string">"default"</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/var/folders/27/4j7qwl0n383_wdy85h_txrzr0000gn/T/abnerworks.Typora/image-20181223125936969.png" alt="image-20181223125936969"></p><h2 id="Docker构建容器"><a href="#Docker构建容器" class="headerlink" title="Docker构建容器"></a>Docker构建容器</h2><ul><li><p><code>mysql</code>镜像</p><p>我们在安装了<code>docker</code>后，首先将<code>mysql</code>镜像下载下来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.6</span><br></pre></td></tr></table></figure><p>接着我们可以查看到已有的镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images |grep mysql</span><br></pre></td></tr></table></figure><p>然后开启<code>mysql</code>容器，并指定各类配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mymysql -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6</span><br></pre></td></tr></table></figure><ul><li><strong>-p 3306:3306</strong>：将容器的 3306 端口映射到主机的 3306 端口。</li><li><strong>-v ~/conf:/etc/mysql/conf.d</strong>：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。</li><li><strong>-v ~/logs:/logs</strong>：将主机当前目录下的 logs 目录挂载到容器的 /logs。</li><li><strong>-v ~/data:/var/lib/mysql</strong> ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。</li><li><strong>-e MYSQL_ROOT_PASSWORD=123456：</strong>初始化 root 用户的密码。</li></ul></li><li><p><code>node</code>镜像</p><p>接下来开启前端镜像，以下我们使用dockerfiles，进入项目目录。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装node镜像</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">7.8</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 app 目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span> /app</span><br><span class="line"></span><br><span class="line"># 安装 app 依赖</span><br><span class="line"></span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line">#暴露端口</span><br><span class="line">EXPOSE 8080</span><br><span class="line">#运行命令</span><br><span class="line">CMD [ "npm", "run" ,"dev"]</span><br></pre></td></tr></table></figure><p>然后我们创建<code>docker</code>镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t web_front .</span><br></pre></td></tr></table></figure><p>并运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 -d web_front</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fygsdr5ec1j30q20cqae0.jpg" alt=""></p></li><li><p>go镜像</p><p>接下来我们同样进入<code>web</code>后端目录，创建<code>dockerfile</code>。</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装go镜像</span></span><br><span class="line"><span class="keyword">FROM</span> golang:latest</span><br><span class="line"><span class="comment"># 创建 应用 目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span> $GOPATH/src/web_pro</span><br><span class="line">ADD . $GOPATH/src/web_pro</span><br><span class="line">#安装依赖</span><br><span class="line">RUN go get github.com/astaxie/beego</span><br><span class="line">RUN go get github.com/beego/bee</span><br><span class="line">RUN go build .</span><br><span class="line">#暴露端口</span><br><span class="line">EXPOSE 8080</span><br><span class="line">#运行命令</span><br><span class="line">CMD [ "bee", "run" ]</span><br></pre></td></tr></table></figure><p>然后我们创建<code>docker</code>镜像，并运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t web_pro .</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 -d web_pro</span><br></pre></td></tr></table></figure><p><img src="/var/folders/27/4j7qwl0n383_wdy85h_txrzr0000gn/T/abnerworks.Typora/image-20181223170149382.png" alt="image-20181223170149382"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;改用Mysql数据库&quot;&gt;&lt;a href=&quot;#改用Mysql数据库&quot; class=&quot;headerlink&quot; title=&quot;改用Mysql数据库&quot;&gt;&lt;/a&gt;改用Mysql数据库&lt;/h2&gt;&lt;p&gt;本次作业要求改&lt;code&gt;BoltDB&lt;/code&gt;为&lt;code&gt;Mysql
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>net/http 源码略读</title>
    <link href="http://yyhyplxyz.github.io/2018/11/16/net-http-%E6%BA%90%E7%A0%81%E7%95%A5%E8%AF%BB/"/>
    <id>http://yyhyplxyz.github.io/2018/11/16/net-http-源码略读/</id>
    <published>2018-11-16T03:44:22.000Z</published>
    <updated>2018-11-16T04:11:53.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="net-http-源码略读"><a href="#net-http-源码略读" class="headerlink" title="net/http 源码略读"></a>net/http 源码略读</h2><h4 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h4><p>​    网络发展，很多网络应用都是构建再 HTTP 服务基础之上。HTTP 协议从诞生到现在，发展从1.0，1.1到2.0也不断再进步。理解 HTTP 构建的网络应用只要关注两个端—客户端（clinet）和服务端（server），两个端的交互来自 clinet 的 request，以及server端的response。所谓的http服务器，主要在于如何接受 clinet 的 request，并向client返回response。</p><h4 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h4><p>​    以下是最简单的使用net/http库构建的web服务器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">handler := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello golang\n"</span>))</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, handler)</span><br><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    根据以上的代码，发现主要的是三个部分<code>HandleFunc</code>，<code>ResponseWriter</code>和<code>ListenAndServe</code>。下面将分别解释这三个部分。</p><p>####<code>HandleFunc</code> </p><p>​    实际上<code>http.HandleFunc</code>封装自<code>ServeMux</code>的HandleFunc方法。见如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">pattern <span class="keyword">string</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    接收request的过程中，最重要的莫过于路由（<code>router</code>），这就是内置的<code>DefautServeMux</code>，也可以自定义。Multiplexer路由的目的就是为了找到处理器函数（<code>handler</code>），后者将对request进行处理，同时构建response。Golang中的<code>Multiplexer</code>基于<code>ServeMux</code>结构，同时也实现了<code>Handler</code>接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">mu sync.RWMutex</span><br><span class="line">m <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry</span><br><span class="line">hosts <span class="keyword">bool</span> <span class="comment">// 决定是否会保存主机名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">explicit <span class="keyword">bool</span></span><br><span class="line">h Handler <span class="comment">//控制器</span></span><br><span class="line">pattern <span class="keyword">string</span> <span class="comment">//路由</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    其中<code>mu</code>字段是读写锁，用于并发读写的数据同步。在并发的时候保证了数据的一致性。<code>m</code>字段是一个字典数据结构，可以看到muxEntry才是路由的保存的地方，也就是一个路径对应一个<code>urlhandler</code>。</p><h4 id="ResponseWriter"><a href="#ResponseWriter" class="headerlink" title="ResponseWriter"></a><code>ResponseWriter</code></h4><p>​    <code>ResponseWriter</code>是一个接口，主要部分就是下面列的三个</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ResponseWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">   Header() Header</span><br><span class="line">   Write([]<span class="keyword">byte</span>) (<span class="keyword">int</span>, error)</span><br><span class="line">   WriteHeader(statusCode <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    其中，Header会返回Http头部内容，write和writeHeader就主要负责写入具体内容到报文。</p><h4 id="ListenAndServe"><a href="#ListenAndServe" class="headerlink" title="ListenAndServe"></a><code>ListenAndServe</code></h4><p>​    在<code>http.ListenAndServe(&quot;:8080&quot;, nil)</code>上，服务器会触发对应模式的handler。</p><p>其具体实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// 只要实现了ServeHTTP接口就可以用作handler作为ListenAndServe的第二个参数</span></span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ResponseWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">Header() Header</span><br><span class="line">Write([]<span class="keyword">byte</span> (<span class="keyword">int</span>, error)</span><br><span class="line">WriteHeader(<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(add <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// server内部有一种方法找到我们先前注册的handler</span></span><br><span class="line">server := &amp;Server&#123;Addr: addr, Handler: Handler&#125; </span><br><span class="line"><span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">Addr <span class="keyword">string</span></span><br><span class="line">Handler Handler</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">包括其他的Server控制参数，包括时间相关的参数</span></span><br><span class="line"><span class="comment">Header大小、状态、日志、运输层安全。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">mu sync.Mutex</span><br><span class="line">listeners <span class="keyword">map</span>[net.Listener]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// TCP 底层的连接池</span></span><br><span class="line"><span class="comment">// 保存HTTP长连接，看HTTP协议版本和HTTP首部字段中的`Connection`的状体</span></span><br><span class="line"><span class="comment">// 注意map的值是struct&#123;&#125;类型,保证可以存储各类控制handler</span></span><br><span class="line">activeConn <span class="keyword">map</span>[*conn]<span class="keyword">struct</span>&#123;&#125; </span><br><span class="line">doneChan <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// Server的停止、关闭控制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServe</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 忽略细节性代码</span></span><br><span class="line">addr := srv.Addr</span><br><span class="line">ln, err := net.Listen(<span class="string">"tcp"</span>, addr) <span class="comment">// 创建tcp连接，addr为监听地址"ip:port"形式的字符串</span></span><br><span class="line"><span class="keyword">return</span> srv.Serve(tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;)</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>总而言之，web服务器的基本流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Clinet -&gt; Requests -&gt;  [Multiplexer(router)] -&gt; handler  -&gt; Response -&gt; Clinet</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;net-http-源码略读&quot;&gt;&lt;a href=&quot;#net-http-源码略读&quot; class=&quot;headerlink&quot; title=&quot;net/http 源码略读&quot;&gt;&lt;/a&gt;net/http 源码略读&lt;/h2&gt;&lt;h4 id=&quot;基本架构&quot;&gt;&lt;a href=&quot;#基本架构&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>go语言并发爬虫</title>
    <link href="http://yyhyplxyz.github.io/2018/10/04/go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E7%88%AC%E8%99%AB/"/>
    <id>http://yyhyplxyz.github.io/2018/10/04/go语言并发爬虫/</id>
    <published>2018-10-04T04:48:59.000Z</published>
    <updated>2018-11-03T15:47:14.067Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则表达式的使用"><a href="#正则表达式的使用" class="headerlink" title="正则表达式的使用"></a>正则表达式的使用</h2><pre><code>正则表达式是一种进行模式匹配和文本操纵的复杂而又强大的工具。虽然正则表达式比纯粹的文本匹配效率低，但是它却更灵活。按照它的语法规则，随需构造出的匹配模式就能够从原始文本中筛选出几乎任何你想要得到的字符组合。Go语言通过`regexp`标准包为正则表达式提供了官方支持，`regexp`包中含有三个函数用来判断是否匹配，如果匹配返回true，否则返回false</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Match</span><span class="params">(pattern <span class="keyword">string</span>, b []<span class="keyword">byte</span>)</span> <span class="params">(matched <span class="keyword">bool</span>, error error)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">MatchReader</span><span class="params">(pattern <span class="keyword">string</span>, r io.RuneReader)</span> <span class="params">(matched <span class="keyword">bool</span>, error error)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">MatchString</span><span class="params">(pattern <span class="keyword">string</span>, s <span class="keyword">string</span>)</span> <span class="params">(matched <span class="keyword">bool</span>, error error)</span></span></span><br></pre></td></tr></table></figure><pre><code>上面的三个函数实现了同一个功能，就是判断`pattern`是否和输入源匹配，匹配的话就返回true，如果解析正则出错则返回error。三个函数的输入源分别是byte slice、RuneReader和string。</code></pre><p>如果要验证一个输入是不是IP地址，那么如何来判断呢？请看如下实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsIP</span><span class="params">(ip <span class="keyword">string</span>)</span> <span class="params">(b <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> m, _ := regexp.MatchString(<span class="string">"^[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;$"</span>, ip); !m &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>regexp</code>的pattern和我们平常使用的正则一模一样。</p><h2 id="爬虫基础"><a href="#爬虫基础" class="headerlink" title="爬虫基础"></a>爬虫基础</h2><pre><code>爬虫程序从一个网页开始，获取它的内容之后，可以根据xml或者xpath包找到对应的元素，然后利用上文提到的正则表达式提取一些关键数据。通常爬虫程序在一个网页中找到URL，会继续抓取该URL的内容，继续找URL，再继续抓取它的内容。下面我们演示下利用http库来模拟对浏览器发出请求，并获得响应。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/http/httputil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">request, err := http.NewRequest(</span><br><span class="line">http.MethodGet,</span><br><span class="line"><span class="string">"http://www.baidu.com"</span>, <span class="literal">nil</span>)</span><br><span class="line">request.Header.Add(<span class="string">"User-Agent"</span>,</span><br><span class="line"><span class="string">"Mozilla/5.0 (iPhone; CPU iPhone OS 10_3 like Mac OS X) AppleWebKit/602.1.50 (KHTML, like Gecko) CriOS/56.0.2924.75 Mobile/14E5239e Safari/602.1"</span>)</span><br><span class="line"></span><br><span class="line">client := http.Client&#123;</span><br><span class="line">CheckRedirect: <span class="function"><span class="keyword">func</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">req *http.Request,</span></span></span><br><span class="line"><span class="function"><span class="params">via []*http.Request)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Redirect:"</span>, req)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">resp, err := client.Do(request)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">s, err := httputil.DumpResponse(resp, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>因此爬虫程序的基本原理如下。初始化seed把请求链接给Engine，然后Engine将url维护为一个任务队列，从任务队列中源源不断的取出任务交个Fetcher获得页面内容，再交给Parser获得数据以及其他的任务链接。最后再把这些链接存入任务队列中。</code></pre><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwv9cwuedrj318a0majvo.jpg" alt=""></p><h2 id="Go语言并发编程"><a href="#Go语言并发编程" class="headerlink" title="Go语言并发编程"></a>Go语言并发编程</h2><pre><code>GO语言原生支持协程，可以在一个或多个线程中开启多个协程。主函数main其实也是个协程。Go语言中的协程叫goroutine，Go标准库提供的调用操作，IO操作都会出让CPU给其他goroutine，让协程间的切换管理不依赖系统的线程和进程，不依赖CPU的核心数量。我们可以把它粗略的看成是个简单的线程</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123; <span class="comment">//i是函数的形式变量</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Hello from "</span>+</span><br><span class="line"><span class="string">"goroutine %d\n"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i) <span class="comment">//来源于主函数中的ii</span></span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Minute)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>协程的引入是为了并发编程，提高效率。并发编程的难度在于协调，协调需要通过通信，并发通信模型分为共享数据和消息。共享数据即多个并发单元保持对同一个数据的引用，数据可以是内存数据块，磁盘文件，网络数据等。数据共享通过加锁的方式来避免死锁和资源竞争。**Go**语言则采取消息机制来通信，每个并发单元是独立的个体，有独立的变量，不同并发单元间这些变量不共享，每个并发单元的输入输出只通过消息的方式。下面的代码详细解释了channel的原理</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、channel声明，声明一个管道chanName，该管道可以传递的类型是ElementType</span></span><br><span class="line"><span class="comment">//管道是一种复合类型，[chan ElementType],表示可以传递ElementType类型的管道[类似定语从句的修饰方法]</span></span><br><span class="line"><span class="keyword">var</span> chanName <span class="keyword">chan</span> ElementType</span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span>                  <span class="comment">//声明一个可以传递int类型的管道</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">chan</span> <span class="keyword">bool</span>      <span class="comment">//声明一个map，值的类型为可以传递bool类型的管道</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//2、初始化</span></span><br><span class="line">ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)   <span class="comment">//make一般用来声明一个复合类型，参数为复合类型的属性</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//3、管道写入,把值想象成一个球，"&lt;-"的方向，表示球的流向，ch即为管道</span></span><br><span class="line"><span class="comment">//写入时，当管道已满（管道有缓冲长度）则会导致程序堵塞，直到有goroutine从中读取出值</span></span><br><span class="line">ch &lt;- value</span><br><span class="line"><span class="comment">//管道读取，"&lt;-"表示从管道把球倒出来赋值给一个变量</span></span><br><span class="line"><span class="comment">//当管道为空，读取数据会导致程序阻塞，直到有goroutine写入值</span></span><br><span class="line">value:= &lt;-ch </span><br><span class="line"> </span><br><span class="line"><span class="comment">//4、每个case必须是一个IO操作，面向channel的操作，只执行其中的一个case操作，一旦满足则结束select过程</span></span><br><span class="line"><span class="comment">//面向channel的操作无非三种情况：成功读出；成功写入；即没有读出也没有写入</span></span><br><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-chan1:</span><br><span class="line">  <span class="comment">//如果chan1读到数据，则进行该case处理语句</span></span><br><span class="line">  <span class="keyword">case</span> chan2&lt;<span class="number">-1</span>:</span><br><span class="line">  <span class="comment">//如果成功向chan2写入数据，则进入该case处理语句</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  <span class="comment">//如果上面都没有成功，则进入default处理流程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并发爬虫的实现"><a href="#并发爬虫的实现" class="headerlink" title="并发爬虫的实现"></a>并发爬虫的实现</h2><pre><code>在上文提到的普通爬虫的基础上，我们可以利用并发编程的原理改进成并发爬虫。这是因为Fetcher会耗时较多，造成其它任务的阻塞。并发爬虫的逻辑框架如下，其中worker会读取页面内容，并对页面内容做解析，request队列即是任务队列。我们为每个request构建goroutine，并为每个work构建goroutine，协程和协程间通过channel通信，当有worker的协程空闲时，就会承担某个request的协程的任务。当无法为某个request搭配一个worker时就会堵塞下去。</code></pre><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv9d3ys3lj31cm0lutcq.jpg" alt=""></p><p>具体的我们实现的时候要实现以下几个部件。</p><ul><li>Engine。用于不断的创建协程，根据url判重来发起request，并将request传给scheduler。</li><li>Scheduler。用于维护request队列和创建worker的协程，并维护worker队列。</li><li>Worker。构建页面解析函数，用于解析页面获得新的url以及得到我们想要的数据</li></ul><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv8z8u90bj30nc0d5acy.jpg" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> scheduler</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"scrawl/types"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Request队列和Worker队列</span></span><br><span class="line"><span class="keyword">type</span> QueuedScheduler <span class="keyword">struct</span> &#123;</span><br><span class="line">requestChan <span class="keyword">chan</span> types.Request</span><br><span class="line">workChan    <span class="keyword">chan</span> <span class="keyword">chan</span> types.Request</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *QueuedScheduler)</span> <span class="title">Submit</span><span class="params">(r types.Request)</span></span> &#123;</span><br><span class="line">s.requestChan &lt;- r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *QueuedScheduler)</span> <span class="title">WorkerChan</span><span class="params">()</span> <span class="title">chan</span> <span class="title">types</span>.<span class="title">Request</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make</span>(<span class="keyword">chan</span> types.Request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *QueuedScheduler)</span> <span class="title">WorkerReady</span><span class="params">(w <span class="keyword">chan</span> types.Request)</span></span> &#123;</span><br><span class="line">s.workChan &lt;- w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *QueuedScheduler)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">s.workChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> types.Request)</span><br><span class="line">s.requestChan = <span class="built_in">make</span>(<span class="keyword">chan</span> types.Request)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> requestQ []types.Request</span><br><span class="line"><span class="keyword">var</span> workQ []<span class="keyword">chan</span> types.Request</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> activeRequest types.Request</span><br><span class="line"><span class="keyword">var</span> activeWorker <span class="keyword">chan</span> types.Request</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(requestQ) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(workQ) &gt; <span class="number">0</span> &#123;</span><br><span class="line">activeWorker = workQ[<span class="number">0</span>]</span><br><span class="line">activeRequest = requestQ[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> r := &lt;-s.requestChan:</span><br><span class="line">requestQ = <span class="built_in">append</span>(requestQ, r)</span><br><span class="line"><span class="keyword">case</span> w := &lt;-s.workChan:</span><br><span class="line">workQ = <span class="built_in">append</span>(workQ, w)</span><br><span class="line"><span class="keyword">case</span> activeWorker &lt;- activeRequest:</span><br><span class="line">workQ = workQ[<span class="number">1</span>:]</span><br><span class="line">requestQ = requestQ[<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码见github <a href="https://github.com/zys980808/Agenda-Go" target="_blank" rel="noopener">https://github.com/zys980808/Agenda-Go</a> 中的并发爬虫文件夹内</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;正则表达式的使用&quot;&gt;&lt;a href=&quot;#正则表达式的使用&quot; class=&quot;headerlink&quot; title=&quot;正则表达式的使用&quot;&gt;&lt;/a&gt;正则表达式的使用&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;正则表达式是一种进行模式匹配和文本操纵的复杂而又强大的工具。虽然正则表达式比
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>go语言实现selpg</title>
    <link href="http://yyhyplxyz.github.io/2018/10/04/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0selpg/"/>
    <id>http://yyhyplxyz.github.io/2018/10/04/go语言实现selpg/</id>
    <published>2018-10-04T04:42:43.000Z</published>
    <updated>2018-10-04T06:06:44.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h2><p>selpg是一个unix系统下命令。</p><p>该命令本质上就是将一个文件，通过自己设定的分页方式，输出到屏幕或者重定向到其他文件上，或者利用打印机打印出来。使用格式如下。</p><p><code>-s start_page -e end_page [ -f | -l lines_per_page ][ -d dest ] [ in_filename ]</code></p><p>必需标志以及参数：</p><ul><li>-s，后面接开始读取的页号 int</li><li>-e，后面接结束读取的页号 int<br> s和e都要大于1，并且s &lt;= e，否则提示错误</li></ul><p>可选参数：</p><ul><li>-l，后面跟行数 int，代表多少行分为一页，不指定 -l 又缺少 -f 则默认按照72行分一页</li><li>-f，该标志无参数，代表按照分页符’\f’ 分页</li><li>-d，后面接打印机名称，用于打印</li><li>filename，唯一一个无标识参数，代表选择读取的文件名</li></ul><h2 id="flag包解析参数"><a href="#flag包解析参数" class="headerlink" title="flag包解析参数"></a>flag包解析参数</h2><p>flag库是一个简单的解析参数的函数包，使用它会比使用os函数包解析字符串来获得程序运行参数简单很多。我们可以使用flag.XxxxxVar方法来实现参数的获取，该函数第一个传递值是某个自己定义的变量的指针，第二个传递值是我们给程序的某个参数，第三个传递值是在该参数没有给出时，我们设定的默认值，第四个参数是一个参数说明。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag.IntVar(&amp;pagestart, <span class="string">"s"</span>, <span class="number">-1</span>, <span class="string">"the start page"</span>)</span><br><span class="line">flag.IntVar(&amp;pageend, <span class="string">"e"</span>, <span class="number">-1</span>, <span class="string">"The end page"</span>)</span><br><span class="line">flag.IntVar(&amp;lineperpage, <span class="string">"l"</span>, <span class="number">72</span>, <span class="string">"the paging form"</span>)</span><br><span class="line">flag.StringVar(&amp;printDest, <span class="string">"d"</span>, <span class="string">""</span>, <span class="string">"The named-printer to print the selected content."</span>)</span><br><span class="line">flag.BoolVar(&amp;separationtype, <span class="string">"f"</span>, <span class="literal">false</span>, <span class="string">"Choose if the input pages should be separated by Formfeed-Character('\\f'). (not compatible with `-l`)"</span>)</span><br></pre></td></tr></table></figure><p>具体的，在我们的程序中，我们将所有变量都声明在var中，flag的参数绑定方法声明在init()函数中，从而让程序一运行就解析参数并绑定到全局变量中。</p><p>为了让程序具有更好的鲁棒性，设计一个检验函数，在输入命令出错时给予提示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> DefaultlineperPage != lineperpage &amp;&amp; separationtype == <span class="literal">true</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> argsinvalid</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> pagestart == <span class="number">-1</span> || pageend == <span class="number">-1</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> valueInvalid</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> pagestart &lt;= <span class="number">0</span> || pagestart &gt; pageend &#123;</span><br><span class="line"><span class="keyword">goto</span> valueInvalid</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> lineperpage &lt;= <span class="number">0</span>&#123;</span><br><span class="line"><span class="keyword">goto</span> valueInvalid</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">argsinvalid:</span><br><span class="line">log.Fatalln(<span class="string">"[Error] ... `-l` is not compatible with `-f`."</span>)</span><br><span class="line">valueInvalid:</span><br><span class="line">log.Fatalln(<span class="string">"[Error] ... Values of `-s` and `-e` are invalid."</span>)</span><br></pre></td></tr></table></figure><h2 id="分页功能"><a href="#分页功能" class="headerlink" title="分页功能"></a>分页功能</h2><p>接下来我们实现具体的文件分页功能，首先我们要根据separtiontype，即是否有<code>-f</code>参数来判断根据换行符还是行数来分页。</p><p>如果是根据行数来判断分页，我们首先利用bufio函数获得我们输入流的缓存，再以换行符为依据读取每行内容，在不需要输出到打印机时，直接利用系统输出流输出到文件或者屏幕即可，否则要将内容暂时存到res这个string变量中。</p><p>如果是根据换行符来判断，则要用<code>readrune</code>函数来读取单个字符，接着输出到标准输出流或者暂时存在内存中，输出到打印机内。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line">rd := bufio.NewReader(myin)</span><br><span class="line"><span class="keyword">if</span> !separationtype &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line"><span class="comment">//d1 := []byte("lineperpage" + string(lineperpage))</span></span><br><span class="line"><span class="comment">//err := ioutil.WriteFile("test.txt", d1, 0644)</span></span><br><span class="line">line, err = rd.ReadString(<span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> || io.EOF == err &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">currLine++</span><br><span class="line"><span class="keyword">if</span> currLine &gt; lineperpage &#123;</span><br><span class="line">currPage++</span><br><span class="line">currLine = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> currPage &gt;= pagestart &amp;&amp; currPage &lt;= pageend &#123;</span><br><span class="line"><span class="comment">// not for printer but to stdout</span></span><br><span class="line"><span class="keyword">if</span> printDest == <span class="string">""</span> &#123;</span><br><span class="line">fmt.Fprintf(myout, <span class="string">"%s"</span>, line)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res += line</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">char, _, err1 := rd.ReadRune()</span><br><span class="line"><span class="keyword">if</span> err1 != <span class="literal">nil</span> || io.EOF == err &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> char == <span class="string">'\f'</span> &#123;</span><br><span class="line">currPage++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> currPage &gt;= pagestart &amp;&amp; currPage &lt;= pageend &#123;</span><br><span class="line"><span class="comment">// output to stdout</span></span><br><span class="line"><span class="keyword">if</span> printDest == <span class="string">""</span> &#123;</span><br><span class="line">fmt.Fprintf(myout, <span class="string">"%c"</span>, char)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res += <span class="keyword">string</span>(char)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h2><p>我们首先要确定输入输出流，如果参数指明了输入文件，我们就要将输入流由标准输入流改为文件输入流，如果出现错误时，打出报错，显示用法，并退出程序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inputrouter</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> inputfile != <span class="string">""</span> &#123;</span><br><span class="line">myin, err = os.Open(inputfile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"selpg: could not open input file \"%s\"\n"</span>, inputfile)</span><br><span class="line">fmt.Println(err)</span><br><span class="line">usage()</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出流一般都是操作系统的标准输出，当指明了输出的打印机时，就要把输出的内容先暂存到内存中，然后通过管道传到lp命令的输入流，再通过lp命令来实现打印功能。这里使用了exec函数库中的cmmand，开启另一个线程来调用系统命令。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">outputrouter</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> printDest != <span class="string">""</span> &#123;</span><br><span class="line">str := fmt.Sprintf(<span class="string">"-d%s"</span>, printDest)</span><br><span class="line">cmd = exec.Command(<span class="string">"lp"</span>, str)</span><br><span class="line">_, err := cmd.Output()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"%s: could not open pipe to \"%s\"\n"</span>, <span class="string">"try"</span>, str)</span><br><span class="line">os.Exit(<span class="number">13</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> printDest != <span class="string">""</span> &#123;</span><br><span class="line">cmd.Stdin = strings.NewReader(res)</span><br><span class="line">cmd.Stdout = myout</span><br><span class="line">err = cmd.Run()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"printing to %s occurs some errors"</span>, printDest)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="程序测试"><a href="#程序测试" class="headerlink" title="程序测试"></a>程序测试</h2><ol><li>文件读取</li></ol><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvw5iugbjsj31kw0wqqav.jpg" alt=""></p><ol><li><p>标准输入输出流</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvw5mi0z5hj319u0emwfl.jpg" alt=""></p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvw5o1haigj31kw0h8tcb.jpg" alt=""></p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvw5o1haigj31kw0h8tcb.jpg" alt=""></p></li></ol><ol><li><p>输出重定向</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvw5p5ljrwj31kw055wft.jpg" alt=""></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;功能简介&quot;&gt;&lt;a href=&quot;#功能简介&quot; class=&quot;headerlink&quot; title=&quot;功能简介&quot;&gt;&lt;/a&gt;功能简介&lt;/h2&gt;&lt;p&gt;selpg是一个unix系统下命令。&lt;/p&gt;
&lt;p&gt;该命令本质上就是将一个文件，通过自己设定的分页方式，输出到屏幕或者重定向
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CentOS下Golang配置</title>
    <link href="http://yyhyplxyz.github.io/2018/09/27/CentOS%E4%B8%8BGolang%E9%85%8D%E7%BD%AE/"/>
    <id>http://yyhyplxyz.github.io/2018/09/27/CentOS下Golang配置/</id>
    <published>2018-09-27T15:04:18.000Z</published>
    <updated>2018-09-27T15:37:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Go环境配置"><a href="#Go环境配置" class="headerlink" title="Go环境配置"></a>Go环境配置</h4><p>在上一次作业中我们已经配置好了Centos虚拟机，基于此我们配置安装go环境。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install gloang #利用yum安装go</span><br><span class="line">go version #查看go版本</span><br><span class="line">rpm -ql golang |more #查看go安装的路径</span><br></pre></td></tr></table></figure><p>安装完毕后，我们需要配置环境变量，令我们在终端中可以使用go命令。</p><p>首先我们要了解下go语言的工作空间。工作空间，应该由 /bin, /src/, /pkg 三个文件夹组成。三个文件夹的作用如下：</p><table><thead><tr><th>Folder</th><th>Usage</th></tr></thead><tbody><tr><td>bin</td><td>存放编译后的程序包</td></tr><tr><td>pkg</td><td>存放编译生成的对象文件</td></tr><tr><td>src</td><td>外部库/源文件</td></tr></tbody></table><p>因此我们接下来将创建工作空间和工作空间内的三个文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir $HOME/gowork #创建名为gowork的工作空间</span><br><span class="line">mkdir $HOME/gowork/bin #以下分别创建三个不同作用的文件夹</span><br><span class="line">mkdir $HOME/gowork/pkg</span><br><span class="line">mkdir $HOME/gowork/src</span><br></pre></td></tr></table></figure><p>然后我们就要用命令行开始配置环境变量啦</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile #打开该文件</span><br></pre></td></tr></table></figure><p>我们在文件中添加下面两个语句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=$HOME/gowork</span><br><span class="line">export PATH=$PATH:$GOAPTH/bin</span><br></pre></td></tr></table></figure><p>接着我们输入<code>source /etc/profile</code>使变量生效。</p><p>输入<code>cd $GOPATH</code>，看是否进入了工作空间，即gowork文件夹，来判断是否设置成功。</p><p>但是这个只在当前 终端 生效，退出或新开终端则无用。因此我们可以在 .bashrc 文件中设置其永久生效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bashrc</span><br></pre></td></tr></table></figure><p>在里面加一句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>最后，我们输入<code>go env</code>，终端会输出go的所有环境配置，如下图所示</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fvoiv4i5o2j30m60go0u6.jpg" alt=""></p><h4 id="编辑工具下载安装"><a href="#编辑工具下载安装" class="headerlink" title="编辑工具下载安装"></a>编辑工具下载安装</h4><p>在安装好go之后，我们需要一个好用的代码编写工具，这里我们选用了vscode，按照官网上的安装教程输入如下命令进行安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc</span><br><span class="line">sudo sh -c 'echo -e "[code]\nname=Visual Studio Code\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc" &gt; /etc/yum.repos.d/vscode.repo' # configure the code repo</span><br><span class="line">yum check-update</span><br><span class="line">sudo yum install code</span><br></pre></td></tr></table></figure><p>在 vscode中我们需要安装Go的工具，但是因为中国网络环境可能无法直接访问Golang.org获取，因此我们从github上下载源码，然后进行编译，下面是示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir $GOPATH/src/golang.org/x/ #创建文件夹</span><br><span class="line">go get -d github.com/golang/tools #下载源码</span><br><span class="line">cp $GOPATH/src/github.com/golang/tools $GOPATH/src/golang.org/x/ -rf #复制移动到指定位置</span><br><span class="line">go install golang.org/x/tools/go/buildutil #安装工具包</span><br></pre></td></tr></table></figure><h4 id="第一份Go文件"><a href="#第一份Go文件" class="headerlink" title="第一份Go文件"></a>第一份Go文件</h4><p>我们接下来可以开始编写和运行我们的第一份go文件了，首先我们创建好目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $GOPATH/src/github.com/XXXX/hello</span><br></pre></td></tr></table></figure><p>接着，我们在上述目录中创建新的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code hello.go #使用VSCode新建打开</span><br></pre></td></tr></table></figure><p>添加如下代码，保存并退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Hello, world.\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们回到终端，使用go工具来构建并安装程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run hello.go #运行</span><br><span class="line">go install github.com/github-user/hello  #构建hello命令，添加到bin中</span><br><span class="line">hello #运行安装好的程序，如果$GOPATH/bin 已经添加到PATH中</span><br></pre></td></tr></table></figure><p>可以看到屏幕中会有如下输出</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fvoiv5ha5uj30cn01pt8k.jpg" alt=""></p><h4 id="绑定git仓库"><a href="#绑定git仓库" class="headerlink" title="绑定git仓库"></a>绑定git仓库</h4><p>我们可以将我们的代码推送到远程的git仓库上，首先我们要安装git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install git</span><br><span class="line">git --version    #显示git版本</span><br></pre></td></tr></table></figure><p>安装好git后，我们可以配置git用户名和邮箱</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "Your Name"             #Github用户名</span><br><span class="line">git config --global user.email "email@example.com"    #与Github注册邮箱一致</span><br><span class="line">git config --global credential.helper store  #第一次提交输入密码，之后免密提交</span><br></pre></td></tr></table></figure><p>最后的最后，我们可以在上面创建的hello目录中把代码推送到远程仓库啦</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init  #初始化仓库</span><br><span class="line">git add . #上传修改的文件</span><br><span class="line">git commit -m "initial commit" #提交所有更改</span><br><span class="line">git remote add origin http://github.com/username/project.git  #此处我们首先要在远程建立一个仓库</span><br><span class="line">git push origin master   #将更改提交到远程仓库</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Go环境配置&quot;&gt;&lt;a href=&quot;#Go环境配置&quot; class=&quot;headerlink&quot; title=&quot;Go环境配置&quot;&gt;&lt;/a&gt;Go环境配置&lt;/h4&gt;&lt;p&gt;在上一次作业中我们已经配置好了Centos虚拟机，基于此我们配置安装go环境。&lt;/p&gt;
&lt;figure cl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>搭建私有云桌面</title>
    <link href="http://yyhyplxyz.github.io/2018/09/13/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A/"/>
    <id>http://yyhyplxyz.github.io/2018/09/13/服务计算第一次作业/</id>
    <published>2018-09-13T07:04:19.000Z</published>
    <updated>2018-09-13T11:40:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h2><p>这次我们要利用虚拟机搭建一个自己的私有云，并完成图形化界面的远程控制。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>​    一般意义上我们只要搭建一个linux系统，再让其可以访问公网，则可以简单的称为是一个云服务器了，但这次我们作业是要考虑到一个计算机有多个多个虚拟系统，即令一台计算机充当多个虚拟专享服务器，多个虚拟机间构成子网，多台计算机再通过路由器，交换机构成子网，从而让服务商方便快捷地管理云资源。</p><p>​    我们的作业实现思路就是为虚拟机创建两张虚拟网卡，它们分别构成了一个子网络，一张网卡是NAT模式，另一张网卡是仅主机模式。在NAT模式中，主机网卡直接与虚拟NAT设备相连，然后虚拟NAT设备与虚拟DHCP服务器一起连接在虚拟交换机VMnet8上，这样就实现了虚拟机联通外网。而Host-Only模式将虚拟机与外网隔开，使得虚拟机成为一个独立的系统，只与主机相互通讯，从而构成了一个内网。</p><p>​    主要结构如下。</p><p><img src="http://p35v64prn.bkt.clouddn.com/try4.png" alt="git"></p><h2 id="环境安装配置"><a href="#环境安装配置" class="headerlink" title="环境安装配置"></a>环境安装配置</h2><p>​    我们首先下载<a href="https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html" target="_blank" rel="noopener">VMware软件</a>，网上可以很容易地找到破解码。接着我们可以到高校ftp上下载<a href="https://mirror.tuna.tsinghua.edu.cn/centos/7.5.1804/isos/x86_64/" target="_blank" rel="noopener">centos</a>系统。</p><p>​    软件安装完毕后，我们将系统添加到VMware workstation pro中，随后我们根据提示设置用户名密码等，完成系统安装即可。进入系统后，我们输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmtui</span><br></pre></td></tr></table></figure><p>打开图形化界面然后选择激活网卡，如图所示。</p><p><img src="http://p35v64prn.bkt.clouddn.com/try5.png" alt="git"></p><p><img src="http://p35v64prn.bkt.clouddn.com/try6.png" alt="git"></p><p>接着我们在VMware里添加虚拟网卡，在虚拟机-&gt;设置-&gt;添加硬件-&gt;网络适配器中选择仅主机模式 ，如下图所示</p><p><img src="http://p35v64prn.bkt.clouddn.com/try8.PNG" alt="git"></p><p>此时我们配置了两张网卡，进入系统看下能否ping通百度等网站，如果不成功则需要进行网络开启的操作。运行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/sysconfig/network-scripts/</span><br></pre></td></tr></table></figure><p>打开某个对应系统网卡的文件，不清楚可以使用<code>ifconfig</code>命令来查看网卡和ip。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ifcfg-ens33</span><br></pre></td></tr></table></figure><p>将ONBOOT设置成yes，接着重启网络服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure><p>这样，我们就做到了开机自动启动网络服务，我们可以上网了。</p><p>​    然后，我们更新和安装一些必要的软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum install wegt</span><br><span class="line">yum update</span><br><span class="line"></span><br><span class="line">yum groupinstall "X Window System"</span><br><span class="line">yum groupinstall "GNOME Desktop"</span><br><span class="line">systemctl set-default multi-user.target  //设置成命令模式</span><br><span class="line">systemctl set-default graphical.target  //设置成图形模式</span><br><span class="line">shutdown -r now #重启</span><br></pre></td></tr></table></figure><p>​    此时我们重启后看到的应该是图形化界面了。</p><p>​    接着，我们使用 windows 的远程桌面控制来访问我们的虚拟机。但是 windows 的远程桌面使用 RDP 协议，而 linux 系统原生并不支持此协议。因此我们需要在 linux 系统安装 XRDP 来支持协议。</p><p>- 下载安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">su #图形化界面账号为非root账号，su获取root权限</span><br><span class="line">#root password</span><br><span class="line">yum install epel-release #社区对于yum的补充开源库</span><br><span class="line">yum install xrdp</span><br><span class="line">yum install tigervnc-server</span><br></pre></td></tr></table></figure><p>- 开启 XRDP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start xrdp</span><br><span class="line">systemctl enable xrdp</span><br></pre></td></tr></table></figure><p>XRDP 默认监听的端口号是3389 ，我们远程连接就可以使用这个端口号</p><p>- 关闭防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure><p>- 或不关闭防火墙，添加防火墙例外，打开3389端口命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-port=3389/tcp</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>- 启动xrdp服务，并且设置为开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start xrdp</span><br><span class="line">systemctl enable xrdp</span><br></pre></td></tr></table></figure><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>​    经过了上面的操作步骤后，我们打开远程桌面连接，就可以连接上远程服务器了，实验效果如图所示。</p><p><img src="http://p35v64prn.bkt.clouddn.com/远程控制.PNG" alt="git"></p><p>​    我们需要多个虚拟机的话，那么，刚刚配置的虚拟机，就可以作为 base，我们 clone 这个虚拟机就好了。链接克隆和完整克隆都可以，具体操纵比较简单就不再赘述了，克隆完毕后我们进入新的虚拟机系统，查看ip，同样可以远程连接到这个虚拟机系统上面去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;作业要求&quot;&gt;&lt;a href=&quot;#作业要求&quot; class=&quot;headerlink&quot; title=&quot;作业要求&quot;&gt;&lt;/a&gt;作业要求&lt;/h2&gt;&lt;p&gt;这次我们要利用虚拟机搭建一个自己的私有云，并完成图形化界面的远程控制。&lt;/p&gt;
&lt;h2 id=&quot;基本原理&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SQL期中实验报告</title>
    <link href="http://yyhyplxyz.github.io/2018/03/30/SQL%E6%9C%9F%E4%B8%AD%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <id>http://yyhyplxyz.github.io/2018/03/30/SQL期中实验报告/</id>
    <published>2018-03-29T17:08:42.000Z</published>
    <updated>2018-03-29T17:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库小实验实验报告"><a href="#数据库小实验实验报告" class="headerlink" title="数据库小实验实验报告"></a>数据库小实验实验报告</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">16340274 杨元昊</span><br></pre></td></tr></table></figure><h3 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h3><p>本作业以实现一个基本的学生成绩管理系统为例，从无到有地展示Mysql数据库的使用方法，并增进对课程学习内容的理解。</p><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>操作系统 MAC OSX</p><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="安装和初步使用Mysql"><a href="#安装和初步使用Mysql" class="headerlink" title="安装和初步使用Mysql"></a>安装和初步使用Mysql</h4><p>MySQL 是最流行的关系型 DBMS（数据库管理系统）。MySQL 使用 SQL 语言进行操作。在<a href="https://www.mysql.com" target="_blank" rel="noopener">mysql</a>官网上下载软件并安装，安装过程中会设置管理员账号和密码。启动软件后，我们使用如下语句连接数据库，其中 -u 参数是指定用户名，（root是用户名，可自由替代成别的），-p参数是表明该账号要输入密码。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u （root） -p</span><br></pre></td></tr></table></figure><p>接着输入密码后，我们就连接了数据库账户。</p><p>再接着，我们可以查看已有的数据库，并将工作环境切换到某个数据库下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>;</span><br><span class="line"><span class="keyword">use</span> information_schema</span><br></pre></td></tr></table></figure><p>这里要注意三点：</p><ol><li>sql语言是以;作为结束的，但是我们也可以用<code>DELIMITER |</code>这个语句来指定结束标志符换为|。其中|可以自己替换成任意非sql保留字符</li><li>SQL默认是大小写不敏感的，也就是说a和A在sql里被认为是一样的。虽然我们也可以在mysql的配置文件中指定大小写敏感，但从规范性的角度讲，sql的保留字我们通常要用大写，以示区分。</li><li>use + 数据库名字是我目前知道的唯一一个不用加结束符结尾的命令语句，当然了加上也是没错的。</li></ol><h4 id="数据表的增删改查与查询"><a href="#数据表的增删改查与查询" class="headerlink" title="数据表的增删改查与查询"></a>数据表的增删改查与查询</h4><h5 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h5><p>首先，我们可以创建一个数据库，接着指明使用它。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> gradesystem;</span><br><span class="line"><span class="keyword">use</span> gradesystem</span><br></pre></td></tr></table></figure><p>我们在指明了使用的数据库后，可以利用<code>SHOW TABLES;</code>来显示显示已有的表单。此时当然什么都没有啦。</p><p>下一步我们可以来创建表单了。基本的格式是这样的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表的名字</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line"></span><br><span class="line">列名a 数据类型(数据长度),</span><br><span class="line"></span><br><span class="line">列名b 数据类型(数据长度)，</span><br><span class="line"></span><br><span class="line">列名c 数据类型(数据长度)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表的名字(列名a,列名b,列名c) <span class="keyword">VALUES</span>(值<span class="number">1</span>,值<span class="number">2</span>,值<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>数据的类型有挺多的，值得注意的是以下这些类型</p><table><thead><tr><th>数据类型</th><th>大小</th><th>用途</th><th>格式</th></tr></thead><tbody><tr><td>DATE</td><td>3</td><td>日期</td><td>YYYY-MM-DD</td></tr><tr><td>TIME</td><td>3</td><td>时间点或持续时间</td><td>HH:MM:SS</td></tr><tr><td>YEAR</td><td>1</td><td>年份值</td><td>YYYY</td></tr><tr><td>CHAR</td><td>0~255</td><td>定长字符串</td><td></td></tr><tr><td>VARCHAR</td><td>0~255</td><td>变长字符串</td><td></td></tr><tr><td>TEXT</td><td>0~65535</td><td>长文本数据</td></tr></tbody></table><p>Mysql对时间差的函数做了计算优化，所以数据库中有时间变量时，最好用时间类型，而不是int double。</p><p>在实际应用开发中，评论和简介的功能是很常见的，此时选用TEXT类型比较好。</p><p>下面对比下VARCHAR与CHAR，</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VARCHAR score(20) #占据（score实际长度+1）Byte,多的一个Byte用于存放长度值</span><br><span class="line">CHAR score(20)#占据（20）Byte，如果score长度小于20，多出来的Byte都是空白的</span><br></pre></td></tr></table></figure><p>但是值得注意的是，类比内存对齐的概念，VARCHAR中存储的数据长度改变后，容易导致数据存储位置发生改变，对效率有一定影响（具体改变方式视数据库引擎不同而不同）。CHAR则没有这个隐忧，只是会稍微多占用一些存储空间。所以，实际中常将大小不怎么改变的长字符串存储成VARCHAR类型。</p><h5 id="实体／参照完整性"><a href="#实体／参照完整性" class="headerlink" title="实体／参照完整性"></a>实体／参照完整性</h5><h6 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h6><p>主键作为这一行的唯一标识符，不仅可以是表中的一列，也可以由表中的两列或多列来共同标识</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONSTRAINT 你的主键名字 PRIMARY KEY （列名1，列名2）</span><br></pre></td></tr></table></figure><h6 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h6><p>当有 DEFAULT 约束的列，插入数据为空时，将使用默认值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列名a 数据类型(数据长度),DEFAULT '默认值'</span><br></pre></td></tr></table></figure><h6 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h6><p>它规定一张表中指定的一列的值必须不能有重复值，即这一列每个值都是唯一的.</p><p>当 INSERT 语句新插入的数据和已有数据重复的时候，如果有 UNIQUE约束，则 INSERT 失败.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">列名a 数据类型(数据长度),UNIQUE </span><br><span class="line">或UNIQUE(列名)</span><br></pre></td></tr></table></figure><h6 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列名a 数据类型(数据长度),NOT NULL</span><br></pre></td></tr></table></figure><h6 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h6><p>它既能确保数据完整性，也能表现表之间的关系。一个表可以有多个外键，每个外键必须 REFERENCES (参考) 另一个表的主键，被外键约束的列，取值必须在它参考的列中有对应值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOREIGN KEY(列名a) REFERENCES 表名b(b中的列名)</span><br></pre></td></tr></table></figure><h4 id="学生成绩管理系统的构建"><a href="#学生成绩管理系统的构建" class="headerlink" title="学生成绩管理系统的构建"></a>学生成绩管理系统的构建</h4><p>初步的构建是有学生，课程和成绩三张表，互相之间用外键关联。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> gradesystem2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> gradesystem2</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line"><span class="keyword">sid</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">sname <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">gender <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="keyword">sid</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> course(</span><br><span class="line">cid <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">cname <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(cid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mark(</span><br><span class="line"> <span class="keyword">mid</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> <span class="keyword">sid</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">cid <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">score <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="keyword">mid</span>),</span><br><span class="line">FOREIGN <span class="keyword">KEY</span>(<span class="keyword">sid</span>) <span class="keyword">REFERENCES</span> student(<span class="keyword">sid</span>),</span><br><span class="line">FOREIGN <span class="keyword">KEY</span>(cid) <span class="keyword">REFERENCES</span> course(cid)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">'Tom'</span>,<span class="string">'male'</span>),(<span class="number">2</span>,<span class="string">'Jack'</span>,<span class="string">'male'</span>),(<span class="number">3</span>,<span class="string">'Rose'</span>,<span class="string">'female'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> course <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">'math'</span>),(<span class="number">2</span>,<span class="string">'physics'</span>),(<span class="number">3</span>,<span class="string">'chemistry'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mark <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">80</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">85</span>),(<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">90</span>),(<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">60</span>),(<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">90</span>),(<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">75</span>),(<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">95</span>),(<span class="number">8</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">75</span>),(<span class="number">9</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">85</span>);</span><br></pre></td></tr></table></figure><h4 id="数据库中的复杂查询"><a href="#数据库中的复杂查询" class="headerlink" title="数据库中的复杂查询"></a>数据库中的复杂查询</h4><p>查询的基本格式是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 列名 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 列名=*** <span class="keyword">ORDER</span> <span class="keyword">BY</span> 列名 <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> 某数字</span><br></pre></td></tr></table></figure><p>表示降序排列搜出来的结果，搜出来的行数有限制</p><p>查询还有MAX MIN等函数，像dataframe一样的groupby功能，也可以自己设置用户变量，自己在创建成绩系统时并没有用到这些功能，就不赘述了。</p><p>基本查询可以无限制的迭代下去，接下来我们找出物理分数最高的同学，并修改Tom 的化学成绩，下面代码就是一段多重迭代的查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span>,sname,gender <span class="keyword">FROM</span> student </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">sid</span>=(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span> <span class="keyword">FROM</span> mark </span><br><span class="line"><span class="keyword">WHERE</span> score=(</span><br><span class="line"> <span class="keyword">SELECT</span> <span class="keyword">MAX</span>(score) <span class="keyword">FROM</span> mark </span><br><span class="line">        <span class="keyword">WHERE</span> cid=<span class="number">1</span>) </span><br><span class="line"> )</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> mark <span class="keyword">set</span> score= score+<span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> cid=(</span><br><span class="line">    <span class="keyword">select</span> cid</span><br><span class="line">    <span class="keyword">from</span> course </span><br><span class="line">    <span class="keyword">where</span> cname=<span class="string">'chemistry'</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">and</span> <span class="keyword">sid</span>=(</span><br><span class="line">     <span class="keyword">select</span> <span class="keyword">sid</span></span><br><span class="line">     <span class="keyword">from</span> student</span><br><span class="line">     <span class="keyword">where</span> sname=<span class="string">'Tom'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我之前曾经研究过复杂查询的效率问题，<a href="http://yangyuanhao.com/2018/03/14/sql语言初探/#more" target="_blank" rel="noopener">见博客</a>，找出物理分数最高的同学的代码可以修改成以下的，可以提高一些查询效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sid</span>, sname, gender <span class="keyword">FROM</span> student s</span><br><span class="line"><span class="keyword">JOIN</span> mark m</span><br><span class="line"><span class="keyword">on</span> (s.sid=m.sid )</span><br><span class="line"><span class="keyword">where</span> m.cid=<span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="设计触发器"><a href="#设计触发器" class="headerlink" title="设计触发器"></a>设计触发器</h4><p>触发器是指当表上出现特定事件时，将激活该运算，一般用于更新A表的值时自动更新B表的值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name trigger_time trigger_event</span><br><span class="line">    <span class="keyword">ON</span> tabel_name <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> trigger_stmt</span><br></pre></td></tr></table></figure><p><code>trigger_time</code>是触发程序的动作时间。它可以是<code>BEFORE</code>或<code>AFTER</code>，以指明触发程序是在激活它的语句之前或之后触发。</p><p><code>trigger_event</code>指明了激活触发程序的语句的类型。<code>trigger_event</code>可以是下述值之一：</p><ul><li><code>INSERT</code>：将新行插入表时激活触发程序，例如，通过<code>INSERT</code>、<code>LOAD DATA</code>和<code>REPLACE</code>语句实现插入数据。</li><li><code>UPDATE</code>：更改某一行时激活触发程序，例如，通过<code>UPDATE</code>语句更新数据。</li><li><code>DELETE</code>：从表中删除某一行时激活触发程序，例如，通过<code>DELETE</code>和<code>REPLACE</code>语句删除数据。</li></ul><h4 id="设计学生成绩系统的重修成绩单"><a href="#设计学生成绩系统的重修成绩单" class="headerlink" title="设计学生成绩系统的重修成绩单"></a>设计学生成绩系统的重修成绩单</h4><p>我们想用retakingmark这张表来记录学生重修成绩。</p><p>当我们在mark表中更改学生成绩时，自动地更新重修成绩表，并记录第一次考试的原始分数。（此处假定更改成绩只是因为重修或重考）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> retakingmark(</span><br><span class="line">m_mid <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">m_sid <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">m_cid <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">m_score <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">original_score <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">retaking_times <span class="built_in">int</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">m_time  datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(m_mid),</span><br><span class="line">FOREIGN <span class="keyword">KEY</span>(m_sid) <span class="keyword">REFERENCES</span> student(<span class="keyword">sid</span>),</span><br><span class="line">FOREIGN <span class="keyword">KEY</span>(m_cid) <span class="keyword">REFERENCES</span> course(cid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER |</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_modify <span class="keyword">AFTER</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> mark</span><br><span class="line">    <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> retakingmark <span class="keyword">SET</span></span><br><span class="line">            m_sid=NEW.sid,m_cid=NEW.cid,m_score=NEW.score,retaking_times=retaking_times+<span class="number">1</span>,m_time=<span class="keyword">now</span>(),original_score=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">UPDATE</span> retakingmark</span><br><span class="line"><span class="keyword">SET</span> original_score = OLD.score <span class="keyword">WHERE</span> retaking_times = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> |</span><br><span class="line">#做测试</span><br><span class="line"><span class="keyword">UPDATE</span> mark <span class="keyword">SET</span> score = score + <span class="number">3</span> <span class="keyword">WHERE</span> cid = (<span class="keyword">SELECT</span> cid <span class="keyword">FROM</span> course <span class="keyword">WHERE</span> cname = <span class="string">'chemistry'</span>) <span class="keyword">AND</span> <span class="keyword">sid</span> = (<span class="keyword">SELECT</span> <span class="keyword">sid</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sname = <span class="string">'Tom'</span>);</span><br></pre></td></tr></table></figure><h4 id="创建索引来加快系统查询"><a href="#创建索引来加快系统查询" class="headerlink" title="创建索引来加快系统查询"></a>创建索引来加快系统查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (column_name)</span><br></pre></td></tr></table></figure><p>这样如果有某些列被频繁查询的话，通过索引可以加快查询速度。要注意的是，索引过多，会导致数据库体积增大，因为维护索引，还会降低数据库增删改查的性能。因此我们可以在实际应用场景中，使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'handler_read%'</span>;</span><br></pre></td></tr></table></figure><p>来显示一个行的请求次数。若值较高则意味着在此行建立索引是高效的。若值较低则意味着增加索引所带来的性能改善不够理想。</p><h4 id="学生成绩系统的权限分配"><a href="#学生成绩系统的权限分配" class="headerlink" title="学生成绩系统的权限分配"></a>学生成绩系统的权限分配</h4><p>成绩数据库是非常重要的，为了防止误删数据，我们通常要限制用户的权限，除了最高级管理员，其他人不能修改成绩。于是我们可以创建不同权限的账户。</p><p>一般地账户权限信息被存储在mysql数据库中的<code>user</code>、<code>db</code>、<code>host</code>、<code>tables_priv</code>、<code>columns_priv</code>和<code>procs_priv</code>表中。</p><p>以下面代码为例指明了</p><p>权限对象是在localhost上运行的mysql服务中的gradesystem中所有数据表</p><p>用户名是try，密码是123456</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> gradesystem.* <span class="keyword">TO</span> <span class="string">'try'</span>@<span class="string">'localhost'</span></span><br><span class="line">    <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">权限可以是这些：SELECT,INSERT,UPDATE,DELETE,CREATE,DROP</span><br></pre></td></tr></table></figure><p>于是try用户只能查询成绩，不能作任何修改操作了</p><h4 id="简化学生成绩系统中的数据操作"><a href="#简化学生成绩系统中的数据操作" class="headerlink" title="简化学生成绩系统中的数据操作"></a>简化学生成绩系统中的数据操作</h4><p>有时候我们想简化数据库查询操作，于是可以建立子过程，子程序。</p><p>默认情况下，子程序与当前数据库关联。要明确地把子程序与一个给定数据库关联起来，可以在创建子程序的时候指定其名字为<code>db_name.sp_name</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> sp_name ([proc_parameter[,...]])</span><br><span class="line">    [characteristic ...] routine_body</span><br></pre></td></tr></table></figure><p>官方文档不是很好读，看下范例就好了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER |</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> math_show ()</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">SELECT</span> cname,sname,score <span class="keyword">FROM</span> course,student,mark <span class="keyword">WHERE</span></span><br><span class="line">            course.cid=mark.cid <span class="keyword">AND</span></span><br><span class="line">            student.sid=mark.sid <span class="keyword">AND</span></span><br><span class="line">            cname=<span class="string">'math'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>;</span><br><span class="line">    <span class="keyword">END</span> |</span><br><span class="line"><span class="keyword">CALL</span> math_show();</span><br></pre></td></tr></table></figure><p>这样我们就创建了显示所有学生数学成绩的函数了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据库小实验实验报告&quot;&gt;&lt;a href=&quot;#数据库小实验实验报告&quot; class=&quot;headerlink&quot; title=&quot;数据库小实验实验报告&quot;&gt;&lt;/a&gt;数据库小实验实验报告&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>科研方向选择的一点小思考</title>
    <link href="http://yyhyplxyz.github.io/2018/03/21/%E7%A7%91%E7%A0%94%E6%96%B9%E5%90%91%E9%80%89%E6%8B%A9%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%8F%E6%80%9D%E8%80%83/"/>
    <id>http://yyhyplxyz.github.io/2018/03/21/科研方向选择的一点小思考/</id>
    <published>2018-03-21T01:12:19.000Z</published>
    <updated>2018-03-21T01:28:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><p><img src="http://p35v64prn.bkt.clouddn.com/IMG_5703.JPG" alt="git"></p><p>​    </p><p>​    我觉得出现了上图现象有个原因，人做事一般都要有点奖励和预期奖励来促进多巴胺生产，让自己快乐，也让自己有成就感，成就感也能增加人存在的意义感。机器学习的应用跟做程序开发很像，不需要很多功夫就能打出来很好玩或者很有用的应用。应用打出来的时候也是成就感高涨的时候，会激励自己去做下一个，所以我感觉即使在行业工资差不多的情况下喜欢编程，乐此不疲打代码的很明显比喜欢做会计，乐此不疲来做帐的多。</p><p>​    做科研和做工程不太一样，做科研很少听说研究成果能应用啥的，蛟龙号，神州，还有做核弹研发的大部分是工程师或者科学家客串工程师。只有机器学习这个领域是即做科学研究又做工程师，所以即使这类方向的毕业生工资没那么高，做这类研究的人相对也会比较多的。现在区块链的研究虽然也会有应用前景，但从我浅薄的知识来看他的应用局限在记录的可信度方面，想比机器学习不是很有趣，而且我感觉区块链该有的东西差不多都有了，比特币都能造出来了。人民日报说拿区块链记账也应该不存在理论上的问题，缺的只是工程师了。各国央行都有说要推行数字货币的，不难推测已经不存在技术难题，剩下的是社会经济制度的变革方面的考虑。</p><p>​    所以，我觉得区块链相比机器学习更缺的是工程师而不是科学家。而区块链在科研界的热度应该可以类比pc时代软件开发技术的科研热度，移动端时代网络通信方面的研究热度。（我也不清楚那时候这些面热不热门 QUQ）</p><p>​    大胆的预测下，数字货币真的发行的话，很多金融机构应该会凉凉。在那个时代，一切企业的消费记录和信用记录都是公开透明的，金融的信息不对称性会大大降低，投行起码不能从发行承销上赚钱。（而这已经初见端倪，因为科技公司的强势崛起，google和阿里的ipo案例里，都是投行把客户当成大爷，这跟以往投行话语权远超上市公司是截然不同的）。甚至我觉得区块链自身就具有记账功能，在实现了电子货币的前提下，会计填平账目，审计支出都是个伪命题，区块链开发工程师会或多或少地会计的职能。因为我对金融领域也不是很理解，这部分臆想的成分较多</p><p>​    我看国家在2016年发布135国家战略发展规划中，人工智能占了两个栏目，大数据/数据挖掘占了一个栏目，物联网占了一个栏目。我国从汉代开始就有着官山海的中央金融集权制度，既从科技发展趋势来看，又从国家支持的角度来看，人工智能不管还能不能在科研界火下去，在工业界应该会挺长时间都是热门，但准入门槛应该会逐步降低（类似软件开发的学习门槛相比移动端开始的时期也降低了挺多的）</p><p>​    武辉老师一直都想蹭一个热点，比如区块链，其实从科研的角度来说，我个人认为不是热点才是常态，现在机器学习的研究本身就能作为工业应用，最多的paper从企业的实验室里出出来本身就是很特殊的。</p><p>​    从科研成果的角度我不清楚怎么样好发论文，但我觉得从吸引学生的角度来讲区块链方面不是很好找热点的话，不如更多的注重物联网方面，阿里巴巴在马来西亚和杭州都建立了智能城市，（目前还只用在了交通方面，但以后用在其他方面时肯定很需要很多的计算力，这样老师研究的云计算/雾计算都还比较有用武之地了）除此之外，国家对新零售战略很注重，阿里花90亿美金收购了饿了吗，腾讯收购了沃尔玛。我看了下阿里旗下新零售盒马生鲜的报道，里面提及了特别注重供货商的及时送货和送货路线规划，算法层面感觉会用到运筹学的理论，数据情景也和老师研究的问题挺像的。</p><p>​    如果有大佬看了，轻拍吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p35v64prn.bkt.clouddn.com/IMG_5703.JPG&quot; alt=&quot;git&quot;&gt;&lt;/p&gt;
&lt;p&gt;​    &lt;/p&gt;
&lt;p&gt;​    我觉得出现了上图现象有个原因，人做事一般都要有点奖励和预期奖励
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>xgboost</title>
    <link href="http://yyhyplxyz.github.io/2018/03/16/xgboost/"/>
    <id>http://yyhyplxyz.github.io/2018/03/16/xgboost/</id>
    <published>2018-03-16T15:57:19.000Z</published>
    <updated>2018-03-17T16:23:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装过程中出现的问题"><a href="#安装过程中出现的问题" class="headerlink" title="安装过程中出现的问题"></a>安装过程中出现的问题</h2><p>按照brew install gcc@5 pip install xgboost的方式安装出错，经过查阅stackoverflow和仔细阅读报错说明，“command python setup.py egg_info failer with error 1” 可以认定pip安装时少安装了链接文件，感觉这是在做pip安装包的bug。MAC电脑多半会出现这个错误，于是将解决方案分享给大家。</p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-3-15.4.png" alt="git"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive https://github.com/dmlc/xgboost.git</span><br><span class="line"></span><br><span class="line">cd xgboost</span><br><span class="line"></span><br><span class="line">./build.sh</span><br><span class="line"></span><br><span class="line">cd python-package</span><br><span class="line"></span><br><span class="line">python3 setup.py install</span><br></pre></td></tr></table></figure><p>运行以上命令即可，其实就是从github上下载源码然后来编译啦。</p><h2 id="简单利用xgboost来提高分类性能"><a href="#简单利用xgboost来提高分类性能" class="headerlink" title="简单利用xgboost来提高分类性能"></a>简单利用xgboost来提高分类性能</h2><p>据说这是一个非常强大的库，可以直线提高原有模型的准确度。如果对它的原理和参数具体调优设置有兴趣的可以移步到这个<a href="http://blog.csdn.net/sb19931201/article/details/52557382" target="_blank" rel="noopener">博文</a>，在下才疏学浅，就讲讲自己的简单认识吧：</p><p>xgboost的基本算法原型是决策树</p><p>决策树模型的基础上进行对样本重抽样，然后多个树平均 就得到了 Tree bagging算法</p><p>Tree bagging 算法基础上进行对特征的随机挑选就形成了随机森林算法</p><p>随机森林中多个决策树进行加权平均就得到了Boosing算法</p><p>Boosting算法一般会出现过拟合现象，于是加入了惩罚因子，树越深，因子越大，同时加入了并行计算的方法就形成了现有的 xgboosting算法了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xgboost <span class="keyword">import</span> XGBClassifier</span><br><span class="line">params=&#123;</span><br><span class="line"><span class="string">'booster'</span>:<span class="string">'gbtree'</span>,</span><br><span class="line"><span class="string">'objective'</span>: <span class="string">'multi:softmax'</span>, <span class="comment">#多分类的问题</span></span><br><span class="line"><span class="string">'num_class'</span>:<span class="number">10</span>, <span class="comment"># 类别数，与 multisoftmax 并用</span></span><br><span class="line"><span class="string">'gamma'</span>:<span class="number">0.1</span>,  <span class="comment"># 用于控制是否后剪枝的参数,越大越保守，一般0.1、0.2这样子。</span></span><br><span class="line"><span class="string">'max_depth'</span>:<span class="number">12</span>, <span class="comment"># 构建树的深度，越大越容易过拟合</span></span><br><span class="line"><span class="string">'lambda'</span>:<span class="number">2</span>,  <span class="comment"># 控制模型复杂度的权重值的L2正则化项参数，参数越大，模型越不容易过拟合。</span></span><br><span class="line"><span class="string">'subsample'</span>:<span class="number">0.7</span>, <span class="comment"># 随机采样训练样本</span></span><br><span class="line"><span class="string">'colsample_bytree'</span>:<span class="number">0.7</span>, <span class="comment"># 生成树时进行的列采样</span></span><br><span class="line"><span class="string">'min_child_weight'</span>:<span class="number">3</span>, </span><br><span class="line"><span class="comment"># 这个参数默认是 1，是每个叶子里面 h 的和至少是多少，对正负样本不均衡时的 0-1 分类而言</span></span><br><span class="line"><span class="comment">#，假设 h 在 0.01 附近，min_child_weight 为 1 意味着叶子节点中最少需要包含 100 个样本。</span></span><br><span class="line"><span class="comment">#这个参数非常影响结果，控制叶子节点中二阶导的和的最小值，该参数值越小，越容易 overfitting。 </span></span><br><span class="line"><span class="string">'silent'</span>:<span class="number">0</span> ,<span class="comment">#设置成1则没有运行信息输出，最好是设置为0.</span></span><br><span class="line"><span class="string">'eta'</span>: <span class="number">0.007</span>, <span class="comment"># 如同学习率</span></span><br><span class="line"><span class="string">'seed'</span>:<span class="number">1000</span>, <span class="comment">#随机种子</span></span><br><span class="line"><span class="string">'nthread'</span>:<span class="number">7</span>,<span class="comment"># cpu 线程数</span></span><br><span class="line"><span class="comment">#'eval_metric': 'auc'</span></span><br><span class="line">&#125;</span><br><span class="line">clf = XGBClassifier(params)</span><br><span class="line">Learn=CalibratedClassifierCV(clf, method=<span class="string">'isotonic'</span>, cv=<span class="number">2</span>)</span><br><span class="line">Learn.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装过程中出现的问题&quot;&gt;&lt;a href=&quot;#安装过程中出现的问题&quot; class=&quot;headerlink&quot; title=&quot;安装过程中出现的问题&quot;&gt;&lt;/a&gt;安装过程中出现的问题&lt;/h2&gt;&lt;p&gt;按照brew install gcc@5 pip install xgboo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>线性回归实现</title>
    <link href="http://yyhyplxyz.github.io/2018/03/16/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yyhyplxyz.github.io/2018/03/16/线性回归实现/</id>
    <published>2018-03-16T06:52:13.000Z</published>
    <updated>2018-03-16T15:54:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一元回归基本实现与向量化"><a href="#一元回归基本实现与向量化" class="headerlink" title="一元回归基本实现与向量化"></a>一元回归基本实现与向量化</h2><p>线性回归本质上是处理最优化的问题，即找到a和b，使得$\sum(y<em>{i} - ax</em>{i} - b)^2$  的值                                      尽可能小。</p><p>公式推导如下图</p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-3-15.1.JPG" alt="git"></p><p>接着让我们来实现一元线性回归的方法吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearRegression</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a = <span class="number">0</span></span><br><span class="line">        self.b = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, x_train,y_train)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> x_train.ndim == y_train.ndim == <span class="number">1</span>, <span class="string">"This is a single variable LinearRegression model"</span></span><br><span class="line">        <span class="keyword">assert</span> len(x_train) == len(y_train), <span class="string">"the size of x_train must equal to the size of y_train"</span></span><br><span class="line">        x_mean = np.mean(x_train)</span><br><span class="line">        y_mean = np.mean(y_train)</span><br><span class="line">        <span class="comment">#基本实现</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        numerator = 0.0</span></span><br><span class="line"><span class="string">        denominator = 0.0</span></span><br><span class="line"><span class="string">        for x, y in zip(x_train, y_train):</span></span><br><span class="line"><span class="string">            numerator += (x*y-x*y_mean)</span></span><br><span class="line"><span class="string">            denominator += (x*x - x*x_mean)</span></span><br><span class="line"><span class="string">        self.a = numerator / denominator</span></span><br><span class="line"><span class="string">        self.b = y_mean - self.a * x_mean</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment">#向量化实现</span></span><br><span class="line">        self.a = (x_train - x_mean).dot(y_train - y_mean) / (x_train - x_mean).dot(x_train - x_mean)</span><br><span class="line">        self.b = y_mean - self.a * x_mean</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, topredict)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> topredict.ndim == <span class="number">1</span>, <span class="string">"This is a single variable LinearRegression model"</span></span><br><span class="line">        <span class="keyword">assert</span> self.a <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> self.b <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>, <span class="string">"Must fit before"</span></span><br><span class="line">        <span class="keyword">return</span> np.array([self._predict(i) <span class="keyword">for</span> i <span class="keyword">in</span> topredict])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_predict</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.a * x + self.b</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accuracy_score</span><span class="params">(self, y_true, y_predict)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> y_true.shape[<span class="number">0</span>] == y_predict.shape[<span class="number">0</span>], <span class="string">"the size of y_true must be equal to the size of y_predict"</span></span><br><span class="line">        <span class="keyword">return</span> sum(y_true == y_predict) / len(y_true)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, x_test, y_test)</span>:</span></span><br><span class="line">        y_predict = self.predict(x_test)</span><br><span class="line">        <span class="keyword">return</span> self.accuracy_score(y_test, y_predict)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"My single variable simpleLinearRegression"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>, <span class="number">5.</span>])</span><br><span class="line">y = np.array([<span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>])</span><br><span class="line">model = LinearRegression()</span><br><span class="line">model.fit(x,y)</span><br><span class="line">y_1 = model.predict(x)</span><br><span class="line">print(y_1)</span><br><span class="line"><span class="comment">#print(model.score(y_1, y))</span></span><br></pre></td></tr></table></figure><p>事实上我在上图中推导的公式并非最简的，经过下图的推导可以进一步简化。</p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-3-15.2.JPG" alt="git"></p><p>同时代码方面也可以优化成向量的形式，通过向量运算而非循环迭代可以极大地提高cpu计算效率，而且编译器／操作系统会自发地执行并行计算，加快计算速度。</p><p>代码上面部分中就可以见到了。</p><h2 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h2><p>多元线性回归最关键的是公式的推导，根据维基百科等现有资料，将推导过程呈现如下。</p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-3-15.3.JPG" alt="git"></p><p>代码的实现是蛮容易的，也是像上文一样调用numpy的内置函数做向量化运算的处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearRegression</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.coefficient = <span class="keyword">None</span></span><br><span class="line">        self.intercept_ = <span class="keyword">None</span></span><br><span class="line">        self._theta = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit_normal</span><span class="params">(self, X_train, y_train)</span>:</span></span><br><span class="line">        X_b = np.hstack([np.ones((len(X_train), <span class="number">1</span>)), X_train])</span><br><span class="line">        self._theta = np.linalg.inv(X_b.T.dot(X_b)).dot(X_b.T).dot(y_train)</span><br><span class="line">        self.intercept_ = self._theta[<span class="number">0</span>]</span><br><span class="line">        self.coefficient = self._theta[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X_predict)</span>:</span></span><br><span class="line">        X_b = np.hstack([np.ones((len(X_predict), <span class="number">1</span>)), X_predict])</span><br><span class="line">        <span class="keyword">return</span> X_b.dot(self._theta)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"My Multivariable LinearRegression"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一元回归基本实现与向量化&quot;&gt;&lt;a href=&quot;#一元回归基本实现与向量化&quot; class=&quot;headerlink&quot; title=&quot;一元回归基本实现与向量化&quot;&gt;&lt;/a&gt;一元回归基本实现与向量化&lt;/h2&gt;&lt;p&gt;线性回归本质上是处理最优化的问题，即找到a和b，使得$\su
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>sklearn中使用KNN的范例</title>
    <link href="http://yyhyplxyz.github.io/2018/03/14/sklearn%E4%B8%AD%E4%BD%BF%E7%94%A8KNN%E7%9A%84%E8%8C%83%E4%BE%8B/"/>
    <id>http://yyhyplxyz.github.io/2018/03/14/sklearn中使用KNN的范例/</id>
    <published>2018-03-14T12:27:49.000Z</published>
    <updated>2018-03-14T12:55:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><p>数据挖掘建模中一个非常常见的应用就是商品购买预测，本文将利用sklearn中的KNN算法来做这个案例，最终展现我们预测结果的二维等高线填充地图和实际结果的散点分布。</p><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>数据格式如下图</p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-3-14.1.png" alt="git"></p><p>常规的做法是要将male和female转换为数值型变量，在本例中暂不做此操作。接着我们要将年龄和预计收入归一化。这是因为收入的数值远大于年龄的数值，考虑到KNN算法的特性，不如此的话将导致收入的影响极大，年龄影响极小。于是我们采用了均值方差归一化的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">sc = StandardScaler()</span><br><span class="line">X_train = sc.fit_transform(X_train)</span><br><span class="line">X_test = sc.transform(X_test)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#绘制我们预测结果的二维等高线填充地图</span></span><br><span class="line">X_set, y_set = X_train, y_train</span><br><span class="line">X1, X2 = np.meshgrid(np.arange(start = X_set[:, <span class="number">0</span>].min() - <span class="number">1</span>, stop = X_set[:, <span class="number">0</span>].max() + <span class="number">1</span>, step = <span class="number">0.01</span>),</span><br><span class="line">                     np.arange(start = X_set[:, <span class="number">1</span>].min() - <span class="number">1</span>, stop = X_set[:, <span class="number">1</span>].max() + <span class="number">1</span>, step = <span class="number">0.01</span>))</span><br><span class="line">plt.contourf(X1, X2, classifier.predict(np.array([X1.ravel(), X2.ravel()]).T).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="number">0.75</span>, cmap = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>)))<span class="comment">#根据我们的预测值0，1来确定不同点\区域的颜色是红或者绿</span></span><br><span class="line">plt.xlim(X1.min(), X1.max())</span><br><span class="line">plt.ylim(X2.min(), X2.max())</span><br></pre></td></tr></table></figure><p>显示如下</p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-3-14.2.png" alt="git"></p><p>最终我们将实际的结果以散点图的形式绘制出来，同样以红绿两色表示二分类问题。</p><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(np.unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set == j, <span class="number">0</span>], X_set[y_set == j, <span class="number">1</span>],</span><br><span class="line">                c = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>))(i), label = j)</span><br><span class="line">            </span><br><span class="line">plt.title(<span class="string">'K-NN (Training set)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Age'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Estimated Salary'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="http://p35v64prn.bkt.clouddn.com/2018-3-14.3.png" alt="git"></p><p>全部代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dataset = pd.read_csv(<span class="string">'Social_Network_Ads.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, [<span class="number">2</span>, <span class="number">3</span>]].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">4</span>].values</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.25</span>, random_state = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">sc = StandardScaler()</span><br><span class="line">X_train = sc.fit_transform(X_train)</span><br><span class="line">X_test = sc.transform(X_test)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line">classifier = KNeighborsClassifier(n_neighbors = <span class="number">5</span>, metric = <span class="string">'minkowski'</span>, p = <span class="number">2</span>)</span><br><span class="line">classifier.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">y_pred = classifier.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line">cm = confusion_matrix(y_test, y_pred)</span><br><span class="line"><span class="comment"># Visualising the Training set results</span></span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">X_set, y_set = X_train, y_train</span><br><span class="line">X1, X2 = np.meshgrid(np.arange(start = X_set[:, <span class="number">0</span>].min() - <span class="number">1</span>, stop = X_set[:, <span class="number">0</span>].max() + <span class="number">1</span>, step = <span class="number">0.01</span>),</span><br><span class="line">                     np.arange(start = X_set[:, <span class="number">1</span>].min() - <span class="number">1</span>, stop = X_set[:, <span class="number">1</span>].max() + <span class="number">1</span>, step = <span class="number">0.01</span>))</span><br><span class="line">plt.contourf(X1, X2, classifier.predict(np.array([X1.ravel(), X2.ravel()]).T).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="number">0.75</span>, cmap = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>)))</span><br><span class="line">plt.xlim(X1.min(), X1.max())</span><br><span class="line">plt.ylim(X2.min(), X2.max())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(np.unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set == j, <span class="number">0</span>], X_set[y_set == j, <span class="number">1</span>],</span><br><span class="line">                c = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>))(i), label = j)</span><br><span class="line">            </span><br><span class="line">plt.title(<span class="string">'K-NN (Training set)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Age'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Estimated Salary'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">from matplotlib.colors import ListedColormap</span></span><br><span class="line"><span class="string">X_set, y_set = X_test, y_test</span></span><br><span class="line"><span class="string">X1, X2 = np.meshgrid(np.arange(start = X_set[:, 0].min() - 1, stop = X_set[:, 0].max() + 1, step = 0.01),</span></span><br><span class="line"><span class="string">                     np.arange(start = X_set[:, 1].min() - 1, stop = X_set[:, 1].max() + 1, step = 0.01))</span></span><br><span class="line"><span class="string">plt.contourf(X1, X2, classifier.predict(np.array([X1.ravel(), X2.ravel()]).T).reshape(X1.shape),</span></span><br><span class="line"><span class="string">             alpha = 0.75, cmap = ListedColormap(('red', 'green')))</span></span><br><span class="line"><span class="string">plt.xlim(X1.min(), X1.max())</span></span><br><span class="line"><span class="string">plt.ylim(X2.min(), X2.max())</span></span><br><span class="line"><span class="string">for i, j in enumerate(np.unique(y_set)):</span></span><br><span class="line"><span class="string">    plt.scatter(X_set[y_set == j, 0], X_set[y_set == j, 1],</span></span><br><span class="line"><span class="string">                c = ListedColormap(('red', 'green'))(i), label = j)</span></span><br><span class="line"><span class="string">plt.title('K-NN (Test set)')</span></span><br><span class="line"><span class="string">plt.xlabel('Age')</span></span><br><span class="line"><span class="string">plt.ylabel('Estimated Salary')</span></span><br><span class="line"><span class="string">plt.legend()</span></span><br><span class="line"><span class="string">plt.show()</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;导论&quot;&gt;&lt;a href=&quot;#导论&quot; class=&quot;headerlink&quot; title=&quot;导论&quot;&gt;&lt;/a&gt;导论&lt;/h2&gt;&lt;p&gt;数据挖掘建模中一个非常常见的应用就是商品购买预测，本文将利用sklearn中的KNN算法来做这个案例，最终展现我们预测结果的二维等高线填充地
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>sql语言优化（1）</title>
    <link href="http://yyhyplxyz.github.io/2018/03/14/sql%E8%AF%AD%E8%A8%80%E5%88%9D%E6%8E%A2/"/>
    <id>http://yyhyplxyz.github.io/2018/03/14/sql语言初探/</id>
    <published>2018-03-14T06:24:12.000Z</published>
    <updated>2018-03-17T15:55:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h1><p>sql语言不是图灵完备的，顾名思义，它是不能作出图灵机的。从中也可以见的它的语法是蛮简单的。</p><h2 id="几个基本优化方法"><a href="#几个基本优化方法" class="headerlink" title="几个基本优化方法"></a>几个基本优化方法</h2><p>虽然基本语法很简单，大家看看就会了。但是每一个数据提取，修改的操作效率都具有很大提升空间。</p><h3 id="使用join-代替in"><a href="#使用join-代替in" class="headerlink" title="使用join 代替in"></a>使用join 代替in</h3><p>在这个博客地址中<a href="http://openxtiger.iteye.com/blog/1911228" target="_blank" rel="noopener">http://openxtiger.iteye.com/blog/1911228</a> ，作者做了实验证明了join操作会比子查询效率高很多。事实上，子查询操作要循环多次查找子表，耗时较多，而join方法会将多个表格连接起来，可以避免多次循环查找的问题。</p><p>比如下面这两个写法是等价的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> hotel_info_original <span class="keyword">as</span> c </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> hotel_info_collection h </span><br><span class="line"><span class="keyword">on</span> c.hotel_type=h.hotel_type <span class="keyword">and</span> c.hotel_id =h.hotel_id </span><br><span class="line"><span class="keyword">where</span> h.hotel_id <span class="keyword">is</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c.* <span class="keyword">from</span> hotel_info_original </span><br><span class="line"><span class="keyword">where</span> c.hotel_id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> h.hotel_id <span class="keyword">from</span>  hotel_info_collection <span class="keyword">where</span> h.hotel_type = c.hotel_type)</span><br></pre></td></tr></table></figure><p>Left join是左连接，即从左表(A)产生一套完整的记录,与匹配的记录(右表(B)) .如果没有匹配,右侧将包含null</p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-3-16.1.png" alt="git"></p><p>实际上它是将左表和右表完全拼接起来，不满足on中条件的全部变成NULL。因此在数据库操作过程中，要尽量的多将语句写在on中，这样可以减少where查询时间，也能够提高效率。还不理解的，可以看下图实例再揣摩一下</p><p><img src="http://p35v64prn.bkt.clouddn.com/2018-3-16.2.png" alt="git"></p><h3 id="使用工具进行大表修改"><a href="#使用工具进行大表修改" class="headerlink" title="使用工具进行大表修改"></a>使用工具进行大表修改</h3><p>我们知道在实际应用过程中，当对大表进行修改数据类型时，会造成数据库结构较大的变动。此时mysql会锁表，一切请求只能读不能写，造成大量请求排队，效率极低。因此一个改进的办法就是在主服务器重新建一个表，在旧表上每个entry都安装触发器，修改的请求将会在旧表上进行。这些变化再同步到新表中。</p><p>实际编程较繁琐，起码我不会QUQ</p><p>但是大佬们帮我们封装好了工具，那就是<a href="https://www.percona.com/doc/percona-toolkit/LATEST/pt-online-schema-change.html" target="_blank" rel="noopener">pt-online-schema-change</a>，自己去官网上免费下载安装就好啦。</p><p>基本参数信息如下</p><ul><li><p><code>--host=xxx --user=xxx --password=xxx</code><br>连接实例信息，缩写<code>-h xxx -u xxx -p xxx</code>，密码可以使用参数<code>--ask-pass</code> 手动输入。</p></li><li><p><code>--alter</code></p><p>结构变更语句</p></li></ul><ul><li><code>D=db_name,t=table_name</code><br>指定要ddl的数据库名和表名</li><li><code>--execute</code><br>确定修改表，则指定该参数。真正执行alter。</li><li><code>--execute</code><br>确定修改表，则指定该参数。真正执行alter。–dry-run与–execute必须指定一个，二者相互排斥</li><li><code>--execute</code><br>确定修改表，则指定该参数。真正执行alter。–dry-run与–execute必须指定一个，二者相互排斥</li><li><code>--execute</code><br>确定修改表，则指定该参数。真正执行alter。–dry-run与–execute必须指定一个，二者相互排斥</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-<span class="keyword">change</span> -ujacky -p xxx -h <span class="string">"10.0.201.34"</span> D=confluence,t=sbtest3 \</span><br><span class="line"><span class="comment">--alter "CHANGE pad f_pad varchar(60) NOT NULL DEFAULT '' " \</span></span><br><span class="line"><span class="comment">--execute</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本认识&quot;&gt;&lt;a href=&quot;#基本认识&quot; class=&quot;headerlink&quot; title=&quot;基本认识&quot;&gt;&lt;/a&gt;基本认识&lt;/h1&gt;&lt;p&gt;sql语言不是图灵完备的，顾名思义，它是不能作出图灵机的。从中也可以见的它的语法是蛮简单的。&lt;/p&gt;
&lt;h2 id=&quot;几个基
      
    
    </summary>
    
    
  </entry>
  
</feed>
